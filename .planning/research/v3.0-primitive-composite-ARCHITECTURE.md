# Architecture Research: Primitive/Composite Separation

**Domain:** TSX-to-Markdown compiler restructuring
**Researched:** 2026-01-31
**Overall Confidence:** HIGH (based on detailed codebase analysis)

## Executive Summary

This document analyzes how to restructure the react-agentic compiler to support user-definable composite components while keeping primitives in the compiler. The key insight is that the current architecture already has most of the necessary infrastructure, but the transformer conflates "what to transform" with "how components compose."

The restructuring requires:
1. Clear primitive/composite classification
2. Content node type abstraction for sub-components
3. Variable/function reference `.ref` properties for printing
4. Composite components as plain TSX that compose primitives (processed before transformation)

## Current Architecture Analysis

### Pipeline Overview

```
Parse (ts-morph) --> Transform (IR nodes) --> Emit (Markdown)
     |                      |                      |
  parser.ts           transformer.ts          emitter.ts
                      runtime-dispatch.ts     runtime-markdown-emitter.ts
```

### Component Classification (Current State)

The current codebase implicitly classifies components but doesn't formalize the distinction:

**Hard-coded in SPECIAL_COMPONENTS set (transformer.ts:123-138):**
```typescript
const SPECIAL_COMPONENTS = new Set([
  'Command', 'Markdown', 'XmlBlock', 'Agent', 'SpawnAgent', 'Assign', ...
  'If', 'Else', 'Loop', 'Break', 'Return', 'AskUser',
  'ExecutionContext', 'SuccessCriteria', 'OfferNext', 'XmlSection',
  'Step', 'Bash', 'ReadFiles', 'PromptTemplate', 'Table', 'List',
]);
```

**Custom component detection (transformer.ts:148-153):**
```typescript
export function isCustomComponent(tagName: string): boolean {
  if (HTML_ELEMENTS.has(tagName)) return false;
  if (SPECIAL_COMPONENTS.has(tagName)) return false;
  return /^[A-Z]/.test(tagName);
}
```

### IR Node Structure

Two main content node unions exist:

1. **BaseBlockNode** (nodes.ts:365-388) - Non-runtime nodes
2. **BlockNode** (runtime-nodes.ts:363) - Union of BaseBlockNode + RuntimeBlockNode

The distinction is important: some nodes are "document-level" (can appear at top level), while others need to be children of specific containers.

## Proposed Primitive/Composite Classification

### Primitives (Stay in Compiler)

**Definition:** Components that map directly to IR nodes and emit specific markdown constructs. Users cannot redefine what they output.

#### Document Wrappers (Root-level only)
| Component | IR Node | Emits |
|-----------|---------|-------|
| `Command` | `DocumentNode` | Markdown document with frontmatter |
| `Agent` | `AgentDocumentNode` | Agent markdown with YAML frontmatter |
| `Skill` | `SkillDocumentNode` | Skill directory with SKILL.md |
| `MCPConfig` | `MCPConfigDocumentNode` | settings.json fragment |
| `State` | `StateDocumentNode` | SQLite skill files |

#### Content Primitives (Block-level)
| Component | IR Node | Emits |
|-----------|---------|-------|
| `Markdown` | `RawMarkdownNode` | Verbatim markdown content |
| `XmlBlock` | `XmlBlockNode` | `<name>content</name>` |
| `Table` | `TableNode` | Markdown table |
| `List` | `ListNode` | Bullet/numbered list |
| `Bash` | `CodeBlockNode` | Code fence with `bash` language |
| `Step` | `StepNode` | Numbered step (heading/bold/xml variant) |
| `PromptTemplate` | `PromptTemplateNode` | Content in markdown code fence |
| `ReadFiles` | `ReadFilesNode` | Bash file reading commands |
| `Indent` | `IndentNode` | Indented content |

#### Semantic Primitives (Workflow-specific XML structures)
| Component | IR Node | Emits |
|-----------|---------|-------|
| `ExecutionContext` | `ExecutionContextNode` | `<execution_context>` with @-paths |
| `SuccessCriteria` | `SuccessCriteriaNode` | `<success_criteria>` with checkboxes |
| `OfferNext` | `OfferNextNode` | `<offer_next>` with routes |
| `XmlSection` | `XmlBlockNode` | Generic XML wrapper |

#### Runtime Primitives (Control flow and execution)
| Component | IR Node | Emits |
|-----------|---------|-------|
| `If` | `IfNode` | Prose conditional `**If ctx.x:**` |
| `Else` | `ElseNode` | Prose `**Otherwise:**` |
| `Loop` | `LoopNode` | `**Loop up to N times:**` |
| `Break` | `BreakNode` | `**Break loop**` |
| `Return` | `ReturnNode` | `**End command**` |
| `AskUser` | `AskUserNode` | AskUserQuestion tool syntax |
| `SpawnAgent` | `SpawnAgentNode` | Task() syntax |
| `RuntimeFn.Call` | `RuntimeCallNode` | Function call table + bash |

### Composites (User-definable, processed before transformation)

**Definition:** Components that combine primitives into reusable patterns. These are just function calls that return JSX, not special IR nodes.

#### Current Composites (in codebase but not formalized)
| Component | Composes | Notes |
|-----------|----------|-------|
| Local function components | Any primitives | Already supported via `transformLocalComponent` |
| HTML elements (h1-h6, p, div, etc.) | Inline/block primitives | Standard HTML mapping |
| Assign/AssignGroup | Variable operations | Could become composite |
| OnStatus | Conditional block | Could become composite |
| ReadState/WriteState | Skill invocations | Could become composite |

#### Composite Processing Pattern

Composites should be resolved **before** IR transformation:

```
TSX Source --> Resolve Composites --> Expanded TSX --> Transform --> IR --> Emit
                    |
            Function call inlining
            (like macros, not runtime)
```

**Current implementation already does this for local components:**
```typescript
// runtime-dispatch.ts:913-923
if (isCustomComponent(name) && ctx.localComponents.has(name)) {
  const result = transformLocalComponent(node, ctx, transformRuntimeBlockChildren);
  // ...
}
```

## Content Node Type Abstraction

### The Problem

Currently, components that accept children use `BlockNode[]` or `BaseBlockNode[]`, but there's no distinction between:
1. Document-level content (can include any block)
2. Sub-component content (restricted context)

### Proposed Type Hierarchy

```typescript
// Base content types
type InlineContent = InlineNode[];                    // Text, bold, italic, code, links
type BlockContent = BaseBlockNode[];                  // Any non-runtime block
type RuntimeBlockContent = BlockNode[];               // Includes runtime nodes

// Context-specific content types
type DocumentContent = RuntimeBlockContent;           // Top-level command body
type AgentContent = BlockContent;                     // Agent body (no runtime)
type XmlBlockContent = BlockContent;                  // XmlBlock children
type ControlFlowContent = RuntimeBlockContent;       // If/Else/Loop children

// For composites - accepts primitives only
type CompositeContent = (
  | XmlBlockNode
  | TableNode
  | ListNode
  | CodeBlockNode
  | ParagraphNode
  | HeadingNode
  | RawMarkdownNode
)[];
```

### Implementation Location

Create `src/ir/content-types.ts`:

```typescript
/**
 * Content type hierarchy for component children
 *
 * Provides type safety for what content can appear where:
 * - DocumentContent: Full runtime support
 * - StaticContent: No runtime nodes (Agents, Skills)
 * - PrimitiveContent: Only primitive outputs (for composites)
 */

import type { BaseBlockNode, BlockNode } from './nodes.js';
import type { RuntimeBlockNode } from './runtime-nodes.js';

// Inline content (within paragraphs)
export type InlineContent = import('./nodes.js').InlineNode[];

// Static document content (no runtime features)
export type StaticContent = BaseBlockNode[];

// Full runtime content (Commands)
export type RuntimeContent = BlockNode[];

// Primitive-only content (for composite expansion)
export type PrimitiveContent = Exclude<BaseBlockNode,
  | import('./nodes.js').MCPServerNode
  | import('./nodes.js').AssignNode
  | import('./nodes.js').AssignGroupNode
>[];
```

## Variable/Function Reference `.ref` Property

### The Problem

RuntimeVar proxies need a way to emit their reference for printing in markdown. Currently the transformer extracts `__varName` and `__path`, but there's no standard interface for "printable reference."

### Proposed Solution

Add `.ref` property to RuntimeVar and RuntimeFn that returns a printable representation:

```typescript
// In runtime-var.ts
export interface RuntimeVarProxy<T> extends RuntimeVar<T> {
  readonly [K in keyof T]: T[K] extends object
    ? RuntimeVarProxy<T[K]>
    : RuntimeVar<T[K]>;

  /** Printable reference for markdown interpolation */
  readonly ref: string;  // e.g., "ctx.error" or "result.data.count"
}
```

**Implementation in proxy:**

```typescript
function createRuntimeVarProxy<T>(varName: string, path: string[]): RuntimeVarProxy<T> {
  const target = {
    __varName: varName,
    __path: path,
    [RUNTIME_VAR_MARKER]: true,
  };

  return new Proxy(target as unknown as RuntimeVarProxy<T>, {
    get(_target, prop: string | symbol) {
      // Handle ref property
      if (prop === 'ref') {
        const base = varName.toLowerCase();
        return path.length === 0 ? base : `${base}.${path.join('.')}`;
      }
      // ... existing logic
    },
  });
}
```

### Usage in Composites

```tsx
// User-defined composite that uses ref
function StatusCheck({ result }: { result: RuntimeVarProxy<Result> }) {
  return (
    <XmlBlock name="status_check">
      <p>Checking status of {result.ref}...</p>
      <If condition={result.error}>
        <p>Error found in {result.ref}</p>
      </If>
    </XmlBlock>
  );
}
```

## Suggested Build Order

### Phase 1: Type Foundation (Low risk)

**Goal:** Establish content type hierarchy without breaking changes.

1. Create `src/ir/content-types.ts` with type aliases
2. Add `ref` property to RuntimeVar proxy
3. Add `ref` property to RuntimeFn wrapper (for function name reference)
4. Update existing IR node interfaces to use new content types (type-only changes)

**Files modified:**
- `src/ir/content-types.ts` (new)
- `src/ir/index.ts` (export new types)
- `src/components/runtime-var.ts` (add ref)
- `src/components/runtime-fn.ts` (add ref)

**Tests:** Existing tests should pass. Add unit tests for `.ref` property.

### Phase 2: Primitive Classification (Medium risk)

**Goal:** Formalize which components are primitives.

1. Create `src/primitives/index.ts` that exports primitive list
2. Move primitive classification from SPECIAL_COMPONENTS to explicit registry
3. Update `isCustomComponent` to use registry

```typescript
// src/primitives/registry.ts
export const DOCUMENT_PRIMITIVES = ['Command', 'Agent', 'Skill', 'MCPConfig', 'State'] as const;
export const CONTENT_PRIMITIVES = ['Markdown', 'XmlBlock', 'Table', 'List', 'Bash', 'Step', ...] as const;
export const RUNTIME_PRIMITIVES = ['If', 'Else', 'Loop', 'Break', 'Return', 'AskUser', 'SpawnAgent'] as const;

export const ALL_PRIMITIVES = [
  ...DOCUMENT_PRIMITIVES,
  ...CONTENT_PRIMITIVES,
  ...RUNTIME_PRIMITIVES,
] as const;

export function isPrimitive(name: string): boolean {
  return (ALL_PRIMITIVES as readonly string[]).includes(name);
}
```

**Files modified:**
- `src/primitives/registry.ts` (new)
- `src/parser/transformers/shared.ts` (use registry)
- `src/parser/transformer.ts` (use registry)

**Tests:** Existing tests should pass. Add tests for primitive classification.

### Phase 3: Composite Processing Pipeline (High risk)

**Goal:** Enable user-defined composites to expand before transformation.

1. Extract composite resolution logic from transformers
2. Create `src/parser/composite-resolver.ts`
3. Modify pipeline: Parse -> Resolve Composites -> Transform -> Emit

**Key insight:** The current `transformLocalComponent` already handles this for same-file components. The change is to:
1. Generalize to imported components
2. Run resolution as a separate pass
3. Support prop substitution and children composition

**Files modified:**
- `src/parser/composite-resolver.ts` (new)
- `src/parser/transformers/runtime-component.ts` (extract logic)
- `src/parser/transformers/runtime-dispatch.ts` (call resolver first)

**Tests:** Need comprehensive composite expansion tests.

### Phase 4: Sub-Component Content Types (Medium risk)

**Goal:** Enforce content type restrictions via TypeScript.

1. Update component interfaces to use specific content types
2. Add transformer validation for content type mismatches
3. Improve error messages for invalid nesting

```typescript
// Example: XmlBlock only accepts static content
interface XmlBlockProps {
  name: string;
  attributes?: Record<string, string>;
  children?: StaticContent;  // No If/Else/Loop inside XmlBlock in Agent
}
```

**Files modified:**
- `src/components/structured.ts` (update prop types)
- `src/parser/transformers/*.ts` (add validation)
- `src/cli/errors.ts` (better error messages)

**Tests:** Add negative tests for invalid nesting.

## Key Design Decisions

### 1. Composites as Build-Time Macros

Composites are resolved at build time, not runtime. They're essentially macros that expand to primitive trees. This means:
- No composite IR nodes needed
- No composite emission logic needed
- TypeScript provides full type checking
- User composites work the same as built-in composites

### 2. HTML Elements as Syntactic Sugar

HTML elements (h1-h6, p, div, ul, ol, li, etc.) should remain as syntactic sugar, not primitives:
- They map to IR nodes but don't need special handling
- Users can override their behavior (controversial, but powerful)
- Keeps primitive list small and semantic

### 3. Content Type Enforcement: Gradual

Don't enforce content types strictly at first. Start with:
1. Type definitions (documentation value)
2. Runtime warnings (development feedback)
3. TypeScript strict mode (opt-in)
4. Hard errors (once patterns stabilize)

### 4. Backward Compatibility

The restructuring should not break existing commands/agents. Key constraints:
- All SPECIAL_COMPONENTS continue to work as before
- Custom component resolution works as before
- Output markdown is identical

## Anti-Patterns to Avoid

### 1. Don't Add IR Nodes for Composites

Bad: Creating `IfElseNode` that wraps If+Else into one node
Good: Keep If and Else as separate nodes, handle sibling pairing in transformer

### 2. Don't Mix Resolution and Transformation

Bad: Resolving composites during transformation
Good: Resolve all composites first, then transform pure primitive tree

### 3. Don't Over-Specify Content Types

Bad: `XmlBlockAllowedContent = HeadingNode | ParagraphNode | ListNode | ...`
Good: `StaticContent` (broad) with runtime validation for specific cases

## Open Questions

### 1. Should HTML elements be primitives?

Current: Treated as syntactic sugar, not in SPECIAL_COMPONENTS
Option A: Make them explicit primitives (h1-h6, p, div, etc.)
Option B: Keep as syntactic sugar

**Recommendation:** Option B - Keep as sugar. They're universally understood and don't need semantic distinction.

### 2. Should Assign/AssignGroup become composites?

Current: They're primitives with IR nodes
Option A: Keep as primitives (they emit specific bash patterns)
Option B: Make composites that use Bash primitive

**Recommendation:** Keep as primitives. The bash emission is complex enough to warrant dedicated IR.

### 3. How to handle imported composites?

Current: Only same-file components work
Option A: Follow imports and inline
Option B: Require explicit registration

**Recommendation:** Option A - Follow imports. Mirrors how React/JSX works. Use ts-morph's resolution capabilities.

## Two MarkdownContentNode Types

### The Problem from Project Context

The project context mentions needing "Two MarkdownContentNode types (document-level vs sub-component)". This maps to:

1. **Document-level content** - Full markdown with all IR nodes allowed
2. **Sub-component content** - Restricted to specific patterns

### Proposed Solution

```typescript
// Document-level: can contain runtime nodes
export interface DocumentNode {
  kind: 'document';
  children: RuntimeContent;  // BlockNode[] - includes If, Loop, etc.
}

// XmlBlock: static content only in Agent context
export interface XmlBlockNode {
  kind: 'xmlBlock';
  name: string;
  children: StaticContent;  // BaseBlockNode[] - no runtime nodes
}

// However, XmlBlock in Command can contain runtime nodes
// This is a context-dependent rule, not a type-level rule
```

### Context-Dependent Validation

Rather than two separate node types, use context during transformation:

```typescript
interface TransformContext {
  // ...existing fields...

  /** Document type determines what nodes are allowed */
  documentType: 'command' | 'agent' | 'skill';

  /** Current depth in tree (for error messages) */
  depth: number;
}

function validateContent(node: BlockNode, ctx: TransformContext): void {
  if (ctx.documentType === 'agent' && isRuntimeNode(node)) {
    throw ctx.createError(
      `Runtime node '${node.kind}' not allowed in Agent documents`,
      node
    );
  }
}
```

## Summary

The restructuring is feasible with the current architecture. Key changes:

1. **Formalize primitive classification** - Move from implicit SPECIAL_COMPONENTS to explicit registry
2. **Add `.ref` property** - Enable composites to print variable/function references
3. **Content type hierarchy** - Type safety for what goes where
4. **Composite resolution pass** - Expand composites before transformation

The build order progresses from low-risk type changes to high-risk pipeline changes, allowing validation at each step.

## Roadmap Implications

Based on this research:

### Phase 1: Foundation
- Content type definitions
- `.ref` property on RuntimeVar/RuntimeFn
- Primitive registry (no behavior change)

### Phase 2: Separation
- Extract composite resolution
- Two-pass pipeline (resolve then transform)
- Imported composite support

### Phase 3: Validation
- Context-dependent content validation
- Better error messages
- Documentation updates

### Phase 4: User-Facing
- Documentation for writing composites
- Example composites
- Migration guide (if any breaking changes)

## Sources

**HIGH Confidence:**
- Codebase analysis: `src/ir/nodes.ts`, `src/ir/runtime-nodes.ts`
- Transformer patterns: `src/parser/transformer.ts`, `src/parser/transformers/runtime-dispatch.ts`
- Runtime system: `src/components/runtime-var.ts`, `src/components/runtime-fn.ts`
- Emitter patterns: `src/emitter/emitter.ts`, `src/emitter/runtime-markdown-emitter.ts`

**MEDIUM Confidence:**
- Composite expansion: `src/parser/transformers/runtime-component.ts` (existing local component support)
- Content node context: inferred from how different document types process children differently
