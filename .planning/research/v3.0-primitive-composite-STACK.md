# Stack Patterns: Primitive vs Composite Component Separation

**Project:** react-agentic primitive/composite refactor
**Researched:** 2026-01-31
**Confidence:** HIGH (patterns verified from multiple authoritative sources)

## Executive Summary

This research surveys patterns for separating framework-provided primitives from user-definable composites in JSX-based systems. The key insight: **primitives require compiler/renderer knowledge; composites are pure functions that return primitives.**

React, SolidJS, Ink, MDX, and Astro all share a fundamental architectural pattern: a small set of "host" or "intrinsic" elements handled specially by the rendering infrastructure, with all other components being plain functions that compose those primitives.

**Recommendation:** Adopt the React Fiber model where primitives are identified by tag type (string vs function) and composites are functions that the compiler can inline without special transformation.

---

## Pattern 1: React Fiber Host vs Composite

**Source:** [React Fiber Architecture](https://github.com/acdlite/react-fiber-architecture), [React Implementation Notes](https://legacy.reactjs.org/docs/implementation-notes.html)

### The Pattern

React's reconciler distinguishes two component types by their `type` field:

| Type | Fiber Tag | Identification | Handling |
|------|-----------|----------------|----------|
| **Host** | `HostComponent` | `typeof type === 'string'` | Renderer creates native node (DOM, native view) |
| **Composite** | `FunctionComponent` / `ClassComponent` | `typeof type === 'function'` | Call function, recurse on result |

```typescript
// Host component - string type, handled by renderer
{ type: 'div', props: { className: 'foo' } }

// Composite component - function type, called to get elements
{ type: MyComponent, props: { title: 'Hello' } }
```

### Key Insight

The reconciler doesn't need to know what composites do - it just calls them and processes the return value. Only host components require renderer-specific handling.

**For react-agentic:** Primitives like `Command`, `Agent`, `XmlBlock` (that produce IR nodes) are "host" components. Composites like user-defined `<Banner>` or `<IfElse>` wrappers are functions the compiler can inline.

### TypeScript Integration

Host components are typed via `JSX.IntrinsicElements`:

```typescript
declare namespace JSX {
  interface IntrinsicElements {
    // Host components with their prop types
    div: React.DetailedHTMLProps<React.HTMLAttributes<HTMLDivElement>, HTMLDivElement>;
    span: React.DetailedHTMLProps<React.HTMLAttributes<HTMLSpanElement>, HTMLSpanElement>;
    // ... etc
  }
}
```

**Source:** [TypeScript JSX Documentation](https://www.typescriptlang.org/docs/handbook/jsx.html), [Total TypeScript on IntrinsicElements](https://www.totaltypescript.com/what-is-jsx-intrinsicelements)

---

## Pattern 2: SolidJS Primitives vs Components

**Source:** [SolidJS Docs](https://docs.solidjs.com/concepts/components/basics), [Solid Primitives](https://primitives.solidjs.community/), [GitHub](https://github.com/solidjs-community/solid-primitives)

### The Pattern

SolidJS distinguishes three levels:

| Level | Naming Convention | Purpose |
|-------|-------------------|---------|
| **Primary Primitives** | `createSignal`, `createEffect` | Core reactivity (framework) |
| **Secondary Primitives** | `createResource`, `createStore` | Extended reactivity (framework) |
| **Tertiary Primitives** | `createTimer`, `createStorage` | Ecosystem utilities (solid-primitives) |
| **Components** | `<Show>`, `<For>`, user components | JSX that composes primitives |

### Design Rules from Solid Primitives

1. **`create` prefix** = reactive primitive that sets up subscriptions
2. **`make` prefix** = non-reactive foundation (no cleanup needed)
3. **Composable vs Segmented API** = decide if features stack or decompose

### Key Insight

Components are functions that run once at creation time (not on every render like React). This is closer to react-agentic's model where TSX compiles to static markdown.

**For react-agentic:** Consider `make` prefix for IR-producing helpers that don't need reactivity tracking.

---

## Pattern 3: MDX Component Mapping

**Source:** [MDX Using MDX](https://mdxjs.com/docs/using-mdx/), [GitHub Issue #2473](https://github.com/mdx-js/mdx/issues/2473)

### The Pattern

MDX compiles markdown to JSX, then allows component substitution at runtime:

```jsx
// MDX generates:
<h1>Title</h1>
<p>Paragraph</p>

// User provides component map:
<MDXProvider components={{ h1: MyHeading, p: MyParagraph }}>
  <Content />
</MDXProvider>
```

### Compiler Optimization Issue

MDX generates code that supports ALL possible component overrides, even if user only wants one:

```jsx
// Generated (inefficient)
function MDXContent({ components }) {
  const _components = { h1: 'h1', p: 'p', ...components };
  return <_components.h1>...</_components.h1>;
}
```

**Astro's solution:** Detect which components are actually customized and optimize away the rest.

### Key Insight

MDX treats markdown elements (`h1`, `p`) as "intrinsic" elements that can be swapped, and custom components (`<MyWidget />`) as pass-through. The compiler doesn't need special knowledge of custom components.

**For react-agentic:** The `transformCustomComponent` in `markdown.ts` already implements this pattern - resolve import, inline JSX, no special IR node needed.

---

## Pattern 4: Ink Terminal Primitives

**Source:** [Ink GitHub](https://github.com/vadimdemedes/ink), [Ink NPM](https://www.npmjs.com/package/ink)

### The Pattern

Ink is a React renderer for terminals with its own host components:

| Host Component | Purpose | Maps To |
|----------------|---------|---------|
| `<Box>` | Flexbox container | Yoga layout node |
| `<Text>` | Text content | ANSI string output |
| `<Static>` | Non-updating content | Permanent terminal output |
| `<Newline>` | Line break | `\n` |

All user components are composites that return these primitives.

### Key Insight

Custom renderers define their own primitive vocabulary. Ink's primitives are NOT HTML - they're terminal-specific concepts. The reconciler (react-reconciler) handles the host/composite split.

**For react-agentic:** The IR node types (`HeadingNode`, `ParagraphNode`, `XmlBlockNode`, etc.) are the "host" vocabulary. The markdown emitter is the "renderer."

---

## Pattern 5: Astro Server Components

**Source:** [Astro Components Docs](https://docs.astro.build/en/basics/astro-components/), [Framework Components](https://docs.astro.build/en/guides/framework-components/)

### The Pattern

Astro distinguishes:

| Type | File Extension | Rendering |
|------|----------------|-----------|
| **Astro Components** | `.astro` | Server-only, produces HTML |
| **Framework Components** | `.tsx`, `.vue`, `.svelte` | Can hydrate on client |
| **HTML Elements** | lowercase | Pass-through to output |

### Key Insight

Astro is "HTML-first" - the component syntax is a superset of HTML. Standard HTML elements pass through unchanged. Framework components get special bundling/hydration treatment.

**For react-agentic:** HTML elements (`h1`, `p`, `ul`) are already treated as primitives that map to IR nodes. The pattern is sound.

---

## Pattern 6: Unist/MDAST Content Model

**Source:** [Unist](https://github.com/syntax-tree/unist), [MDAST](https://github.com/syntax-tree/mdast)

### The Pattern

The unified ecosystem uses discriminated unions with content categories:

```typescript
// Discriminator field
interface Node {
  type: string;  // 'heading' | 'paragraph' | 'text' | ...
}

// Content categories constrain children
type FlowContent = Blockquote | Code | Heading | List | Paragraph | ThematicBreak;
type PhrasingContent = Break | Emphasis | InlineCode | Link | Strong | Text;

interface Heading extends Node {
  type: 'heading';
  depth: 1 | 2 | 3 | 4 | 5 | 6;
  children: PhrasingContent[];  // Only phrasing allowed
}

interface Paragraph extends Node {
  type: 'paragraph';
  children: PhrasingContent[];
}

interface List extends Node {
  type: 'list';
  children: ListItem[];  // Only list items allowed
}
```

### Key Insight

The `type` field is the discriminator for exhaustive pattern matching. Content categories (`FlowContent`, `PhrasingContent`) constrain valid children at the type level.

**For react-agentic:** The IR already uses `kind` as discriminator (`nodes.ts`). Could adopt content categories more formally:

```typescript
// Current
type BlockNode = HeadingNode | ParagraphNode | ListNode | ...;

// Enhanced with categories
type FlowContent = HeadingNode | ParagraphNode | ListNode | XmlBlockNode | ...;
type InlineContent = TextNode | BoldNode | ItalicNode | LinkNode | ...;

interface HeadingNode {
  kind: 'heading';
  level: 1 | 2 | 3 | 4 | 5 | 6;
  children: InlineContent[];  // Type-safe constraint
}
```

---

## Pattern 7: Children Type Constraints

**Source:** [Total TypeScript](https://www.totaltypescript.com/type-safe-children-in-react-and-typescript), [TypeScript Issue #42498](https://github.com/microsoft/TypeScript/issues/42498)

### The Problem

It's not possible to restrict React children to specific component types at the TypeScript level:

```typescript
// This doesn't actually work
interface SelectProps {
  children: React.ReactElement<OptionProps>[];  // Can't enforce at compile time
}
```

### Why It Fails

When you write JSX, the resultant type is always `JSX.Element` - TypeScript "blackboxes" the element type:

```typescript
const option = <Option value="1">One</Option>;
// type: JSX.Element (not ReactElement<OptionProps>)
```

### Alternatives

1. **Use a prop instead of children:**
   ```tsx
   <Select options={[{ value: '1', label: 'One' }]} />
   ```

2. **Runtime validation:**
   ```tsx
   React.Children.forEach(children, child => {
     if (child.type !== Option) throw new Error('Only Option allowed');
   });
   ```

3. **Accept the limitation** and use `ReactNode` with documentation

### Key Insight

React's children prop is inherently loosely typed. Strict child constraints require either:
- Prop-based APIs (arrays instead of children)
- Runtime validation
- Convention over enforcement

**For react-agentic:** Since we parse at compile-time (not runtime), we CAN enforce children constraints in the transformer. The MDAST content model approach works better than React's pattern here.

---

## Implementation Recommendations for react-agentic

### 1. Use String Tags for Primitives

Follow React's pattern: lowercase strings are HTML primitives, uppercase PascalCase that are in the primitive registry require compiler handling.

```tsx
// HTML primitive (compiler handles, maps to IR)
<h1>Title</h1>

// Component primitive (compiler handles, special IR)
<XmlBlock name="example">Content</XmlBlock>

// Composite (compiler inlines, then sees primitives)
<Banner>Title</Banner>  // => <h1>Title</h1>
```

**Rationale:** This is the universal JSX convention. TypeScript's `JSX.IntrinsicElements` supports it natively.

### 2. Composites Are Just Functions

No special compiler treatment for composites. Just:
1. Find function definition
2. Call with props
3. Process returned JSX (which contains primitives)

**Rationale:** This is how all JSX frameworks work. Keeps compiler simple.

### 3. Document Roots Are Special

`Command` and `Agent` are hybrid - they look like composites (PascalCase) but need compiler treatment (frontmatter extraction, output path).

**Recommendation:** Keep them as special cases in the dispatcher, not as regular primitives. They're "document roots" not content primitives.

### 4. Adopt Content Categories

Use MDAST-style content typing:
- `FlowContent` for block-level
- `PhrasingContent` for inline
- `RuntimeContent` for control flow

**Rationale:** Catches invalid nesting at transform time (inline inside inline, etc.).

### 5. If/Else Can Be Partially Composite

The key insight from the milestone context: `If`/`Else` markdown template structure could be user-definable:

```tsx
// Could be a user-definable composite:
const IfElse = ({ condition, children, elseContent }) => (
  <>
    <Markdown>{`**If ${condition.ref}:**`}</Markdown>
    {children}
    {elseContent && (
      <>
        <Markdown>**Otherwise:**</Markdown>
        {elseContent}
      </>
    )}
  </>
);
```

However, the **condition parsing** (`ctx.error` to jq expression) still needs compiler support. The markdown template is composite, but RuntimeVar property access tracking is primitive.

**Recommendation:** Split the concern:
- **Primitive:** RuntimeVar property access tracking, condition parsing
- **Composite:** If/Else markdown template structure (optional future work)

---

## Summary: Patterns Applied to react-agentic

| Pattern Source | What react-agentic Should Adopt |
|----------------|--------------------------------|
| **React Fiber** | String vs function type discrimination for host vs composite |
| **SolidJS** | `create`/`make` naming for primitives; run-once component model |
| **MDX** | Compiler doesn't need special knowledge of composites |
| **Ink** | Custom primitive vocabulary for target output format |
| **Astro** | HTML-first with component superset |
| **MDAST** | Content categories with discriminated unions |
| **TypeScript Children** | Props-based API or transformer validation, not TS-level constraints |

---

## Sources

### Authoritative (HIGH confidence)
- [TypeScript JSX Documentation](https://www.typescriptlang.org/docs/handbook/jsx.html)
- [React Implementation Notes](https://legacy.reactjs.org/docs/implementation-notes.html)
- [React Fiber Architecture](https://github.com/acdlite/react-fiber-architecture)
- [Unist Specification](https://github.com/syntax-tree/unist)
- [MDAST Specification](https://github.com/syntax-tree/mdast)
- [SolidJS Component Docs](https://docs.solidjs.com/concepts/components/basics)
- [Ink GitHub](https://github.com/vadimdemedes/ink)
- [MDX Using MDX](https://mdxjs.com/docs/using-mdx/)
- [Astro Component Docs](https://docs.astro.build/en/basics/astro-components/)

### Community (MEDIUM confidence)
- [Total TypeScript on IntrinsicElements](https://www.totaltypescript.com/what-is-jsx-intrinsicelements)
- [Total TypeScript on Children Types](https://www.totaltypescript.com/type-safe-children-in-react-and-typescript)
- [Solid Primitives](https://primitives.solidjs.community/)
- [Patterns.dev Compound Pattern](https://www.patterns.dev/react/compound-pattern/)
- [MDX Compiler Optimization Issue #2473](https://github.com/mdx-js/mdx/issues/2473)
- [TypeScript Children Constraint Issue #42498](https://github.com/microsoft/TypeScript/issues/42498)
