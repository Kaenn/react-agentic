---
phase: 05-composition
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/parser/parser.ts
  - src/parser/transformer.ts
  - tests/parser/transformer.test.ts
autonomous: true

must_haves:
  truths:
    - "User can import shared component and use it in Command body"
    - "Composed component's JSX is flattened into parent document"
    - "Only relative imports are supported (throws for package imports)"
    - "Circular imports are detected and throw descriptive error"
    - "Props on composed components throw (not supported in v1)"
  artifacts:
    - path: "src/parser/parser.ts"
      provides: "resolveComponentImport function for import resolution"
      exports: ["resolveComponentImport"]
    - path: "src/parser/transformer.ts"
      provides: "Custom component detection and JSX inlining"
      contains: "isCustomComponent"
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/parser/parser.ts"
      via: "import resolveComponentImport"
      pattern: "resolveComponentImport"
---

<objective>
Implement component composition for shared command fragments

Purpose: Enable users to define reusable TSX fragments in separate files and compose them into commands, promoting DRY patterns across similar commands.

Output: Working component imports with JSX flattening into parent document
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-composition/05-RESEARCH.md

# Relevant source files
@src/parser/parser.ts
@src/parser/transformer.ts
@tests/parser/transformer.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement component import resolution in parser</name>
  <files>src/parser/parser.ts</files>
  <action>
Add functions to resolve component imports and extract their JSX:

1. `resolveComponentImport(componentName: string, sourceFile: SourceFile, visitedPaths?: Set<string>)`:
   - Initialize visitedPaths if not provided
   - Add current sourceFile.getFilePath() to visitedPaths
   - Find import declaration for componentName:
     ```typescript
     const importDecl = sourceFile.getImportDeclaration(decl => {
       const namedImports = decl.getNamedImports();
       return namedImports.some(ni => ni.getName() === componentName);
     });
     ```
   - If not found, throw: `Component '${componentName}' not imported`
   - Validate module specifier starts with '.' (relative import):
     ```typescript
     const specifier = importDecl.getModuleSpecifierValue();
     if (!specifier.startsWith('.')) {
       throw new Error(`Only relative imports supported for components: '${specifier}'`);
     }
     ```
   - Get source file: `importDecl.getModuleSpecifierSourceFile()`
   - If null, throw: `Cannot resolve import for '${componentName}'`
   - Check for circular import (componentSourceFile.getFilePath() in visitedPaths)
   - If circular, throw: `Circular import detected: ${componentName}`
   - Get exported declarations and find component
   - Call extractJsxFromComponent to get JSX
   - Return { jsx, sourceFile: componentSourceFile, visitedPaths }

2. `extractJsxFromComponent(decl: Node)`:
   - Handle FunctionDeclaration: get body
   - Handle VariableDeclaration with ArrowFunction/FunctionExpression: get body
   - Search body for ReturnStatement with JSX
   - Handle ParenthesizedExpression wrapper
   - Return JsxElement | JsxFragment | JsxSelfClosingElement | null

Import from ts-morph: ImportDeclaration

Export: resolveComponentImport function
  </action>
  <verify>
`npm run typecheck` passes with no errors on new functions
  </verify>
  <done>
resolveComponentImport follows imports, extracts JSX, detects circular references, validates relative imports
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate component composition into transformer</name>
  <files>src/parser/transformer.ts, tests/parser/transformer.test.ts</files>
  <action>
Modify transformer to detect and inline custom components:

1. In transformer.ts:
   - Import resolveComponentImport from parser.ts
   - Add constant sets for element classification:
     ```typescript
     const HTML_ELEMENTS = new Set([
       'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
       'p', 'div', 'span', 'ul', 'ol', 'li',
       'a', 'b', 'i', 'strong', 'em', 'code',
       'pre', 'blockquote', 'br', 'hr',
     ]);
     const SPECIAL_COMPONENTS = new Set(['Command', 'Markdown']);
     ```
   - Add helper `isCustomComponent(tagName: string)`:
     - Return false if HTML_ELEMENTS.has(tagName)
     - Return false if SPECIAL_COMPONENTS.has(tagName)
     - Return true if starts with uppercase: /^[A-Z]/.test(tagName)
   - Add `visitedPaths: Set<string>` field to Transformer class
   - Initialize visitedPaths in transform() method
   - In transformElement, before "throw unsupported":
     - Check if isCustomComponent(name)
     - If yes, validate no attributes (throw if props found: "Component props not supported")
     - Call resolveComponentImport(name, sourceFile, visitedPaths)
     - Recursively transform the resolved JSX
     - Return the transformed block(s) - may need to handle fragment returning multiple blocks

2. Handle fragment returns from composed components:
   - If resolved JSX is JsxFragment, transform each child and return first block
   - Log warning or handle gracefully if component returns multiple root blocks

3. In transformer.test.ts, add "Component composition" describe block:
   - Use project.createSourceFile to create both main and component files
   - Test: composed component JSX inlines into parent
   - Test: throws for package imports (non-relative)
   - Test: throws for circular imports
   - Test: throws for component with props

Example test setup:
```typescript
describe('Component composition', () => {
  function transformWithComponents(files: Record<string, string>, mainFile: string) {
    const project = createProject({ inMemory: true });
    for (const [name, content] of Object.entries(files)) {
      project.createSourceFile(name, content);
    }
    const source = project.getSourceFileOrThrow(mainFile);
    const root = findRootJsxElement(source);
    if (!root) throw new Error('No JSX found');
    const transformer = new Transformer();
    return transformer.transform(root);
  }

  it('inlines composed component JSX', () => {
    const files = {
      'shared.tsx': `
        export function Instructions() {
          return <p>Follow these steps</p>;
        }
      `,
      'main.tsx': `
        import { Instructions } from './shared';
        export default function MyCommand() {
          return (
            <Command name="test" description="Test">
              <Instructions />
            </Command>
          );
        }
      `,
    };
    const doc = transformWithComponents(files, 'main.tsx');
    expect(doc.children).toHaveLength(1);
    expect(doc.children[0].kind).toBe('paragraph');
  });
});
```
  </action>
  <verify>
`npm test` passes all existing and new composition-related tests
  </verify>
  <done>
Custom components are detected, resolved via imports, JSX is inlined, errors thrown for invalid cases
  </done>
</task>

</tasks>

<verification>
1. `npm run typecheck` - no type errors
2. `npm test` - all tests pass including new composition tests
3. Manual verification with two files:
   - shared.tsx: export function SharedSection() { return <div name="section"><p>Shared</p></div>; }
   - main.tsx: import and use `<SharedSection />`
   - Output contains the inlined XML block
</verification>

<success_criteria>
- [ ] resolveComponentImport follows import declarations to source files
- [ ] extractJsxFromComponent extracts returned JSX from function components
- [ ] isCustomComponent distinguishes custom from HTML/special elements
- [ ] Transformer inlines resolved component JSX
- [ ] Relative import validation works (throws for package imports)
- [ ] Circular import detection works
- [ ] Props on composed components throw (v1 limitation)
- [ ] All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-composition/05-02-SUMMARY.md`
</output>
