---
phase: 03-full-element-coverage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/parser/parser.ts
  - src/parser/transformer.ts
  - tests/parser/transformer.test.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can write <Command name='x' description='y'> and get valid YAML frontmatter"
    - "User can write <Command allowedTools={['Read', 'Write']}> and get block-style YAML arrays"
    - "Missing required Command props (name, description) throws descriptive error"
    - "Command children become Markdown body below frontmatter"
  artifacts:
    - path: "src/parser/parser.ts"
      provides: "Array attribute extraction via getArrayAttributeValue"
      exports: ["getArrayAttributeValue"]
    - path: "src/parser/transformer.ts"
      provides: "Command element handler producing DocumentNode with frontmatter"
      contains: "transformCommand"
    - path: "tests/parser/transformer.test.ts"
      provides: "Tests for Command transformation"
      contains: "Command component"
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/parser/parser.ts"
      via: "getArrayAttributeValue import"
      pattern: "getArrayAttributeValue"
    - from: "src/parser/transformer.ts"
      to: "DocumentNode.frontmatter"
      via: "transform method assigns frontmatter"
      pattern: "frontmatter:"
---

<objective>
Transform `<Command>` component props into YAML frontmatter for Claude Code slash commands.

Purpose: Enable users to define Claude Code commands with compile-time type safety. The Command component's props (name, description, allowedTools) become the YAML frontmatter that Claude Code requires, while children become the Markdown body.

Output: Extended transformer and parser that handle Command elements, producing DocumentNode with frontmatter field populated from props. Arrays emit as YAML block style (one item per line with `-` prefix).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-full-element-coverage/03-RESEARCH.md
@.planning/phases/03-full-element-coverage/03-CONTEXT.md

# Source files to modify
@src/parser/parser.ts
@src/parser/transformer.ts
@src/ir/nodes.ts
@src/emitter/emitter.ts
@tests/parser/transformer.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add array attribute extraction to parser</name>
  <files>src/parser/parser.ts</files>
  <action>
Add `getArrayAttributeValue` function to parser.ts for extracting JSX array attributes like `allowedTools={["Read", "Write"]}`.

Implementation:
```typescript
/**
 * Get the value of a JSX array attribute by name
 *
 * Handles JSX expressions containing array literals: attr={["a", "b"]}
 * Returns undefined if attribute is missing or not a string array.
 */
export function getArrayAttributeValue(
  element: JsxOpeningElement | JsxSelfClosingElement,
  name: string
): string[] | undefined {
  const attr = element.getAttribute(name);
  if (!attr || !Node.isJsxAttribute(attr)) {
    return undefined;
  }

  const init = attr.getInitializer();
  if (!init || !Node.isJsxExpression(init)) {
    return undefined;
  }

  const expr = init.getExpression();
  if (!expr || !Node.isArrayLiteralExpression(expr)) {
    return undefined;
  }

  const elements: string[] = [];
  for (const el of expr.getElements()) {
    if (Node.isStringLiteral(el)) {
      elements.push(el.getLiteralValue());
    }
  }
  return elements.length > 0 ? elements : undefined;
}
```

Also add `ArrayLiteralExpression` to the ts-morph import statement.
  </action>
  <verify>`npm test -- --run tests/parser/parser.test.ts` passes (no breaking changes)</verify>
  <done>getArrayAttributeValue function exported from parser.ts, extracts string array literals from JSX attributes</done>
</task>

<task type="auto">
  <name>Task 2: Add Command transformation to transformer</name>
  <files>src/parser/transformer.ts</files>
  <action>
Extend the Transformer class to handle `<Command>` elements:

1. Import `getArrayAttributeValue` from parser.ts
2. Import `FrontmatterNode` type from ir/index.js
3. Modify the `transform` method to detect Command at root level and extract frontmatter
4. Add `transformCommand` private method

Key implementation points:
- Command is a document-level wrapper, not a block element
- Extract props: name (required), description (required), allowedTools (optional array)
- Throw descriptive error if name or description missing
- Children of Command become document body blocks
- Map `allowedTools` to `allowed-tools` (kebab-case for YAML)

Transform method modification:
```typescript
transform(node: JsxElement | JsxSelfClosingElement | JsxFragment): DocumentNode {
  // Check for Command wrapper
  if (Node.isJsxElement(node) || Node.isJsxSelfClosingElement(node)) {
    const name = getElementName(node);
    if (name === 'Command') {
      return this.transformCommand(node);
    }
  }

  // ... existing fragment/element handling
}
```

transformCommand method:
```typescript
private transformCommand(node: JsxElement | JsxSelfClosingElement): DocumentNode {
  const openingElement = Node.isJsxElement(node)
    ? node.getOpeningElement()
    : node;

  // Required props
  const name = getAttributeValue(openingElement, 'name');
  const description = getAttributeValue(openingElement, 'description');

  if (!name) {
    throw new Error('Command requires name prop');
  }
  if (!description) {
    throw new Error('Command requires description prop');
  }

  // Optional array prop
  const allowedTools = getArrayAttributeValue(openingElement, 'allowedTools');

  // Build frontmatter data
  const data: Record<string, unknown> = {
    name,
    description,
  };
  if (allowedTools) {
    data['allowed-tools'] = allowedTools;
  }

  const frontmatter: FrontmatterNode = { kind: 'frontmatter', data };

  // Transform children as body blocks
  const children: BlockNode[] = [];
  if (Node.isJsxElement(node)) {
    for (const child of node.getJsxChildren()) {
      const block = this.transformToBlock(child);
      if (block) children.push(block);
    }
  }

  return { kind: 'document', frontmatter, children };
}
```

Import additions at top:
```typescript
import { getElementName, getAttributeValue, extractText, extractInlineText, getArrayAttributeValue } from './parser.js';
import type { ..., FrontmatterNode } from '../ir/index.js';
```
  </action>
  <verify>TypeScript compiles: `npm run build` or `npx tsc --noEmit`</verify>
  <done>Transformer handles Command elements, extracts props to FrontmatterNode, children to document body</done>
</task>

<task type="auto">
  <name>Task 3: Add Command transformation tests</name>
  <files>tests/parser/transformer.test.ts</files>
  <action>
Add comprehensive tests for Command transformation to transformer.test.ts.

Add new describe block at end of file:
```typescript
describe('Command component', () => {
  it('transforms Command with name and description to frontmatter', () => {
    const source = `
      export default function MyCommand() {
        return (
          <Command name="test" description="A test command">
            <p>Command content</p>
          </Command>
        );
      }
    `;
    const doc = transformSource(source);

    expect(doc.frontmatter).toBeDefined();
    expect(doc.frontmatter?.data).toEqual({
      name: 'test',
      description: 'A test command',
    });
    expect(doc.children).toHaveLength(1);
    expect(doc.children[0].kind).toBe('paragraph');
  });

  it('transforms Command with allowedTools array', () => {
    const source = `
      export default function MyCommand() {
        return (
          <Command
            name="fetch"
            description="Fetch files"
            allowedTools={["Read", "Glob", "Grep"]}
          >
            <p>Fetch content</p>
          </Command>
        );
      }
    `;
    const doc = transformSource(source);

    expect(doc.frontmatter?.data).toEqual({
      name: 'fetch',
      description: 'Fetch files',
      'allowed-tools': ['Read', 'Glob', 'Grep'],
    });
  });

  it('throws error when name prop is missing', () => {
    const source = `
      export default function MyCommand() {
        return (
          <Command description="Missing name">
            <p>Content</p>
          </Command>
        );
      }
    `;
    expect(() => transformSource(source)).toThrow('Command requires name prop');
  });

  it('throws error when description prop is missing', () => {
    const source = `
      export default function MyCommand() {
        return (
          <Command name="test">
            <p>Content</p>
          </Command>
        );
      }
    `;
    expect(() => transformSource(source)).toThrow('Command requires description prop');
  });

  it('transforms Command with multiple children', () => {
    const source = `
      export default function MyCommand() {
        return (
          <Command name="multi" description="Multiple blocks">
            <h1>Title</h1>
            <p>First paragraph</p>
            <p>Second paragraph</p>
          </Command>
        );
      }
    `;
    const doc = transformSource(source);

    expect(doc.children).toHaveLength(3);
    expect(doc.children[0].kind).toBe('heading');
    expect(doc.children[1].kind).toBe('paragraph');
    expect(doc.children[2].kind).toBe('paragraph');
  });

  it('transforms self-closing Command (no body)', () => {
    const source = `
      export default function MyCommand() {
        return (
          <Command name="empty" description="Empty command" />
        );
      }
    `;
    const doc = transformSource(source);

    expect(doc.frontmatter?.data.name).toBe('empty');
    expect(doc.children).toHaveLength(0);
  });
});
```

Also add an E2E test that verifies the full pipeline:
```typescript
describe('Command E2E', () => {
  it('produces valid Claude Code command output', () => {
    const source = `
      export default function MyCommand() {
        return (
          <Command
            name="analyze"
            description="Analyze code patterns"
            allowedTools={["Read", "Grep"]}
          >
            <h1>Analysis Instructions</h1>
            <p>Follow these steps to analyze code.</p>
          </Command>
        );
      }
    `;
    const doc = transformSource(source);
    const output = emit(doc);

    // Should have frontmatter with block-style arrays
    expect(output).toContain('---');
    expect(output).toContain('name: analyze');
    expect(output).toContain('description: Analyze code patterns');
    expect(output).toContain('allowed-tools:');
    expect(output).toContain('  - Read');
    expect(output).toContain('  - Grep');

    // Should have body content
    expect(output).toContain('# Analysis Instructions');
    expect(output).toContain('Follow these steps to analyze code.');
  });
});
```

Import emit at top of test file if not already present:
```typescript
import { emit } from '../../src/emitter/index.js';
```
  </action>
  <verify>`npm test` passes with all new Command tests green</verify>
  <done>All Command transformation tests pass, including E2E verification of full pipeline output</done>
</task>

</tasks>

<verification>
1. `npm test` - All tests pass including new Command tests
2. `npm run build` - TypeScript compiles without errors
3. Manual verification: Create a test command file and run through full pipeline
</verification>

<success_criteria>
- Command component transforms to DocumentNode with FrontmatterNode populated from props
- name and description props map to YAML fields
- allowedTools array maps to `allowed-tools` YAML field with block style (using gray-matter)
- Missing required props throw descriptive errors
- Command children transform correctly as document body
- Full E2E test verifies Claude Code-compatible output format
</success_criteria>

<output>
After completion, create `.planning/phases/03-full-element-coverage/03-01-SUMMARY.md`
</output>
