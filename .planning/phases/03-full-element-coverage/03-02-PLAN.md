---
phase: 03-full-element-coverage
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/ir/nodes.ts
  - src/parser/transformer.ts
  - src/emitter/emitter.ts
  - tests/parser/transformer.test.ts
  - tests/emitter/document.test.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can write <div name='example'>content</div> and get <example>content</example> output"
    - "User can write <div name='x' id='y'> and attributes pass through to <x id='y'>"
    - "User can write <div>content</div> without name and get <div>content</div> unchanged"
    - "User can write <Markdown>{raw}</Markdown> and content passes through unchanged"
    - "Invalid XML tag names (spaces, special chars) throw error with source info"
  artifacts:
    - path: "src/ir/nodes.ts"
      provides: "XmlBlockNode with optional attributes field"
      contains: "attributes?: Record<string, string>"
    - path: "src/parser/transformer.ts"
      provides: "div and Markdown element handlers"
      contains: ["transformDiv", "transformMarkdown"]
    - path: "src/emitter/emitter.ts"
      provides: "XmlBlock emitter with attribute serialization"
      contains: "attributes"
    - path: "tests/parser/transformer.test.ts"
      provides: "Tests for div and Markdown transformation"
      contains: ["Named div blocks", "Markdown passthrough"]
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/ir/nodes.ts"
      via: "XmlBlockNode with attributes"
      pattern: "kind: 'xmlBlock'"
    - from: "src/emitter/emitter.ts"
      to: "XmlBlockNode"
      via: "emitXmlBlock handles attributes"
      pattern: "node.attributes"
---

<objective>
Transform `<div name="x">` to XML blocks and `<Markdown>` to raw passthrough content.

Purpose: Enable users to create Claude Code's XML-style sections using familiar JSX syntax. Named divs become `<name>` tags for structured content sections. The Markdown component allows inserting pre-formatted markdown that should not be processed.

Output: Extended transformer handling div (with name attribute) and Markdown elements. XmlBlockNode IR updated to support attributes for passthrough. Emitter updated to serialize attributes on XML blocks.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-full-element-coverage/03-RESEARCH.md
@.planning/phases/03-full-element-coverage/03-CONTEXT.md
@.planning/phases/03-full-element-coverage/03-01-SUMMARY.md

# Source files to modify
@src/ir/nodes.ts
@src/parser/transformer.ts
@src/emitter/emitter.ts
@tests/parser/transformer.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend XmlBlockNode with attributes and update emitter</name>
  <files>src/ir/nodes.ts, src/emitter/emitter.ts</files>
  <action>
**In src/ir/nodes.ts:**

Add optional `attributes` field to XmlBlockNode interface:
```typescript
/**
 * XML-style block element (e.g., <example>content</example>)
 * Used for Claude Code's special sections
 */
export interface XmlBlockNode {
  kind: 'xmlBlock';
  name: string;
  attributes?: Record<string, string>;  // NEW: additional attributes to pass through
  children: BlockNode[];
}
```

**In src/emitter/emitter.ts:**

Update `emitXmlBlock` method to serialize attributes:
```typescript
/**
 * Emit XML block - <name attrs>content</name>
 */
private emitXmlBlock(node: XmlBlockNode): string {
  // Serialize attributes if present
  const attrs = node.attributes
    ? ' ' + Object.entries(node.attributes)
        .map(([k, v]) => `${k}="${v}"`)
        .join(' ')
    : '';

  const innerContent = node.children.map((child) => this.emitBlock(child)).join('\n\n');

  return `<${node.name}${attrs}>\n${innerContent}\n</${node.name}>`;
}
```

This handles cases like:
- `<example>content</example>` (no attributes)
- `<example id="1" class="foo">content</example>` (with attributes)
  </action>
  <verify>`npm run build` compiles without errors</verify>
  <done>XmlBlockNode interface has attributes field, emitter serializes attributes on XML blocks</done>
</task>

<task type="auto">
  <name>Task 2: Add div and Markdown transformation handlers</name>
  <files>src/parser/transformer.ts</files>
  <action>
Add handlers for `div` and `Markdown` elements in the transformer.

**1. Add XML name validation function (top of file, after imports):**
```typescript
/**
 * Validate that a string is a valid XML tag name
 * Per XML 1.0 spec (simplified): starts with letter or underscore,
 * followed by letters, digits, underscores, hyphens, or periods.
 * Cannot start with 'xml' (case-insensitive).
 */
const XML_NAME_REGEX = /^[a-zA-Z_][a-zA-Z0-9_.\-]*$/;

function isValidXmlName(name: string): boolean {
  if (!name) return false;
  if (!XML_NAME_REGEX.test(name)) return false;
  if (name.toLowerCase().startsWith('xml')) return false;
  return true;
}
```

**2. Add transformDiv method:**
```typescript
private transformDiv(node: JsxElement | JsxSelfClosingElement): BlockNode {
  const openingElement = Node.isJsxElement(node)
    ? node.getOpeningElement()
    : node;

  // Get name attribute (optional - if missing, output as <div>)
  const nameAttr = getAttributeValue(openingElement, 'name');
  const tagName = nameAttr || 'div';

  // Validate XML name if custom name provided
  if (nameAttr && !isValidXmlName(nameAttr)) {
    throw new Error(`Invalid XML tag name '${nameAttr}' - must start with letter/underscore, contain only letters, digits, underscores, hyphens, or periods, and not start with 'xml'`);
  }

  // Extract other attributes (excluding 'name' which becomes the tag)
  const attributes: Record<string, string> = {};
  for (const attr of openingElement.getAttributes()) {
    if (Node.isJsxAttribute(attr)) {
      const attrName = attr.getNameNode().getText();
      if (attrName !== 'name') {
        const value = getAttributeValue(openingElement, attrName);
        if (value !== undefined) {
          attributes[attrName] = value;
        }
      }
    }
  }

  // Transform children as blocks
  const children: BlockNode[] = [];
  if (Node.isJsxElement(node)) {
    for (const child of node.getJsxChildren()) {
      const block = this.transformToBlock(child);
      if (block) children.push(block);
    }
  }

  return {
    kind: 'xmlBlock',
    name: tagName,
    attributes: Object.keys(attributes).length > 0 ? attributes : undefined,
    children,
  };
}
```

**3. Add transformMarkdown method:**
```typescript
private transformMarkdown(node: JsxElement | JsxSelfClosingElement): BlockNode {
  if (Node.isJsxSelfClosingElement(node)) {
    // Self-closing <Markdown /> - empty content
    return { kind: 'raw', content: '' };
  }

  // Extract raw content from children
  const parts: string[] = [];
  for (const child of node.getJsxChildren()) {
    if (Node.isJsxText(child)) {
      // Get raw text preserving whitespace
      parts.push(child.getText());
    } else if (Node.isJsxExpression(child)) {
      // Handle {variable} or {"literal"} expressions
      const expr = child.getExpression();
      if (expr && Node.isStringLiteral(expr)) {
        parts.push(expr.getLiteralValue());
      }
      // Non-string expressions ignored (can't evaluate at transpile time)
    }
  }

  // Trim outer boundaries, preserve internal whitespace
  const content = parts.join('').trim();

  return { kind: 'raw', content };
}
```

**4. Add div and Markdown to transformElement switch (before the final throw):**
```typescript
// XML block via div with name attribute
if (name === 'div') {
  return this.transformDiv(node);
}

// Markdown passthrough
if (name === 'Markdown') {
  return this.transformMarkdown(node);
}
```

**Note:** The import statement already has XmlBlockNode from the ir types. Just ensure `RawMarkdownNode` is not needed as we use `kind: 'raw'` which maps to the existing type.
  </action>
  <verify>`npm run build` compiles without errors</verify>
  <done>Transformer handles div (with/without name) and Markdown elements correctly</done>
</task>

<task type="auto">
  <name>Task 3: Add div and Markdown transformation tests</name>
  <files>tests/parser/transformer.test.ts, tests/emitter/document.test.ts</files>
  <action>
**Add to tests/parser/transformer.test.ts:**

```typescript
describe('Named div blocks', () => {
  it('transforms div with name attribute to XmlBlock', () => {
    const source = `
      export default function Example() {
        return (
          <div name="example">
            <p>Content inside</p>
          </div>
        );
      }
    `;
    const doc = transformSource(source);

    expect(doc.children).toHaveLength(1);
    const block = doc.children[0];
    expect(block.kind).toBe('xmlBlock');
    if (block.kind === 'xmlBlock') {
      expect(block.name).toBe('example');
      expect(block.children).toHaveLength(1);
    }
  });

  it('transforms div without name as <div>', () => {
    const source = `
      export default function Example() {
        return (
          <div>
            <p>Plain div</p>
          </div>
        );
      }
    `;
    const doc = transformSource(source);

    const block = doc.children[0];
    expect(block.kind).toBe('xmlBlock');
    if (block.kind === 'xmlBlock') {
      expect(block.name).toBe('div');
    }
  });

  it('passes through additional attributes', () => {
    const source = `
      export default function Example() {
        return (
          <div name="section" id="intro" class="main">
            <p>Content</p>
          </div>
        );
      }
    `;
    const doc = transformSource(source);

    const block = doc.children[0];
    expect(block.kind).toBe('xmlBlock');
    if (block.kind === 'xmlBlock') {
      expect(block.name).toBe('section');
      expect(block.attributes).toEqual({ id: 'intro', class: 'main' });
    }
  });

  it('handles self-closing div', () => {
    const source = `
      export default function Example() {
        return <div name="break" />;
      }
    `;
    const doc = transformSource(source);

    const block = doc.children[0];
    expect(block.kind).toBe('xmlBlock');
    if (block.kind === 'xmlBlock') {
      expect(block.name).toBe('break');
      expect(block.children).toHaveLength(0);
    }
  });

  it('throws error on invalid XML name with spaces', () => {
    const source = `
      export default function Example() {
        return <div name="has spaces"><p>Bad</p></div>;
      }
    `;
    expect(() => transformSource(source)).toThrow(/Invalid XML tag name/);
  });

  it('throws error on name starting with number', () => {
    const source = `
      export default function Example() {
        return <div name="123start"><p>Bad</p></div>;
      }
    `;
    expect(() => transformSource(source)).toThrow(/Invalid XML tag name/);
  });

  it('throws error on name starting with xml', () => {
    const source = `
      export default function Example() {
        return <div name="xmlData"><p>Bad</p></div>;
      }
    `;
    expect(() => transformSource(source)).toThrow(/Invalid XML tag name/);
  });
});

describe('Markdown passthrough', () => {
  it('passes through raw markdown content', () => {
    const source = `
      export default function Example() {
        return (
          <Markdown>
            # Pre-formatted heading

            Some **bold** already formatted.
          </Markdown>
        );
      }
    `;
    const doc = transformSource(source);

    expect(doc.children).toHaveLength(1);
    const block = doc.children[0];
    expect(block.kind).toBe('raw');
    if (block.kind === 'raw') {
      expect(block.content).toContain('# Pre-formatted heading');
      expect(block.content).toContain('**bold**');
    }
  });

  it('handles JSX expression with string literal', () => {
    const source = `
      export default function Example() {
        return (
          <Markdown>{"# Dynamic heading"}</Markdown>
        );
      }
    `;
    const doc = transformSource(source);

    const block = doc.children[0];
    expect(block.kind).toBe('raw');
    if (block.kind === 'raw') {
      expect(block.content).toBe('# Dynamic heading');
    }
  });

  it('handles self-closing Markdown as empty', () => {
    const source = `
      export default function Example() {
        return <Markdown />;
      }
    `;
    const doc = transformSource(source);

    const block = doc.children[0];
    expect(block.kind).toBe('raw');
    if (block.kind === 'raw') {
      expect(block.content).toBe('');
    }
  });

  it('trims outer whitespace but preserves internal', () => {
    const source = `
      export default function Example() {
        return (
          <Markdown>
            Line one

            Line three
          </Markdown>
        );
      }
    `;
    const doc = transformSource(source);

    const block = doc.children[0];
    if (block.kind === 'raw') {
      // Should not have leading/trailing newlines from JSX formatting
      expect(block.content).not.toMatch(/^\s/);
      expect(block.content).not.toMatch(/\s$/);
      // But should preserve internal blank line
      expect(block.content).toContain('\n\n');
    }
  });
});
```

**Add to tests/emitter/document.test.ts (or create if needed):**

```typescript
describe('XmlBlock with attributes', () => {
  it('emits XML block without attributes', () => {
    const doc: DocumentNode = {
      kind: 'document',
      children: [{
        kind: 'xmlBlock',
        name: 'example',
        children: [{ kind: 'paragraph', children: [{ kind: 'text', value: 'Content' }] }],
      }],
    };
    const output = emit(doc);
    expect(output).toBe('<example>\nContent\n</example>\n');
  });

  it('emits XML block with attributes', () => {
    const doc: DocumentNode = {
      kind: 'document',
      children: [{
        kind: 'xmlBlock',
        name: 'section',
        attributes: { id: 'intro', class: 'main' },
        children: [{ kind: 'paragraph', children: [{ kind: 'text', value: 'Content' }] }],
      }],
    };
    const output = emit(doc);
    expect(output).toContain('<section id="intro" class="main">');
    expect(output).toContain('</section>');
  });
});
```

**E2E test for full pipeline with div and Markdown:**

```typescript
describe('Named div and Markdown E2E', () => {
  it('produces correct XML block output', () => {
    const source = `
      export default function Example() {
        return (
          <>
            <div name="instructions" id="main">
              <p>Follow these steps</p>
            </div>
            <Markdown>
              ## Raw Section

              Already formatted content.
            </Markdown>
          </>
        );
      }
    `;
    const doc = transformSource(source);
    const output = emit(doc);

    expect(output).toContain('<instructions id="main">');
    expect(output).toContain('Follow these steps');
    expect(output).toContain('</instructions>');
    expect(output).toContain('## Raw Section');
    expect(output).toContain('Already formatted content.');
  });
});
```
  </action>
  <verify>`npm test` passes with all new div and Markdown tests green</verify>
  <done>All div and Markdown transformation tests pass, including attribute passthrough and validation</done>
</task>

</tasks>

<verification>
1. `npm test` - All tests pass including new div and Markdown tests
2. `npm run build` - TypeScript compiles without errors
3. Manual verification: Test file with div and Markdown elements through full pipeline
</verification>

<success_criteria>
- div with name attribute transforms to XmlBlockNode with that name
- div without name transforms to XmlBlockNode with name="div"
- Additional div attributes (id, class, etc.) pass through to XmlBlockNode.attributes
- Invalid XML tag names throw descriptive errors
- Markdown children pass through as raw content (RawMarkdownNode)
- Markdown trims outer whitespace, preserves internal structure
- Emitter serializes XmlBlock attributes correctly
- Full E2E tests verify complete pipeline
</success_criteria>

<output>
After completion, create `.planning/phases/03-full-element-coverage/03-02-SUMMARY.md`
</output>
