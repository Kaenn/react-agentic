---
phase: 36-meta-prompting-components
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ir/nodes.ts
  - src/ir/index.ts
  - src/parser/transformers/primitives.ts
  - src/parser/transformers/dispatch.ts
  - src/emitter/emitter.ts
  - src/components/meta-prompting.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "ReadFile component compiles to bash file read instruction"
    - "Required files emit VAR=$(cat path)"
    - "Optional files emit VAR=$(cat path 2>/dev/null)"
  artifacts:
    - path: "src/ir/nodes.ts"
      provides: "ReadFileNode interface"
      contains: "ReadFileNode"
    - path: "src/parser/transformers/primitives.ts"
      provides: "transformReadFile function"
      contains: "transformReadFile"
    - path: "src/emitter/emitter.ts"
      provides: "emitReadFile method"
      contains: "emitReadFile"
  key_links:
    - from: "src/parser/transformers/dispatch.ts"
      to: "transformReadFile"
      via: "ReadFile case"
      pattern: "ReadFile.*transformReadFile"
    - from: "src/emitter/emitter.ts"
      to: "ReadFileNode"
      via: "emitReadFile case"
      pattern: "case 'readFile'"
---

<objective>
Add ReadFile primitive component for single-file bash read instructions.

Purpose: Enable semantic file reading with individual ReadFile components that emit bash cat commands. Unlike the existing batch ReadFiles, this allows granular composition in MetaPrompt/GatherContext patterns.

Output: ReadFile primitive component with IR node, transformer, and emitter.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-meta-prompting-components/36-RESEARCH.md

Source files:
@src/ir/nodes.ts
@src/parser/transformers/primitives.ts
@src/parser/transformers/dispatch.ts
@src/emitter/emitter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ReadFileNode IR and component stub</name>
  <files>
    src/ir/nodes.ts
    src/ir/index.ts
    src/components/meta-prompting.ts
    src/index.ts
  </files>
  <action>
1. Add ReadFileNode interface to src/ir/nodes.ts (after ReadFilesNode):

```typescript
/**
 * Single file read - emits bash cat command
 * Unlike ReadFilesNode which batches, this emits one bash block per file
 */
export interface ReadFileNode {
  kind: 'readFile';
  /** File path (may contain variable refs like ${VAR}) */
  path: string;
  /** Shell variable name from 'as' prop */
  varName: string;
  /** Whether file must exist (affects error suppression) */
  required: boolean;
}
```

2. Add ReadFileNode to BaseBlockNode union in nodes.ts (after ReadFilesNode)

3. Export ReadFileNode from src/ir/index.ts

4. Create src/components/meta-prompting.ts with ReadFile component stub:

```typescript
/**
 * Meta-prompting components for context composition
 */

/**
 * Props for ReadFile component
 */
export interface ReadFileProps {
  /** File path relative to project root */
  path: string;
  /** Shell variable name to store content (required) */
  as: string;
  /** If true, suppress errors for missing files */
  optional?: boolean;
}

/**
 * Read a single file into a shell variable at runtime
 * Emits bash: VAR=$(cat path) or VAR=$(cat path 2>/dev/null) for optional
 *
 * @example Required file
 * ```tsx
 * <ReadFile path=".planning/STATE.md" as="STATE_CONTENT" />
 * // Emits: STATE_CONTENT=$(cat .planning/STATE.md)
 * ```
 *
 * @example Optional file
 * ```tsx
 * <ReadFile path=".planning/CONTEXT.md" as="CONTEXT" optional />
 * // Emits: CONTEXT=$(cat .planning/CONTEXT.md 2>/dev/null)
 * ```
 */
export function ReadFile(_props: ReadFileProps): null {
  return null;
}
```

5. Export ReadFile and ReadFileProps from src/index.ts (add to components section)
  </action>
  <verify>
- npm run typecheck passes
- ReadFileNode appears in nodes.ts with kind: 'readFile'
- src/components/meta-prompting.ts exists with ReadFile function
  </verify>
  <done>ReadFileNode IR defined, ReadFile component stub exported from main package</done>
</task>

<task type="auto">
  <name>Task 2: Add transformer and dispatch</name>
  <files>
    src/parser/transformers/primitives.ts
    src/parser/transformers/dispatch.ts
  </files>
  <action>
1. Add transformReadFile function to src/parser/transformers/primitives.ts (after transformReadFiles):

```typescript
/**
 * Transform <ReadFile> to ReadFileNode
 *
 * <ReadFile path="..." as="..." optional />
 * becomes:
 * { kind: 'readFile', path: '...', varName: '...', required: false }
 */
export function transformReadFile(
  node: JsxElement | JsxSelfClosingElement,
  ctx: TransformContext
): ReadFileNode {
  const opening = Node.isJsxElement(node) ? node.getOpeningElement() : node;

  // Get path prop (required)
  const path = getAttributeValue(opening, 'path');
  if (!path) {
    throw ctx.createError('ReadFile requires path prop', node);
  }

  // Get as prop (required) - variable name
  const varName = getAttributeValue(opening, 'as');
  if (!varName) {
    throw ctx.createError('ReadFile requires as prop', node);
  }

  // Get optional prop (default: false = required)
  const optionalAttr = opening.getAttribute('optional');
  const required = !optionalAttr; // Present optional prop means not required

  return {
    kind: 'readFile',
    path,
    varName,
    required,
  };
}
```

2. Update imports in primitives.ts to include ReadFileNode:
```typescript
import type { StepNode, StepVariant, CodeBlockNode, ReadFilesNode, ReadFileNode, ReadFileEntry, ... } from '../../ir/index.js';
```

3. Export transformReadFile from primitives.ts

4. Add dispatch case in src/parser/transformers/dispatch.ts:
- Import transformReadFile from './primitives.js'
- Add case before ReadFiles case:
```typescript
// ReadFile - single file reading
if (name === 'ReadFile') {
  return transformReadFile(node, ctx);
}
```
  </action>
  <verify>
- npm run typecheck passes
- grep shows transformReadFile in primitives.ts
- grep shows 'ReadFile' case in dispatch.ts
  </verify>
  <done>transformReadFile handles ReadFile component transformation, dispatch routes correctly</done>
</task>

<task type="auto">
  <name>Task 3: Add emitter</name>
  <files>
    src/emitter/emitter.ts
  </files>
  <action>
1. Add import for ReadFileNode in emitter.ts (add to existing imports from ir/index.js)

2. Add case in emitBlock switch (after 'readFiles' case):
```typescript
case 'readFile':
  return this.emitReadFile(node);
```

3. Add emitReadFile private method (after emitReadFiles):
```typescript
/**
 * Emit single file read as bash code block
 * Pattern follows GSD: VAR=$(cat path) or VAR=$(cat path 2>/dev/null)
 */
private emitReadFile(node: ReadFileNode): string {
  // Quote path if it contains variables ($) or spaces
  const quotedPath = /[$\s]/.test(node.path) ? `"${node.path}"` : node.path;

  if (node.required) {
    // Required file - fail loudly if missing
    return `\`\`\`bash\n${node.varName}=$(cat ${quotedPath})\n\`\`\``;
  } else {
    // Optional file - suppress errors with 2>/dev/null
    return `\`\`\`bash\n${node.varName}=$(cat ${quotedPath} 2>/dev/null)\n\`\`\``;
  }
}
```
  </action>
  <verify>
- npm run typecheck passes
- grep shows emitReadFile in emitter.ts
- grep shows "case 'readFile'" in emitter.ts
  </verify>
  <done>ReadFile component emits to bash code blocks with correct required/optional patterns</done>
</task>

</tasks>

<verification>
```bash
# Typecheck entire project
npm run typecheck

# Verify ReadFileNode IR exists
grep -n "ReadFileNode" src/ir/nodes.ts

# Verify transformer exists
grep -n "transformReadFile" src/parser/transformers/primitives.ts

# Verify dispatch routes
grep -n "'ReadFile'" src/parser/transformers/dispatch.ts

# Verify emitter handles readFile
grep -n "emitReadFile" src/emitter/emitter.ts

# Build to verify compilation
npm run build
```
</verification>

<success_criteria>
1. ReadFileNode IR interface defined in nodes.ts with kind: 'readFile'
2. ReadFile component exported from main package
3. transformReadFile parses path, as, and optional props
4. Dispatch routes ReadFile to transformReadFile
5. Emitter produces bash code block with correct cat command pattern
6. Typecheck and build pass
</success_criteria>

<output>
After completion, create `.planning/phases/36-meta-prompting-components/36-01-SUMMARY.md`
</output>
