---
phase: 36-meta-prompting-components
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/composites/meta-prompting/index.ts
  - src/composites/meta-prompting/MetaPrompt.tsx
  - src/composites/meta-prompting/GatherContext.tsx
  - src/composites/meta-prompting/ComposeContext.tsx
  - src/composites/meta-prompting/InlineField.tsx
  - src/composites/meta-prompting/Preamble.tsx
  - src/composites/index.ts
autonomous: true

must_haves:
  truths:
    - "MetaPrompt wraps children for semantic grouping"
    - "GatherContext wraps ReadFile components"
    - "ComposeContext wraps content in XmlBlock"
    - "InlineField emits **Name:** value markdown"
    - "Preamble renders children in blockquote"
  artifacts:
    - path: "src/composites/meta-prompting/index.ts"
      provides: "Meta-prompting composite exports"
      exports: ["MetaPrompt", "GatherContext", "ComposeContext", "InlineField", "Preamble"]
    - path: "src/composites/index.ts"
      provides: "Main composites exports"
      contains: "meta-prompting"
  key_links:
    - from: "src/composites/meta-prompting/ComposeContext.tsx"
      to: "XmlBlock primitive"
      via: "import and use"
      pattern: "import.*XmlBlock"
---

<objective>
Create 5 meta-prompting composite components for semantic context composition.

Purpose: Provide semantic wrappers (MetaPrompt, GatherContext, ComposeContext, InlineField, Preamble) that work with the ReadFile primitive to enable GSD-style context gathering patterns.

Output: New src/composites/meta-prompting/ directory with 5 composites exported from main composites package.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-meta-prompting-components/36-RESEARCH.md

Reference existing composites:
@src/composites/BulletList.tsx
@src/composites/FileContext.tsx
@src/composites/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create meta-prompting composite directory and components</name>
  <files>
    src/composites/meta-prompting/MetaPrompt.tsx
    src/composites/meta-prompting/GatherContext.tsx
    src/composites/meta-prompting/ComposeContext.tsx
    src/composites/meta-prompting/InlineField.tsx
    src/composites/meta-prompting/Preamble.tsx
  </files>
  <action>
Create src/composites/meta-prompting/ directory with 5 composite components:

1. **MetaPrompt.tsx** - Top-level semantic wrapper:
```tsx
import type { ReactNode } from 'react';

/**
 * Semantic wrapper for meta-prompting context composition
 *
 * Groups GatherContext and ComposeContext for structured context assembly.
 * Pass-through container for organizational clarity.
 *
 * @example
 * ```tsx
 * <MetaPrompt>
 *   <GatherContext>
 *     <ReadFile path=".planning/STATE.md" as="STATE" />
 *   </GatherContext>
 *   <ComposeContext name="planning">
 *     <InlineField name="Phase" value={8} />
 *   </ComposeContext>
 * </MetaPrompt>
 * ```
 */
export interface MetaPromptProps {
  /** Context composition content */
  children: ReactNode;
}

export const MetaPrompt = ({ children }: MetaPromptProps): ReactNode => {
  return <>{children}</>;
};
```

2. **GatherContext.tsx** - Groups file reads:
```tsx
import type { ReactNode } from 'react';

/**
 * Groups file read operations for context gathering
 *
 * Semantic wrapper around ReadFile components. Pure organizational
 * container - renders children directly.
 *
 * @example
 * ```tsx
 * <GatherContext>
 *   <ReadFile path=".planning/STATE.md" as="STATE_CONTENT" />
 *   <ReadFile path=".planning/ROADMAP.md" as="ROADMAP_CONTENT" />
 *   <ReadFile path=".planning/CONTEXT.md" as="CONTEXT" optional />
 * </GatherContext>
 * ```
 */
export interface GatherContextProps {
  /** ReadFile components */
  children: ReactNode;
}

export const GatherContext = ({ children }: GatherContextProps): ReactNode => {
  return <>{children}</>;
};
```

3. **ComposeContext.tsx** - Structures gathered content into XML:
```tsx
import type { ReactNode } from 'react';
import { XmlBlock } from '../../primitives/markdown.js';

/**
 * Structure gathered content into named XML block
 *
 * Wraps children in XmlBlock primitive. Use with InlineField
 * and Preamble for structured context composition.
 *
 * @example
 * ```tsx
 * <ComposeContext name="planning_context">
 *   <Preamble>You will use this context to create plans.</Preamble>
 *   <InlineField name="Phase" value={8} />
 *   <InlineField name="Mode" value="standard" />
 * </ComposeContext>
 * ```
 *
 * Emits:
 * ```markdown
 * <planning_context>
 *
 * > You will use this context to create plans.
 *
 * **Phase:** 8
 * **Mode:** standard
 *
 * </planning_context>
 * ```
 */
export interface ComposeContextProps {
  /** XML block name (e.g., "planning_context") */
  name: string;
  /** Structured content (InlineFields, Preambles, markdown, etc.) */
  children: ReactNode;
}

export const ComposeContext = ({ name, children }: ComposeContextProps): ReactNode => {
  return (
    <XmlBlock name={name}>
      {children}
    </XmlBlock>
  );
};
```

4. **InlineField.tsx** - Renders key-value markdown:
```tsx
import type { ReactNode } from 'react';
import { Markdown } from '../../primitives/markdown.js';

/**
 * Render inline key-value field in bold format
 *
 * Produces **Name:** value markdown pattern. For dynamic
 * runtime values, compose with <Ref> component manually.
 *
 * @example Static value
 * ```tsx
 * <InlineField name="Phase" value={8} />
 * // Emits: **Phase:** 8
 * ```
 *
 * @example String value
 * ```tsx
 * <InlineField name="Mode" value="standard" />
 * // Emits: **Mode:** standard
 * ```
 *
 * @example Dynamic value (use Ref)
 * ```tsx
 * // For runtime variables, compose manually:
 * <Markdown>**Phase:** <Ref value={ctx.phase} /></Markdown>
 * ```
 */
export interface InlineFieldProps {
  /** Field name/label */
  name: string;
  /** Static value (string or number) */
  value: string | number;
}

export const InlineField = ({ name, value }: InlineFieldProps): ReactNode => {
  return <Markdown>{`**${name}:** ${value}`}</Markdown>;
};
```

5. **Preamble.tsx** - Renders intro text in blockquote:
```tsx
import type { ReactNode } from 'react';

/**
 * Render preamble text in blockquote for visual distinction
 *
 * Wraps children in blockquote for introductory context.
 * Use at the start of ComposeContext blocks.
 *
 * @example
 * ```tsx
 * <Preamble>
 *   You will use this context to create executable phase plans.
 *   Output consumed by /gsd:execute-phase.
 * </Preamble>
 * ```
 *
 * Emits:
 * ```markdown
 * > You will use this context to create executable phase plans.
 * > Output consumed by /gsd:execute-phase.
 * ```
 */
export interface PreambleProps {
  /** Introductory text content */
  children: ReactNode;
}

export const Preamble = ({ children }: PreambleProps): ReactNode => {
  return <blockquote>{children}</blockquote>;
};
```
  </action>
  <verify>
- All 5 .tsx files exist in src/composites/meta-prompting/
- npm run typecheck passes
  </verify>
  <done>5 meta-prompting composites created with full JSDoc documentation</done>
</task>

<task type="auto">
  <name>Task 2: Create index and wire exports</name>
  <files>
    src/composites/meta-prompting/index.ts
    src/composites/index.ts
  </files>
  <action>
1. Create src/composites/meta-prompting/index.ts:
```typescript
/**
 * Meta-prompting composites for context composition
 *
 * Components for structured context gathering and composition,
 * following GSD patterns for file reading and XML block assembly.
 *
 * Import: import { MetaPrompt, GatherContext, ... } from 'react-agentic/composites'
 *
 * @example Full pattern
 * ```tsx
 * import { ReadFile } from 'react-agentic';
 * import { MetaPrompt, GatherContext, ComposeContext, InlineField, Preamble } from 'react-agentic/composites';
 *
 * <MetaPrompt>
 *   <GatherContext>
 *     <ReadFile path=".planning/STATE.md" as="STATE" />
 *   </GatherContext>
 *   <ComposeContext name="planning_context">
 *     <Preamble>Use this context to plan.</Preamble>
 *     <InlineField name="Phase" value={8} />
 *   </ComposeContext>
 * </MetaPrompt>
 * ```
 */

export { MetaPrompt, type MetaPromptProps } from './MetaPrompt.js';
export { GatherContext, type GatherContextProps } from './GatherContext.js';
export { ComposeContext, type ComposeContextProps } from './ComposeContext.js';
export { InlineField, type InlineFieldProps } from './InlineField.js';
export { Preamble, type PreambleProps } from './Preamble.js';
```

2. Update src/composites/index.ts to include meta-prompting exports.

Add new section after existing exports:
```typescript
// Meta-prompting composites
export {
  MetaPrompt,
  type MetaPromptProps,
  GatherContext,
  type GatherContextProps,
  ComposeContext,
  type ComposeContextProps,
  InlineField,
  type InlineFieldProps,
  Preamble,
  type PreambleProps,
} from './meta-prompting/index.js';
```
  </action>
  <verify>
- npm run typecheck passes
- grep shows all 5 components exported from src/composites/index.ts
  </verify>
  <done>Meta-prompting composites exported from react-agentic/composites</done>
</task>

</tasks>

<verification>
```bash
# Typecheck entire project
npm run typecheck

# Verify all composite files exist
ls -la src/composites/meta-prompting/

# Verify exports from index
grep -n "MetaPrompt\|GatherContext\|ComposeContext\|InlineField\|Preamble" src/composites/index.ts

# Build to verify compilation
npm run build
```
</verification>

<success_criteria>
1. 5 composites exist in src/composites/meta-prompting/
2. All composites have JSDoc documentation with examples
3. ComposeContext wraps XmlBlock primitive
4. InlineField uses Markdown primitive for **Name:** value pattern
5. Preamble uses blockquote for visual distinction
6. All composites exported from react-agentic/composites
7. Typecheck and build pass
</success_criteria>

<output>
After completion, create `.planning/phases/36-meta-prompting-components/36-02-SUMMARY.md`
</output>
