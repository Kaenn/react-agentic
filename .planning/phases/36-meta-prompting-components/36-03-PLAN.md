---
phase: 36-meta-prompting-components
plan: 03
type: execute
wave: 2
depends_on: ["36-01", "36-02"]
files_modified:
  - tests/parser/meta-prompting.test.ts
  - tests/emitter/meta-prompting.test.ts
  - tests/snapshots/meta-prompting.test.ts
  - docs/meta-prompting.md
  - docs/grammar.md
  - docs/README.md
autonomous: true

must_haves:
  truths:
    - "ReadFile transformer handles required/optional correctly"
    - "ReadFile emitter produces correct bash patterns"
    - "Snapshot tests validate full meta-prompting pattern"
    - "Documentation explains GSD-style context composition"
  artifacts:
    - path: "tests/parser/meta-prompting.test.ts"
      provides: "Transformer unit tests"
      contains: "transformReadFile"
    - path: "tests/emitter/meta-prompting.test.ts"
      provides: "Emitter unit tests"
      contains: "emitReadFile"
    - path: "docs/meta-prompting.md"
      provides: "User guide for meta-prompting"
      contains: "ReadFile"
  key_links:
    - from: "docs/README.md"
      to: "docs/meta-prompting.md"
      via: "navigation link"
      pattern: "meta-prompting"
---

<objective>
Add tests and documentation for meta-prompting components.

Purpose: Validate ReadFile transformer/emitter behavior and provide user documentation for the full meta-prompting pattern.

Output: Unit tests for ReadFile primitive, snapshot tests for integration, and docs/meta-prompting.md guide.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-meta-prompting-components/36-RESEARCH.md

Reference existing tests:
@tests/parser/control.test.ts
@tests/emitter/control.test.ts
@tests/snapshots/

Reference existing docs:
@docs/grammar.md
@docs/README.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ReadFile transformer tests</name>
  <files>
    tests/parser/meta-prompting.test.ts
  </files>
  <action>
Create tests/parser/meta-prompting.test.ts:

```typescript
/**
 * Meta-prompting transformer tests
 *
 * Tests for ReadFile component transformation.
 */

import { describe, it, expect } from 'vitest';
import { parseCommand } from '../../src/parser/index.js';

describe('transformReadFile', () => {
  describe('required files', () => {
    it('transforms basic ReadFile to IR', () => {
      const tsx = `
        import { Command, ReadFile } from 'react-agentic';
        export default (
          <Command name="test" description="test">
            <ReadFile path=".planning/STATE.md" as="STATE_CONTENT" />
          </Command>
        );
      `;
      const result = parseCommand(tsx, 'test.tsx');

      // Find readFile node in children
      const readFileNode = result.children.find((c: any) => c.kind === 'readFile');
      expect(readFileNode).toBeDefined();
      expect(readFileNode).toMatchObject({
        kind: 'readFile',
        path: '.planning/STATE.md',
        varName: 'STATE_CONTENT',
        required: true,
      });
    });

    it('handles path with variable reference', () => {
      const tsx = `
        import { Command, ReadFile } from 'react-agentic';
        export default (
          <Command name="test" description="test">
            <ReadFile path="\${PHASE_DIR}/*-CONTEXT.md" as="CONTEXT" />
          </Command>
        );
      `;
      const result = parseCommand(tsx, 'test.tsx');

      const readFileNode = result.children.find((c: any) => c.kind === 'readFile');
      expect(readFileNode).toMatchObject({
        kind: 'readFile',
        path: '${PHASE_DIR}/*-CONTEXT.md',
        varName: 'CONTEXT',
        required: true,
      });
    });
  });

  describe('optional files', () => {
    it('transforms optional ReadFile', () => {
      const tsx = `
        import { Command, ReadFile } from 'react-agentic';
        export default (
          <Command name="test" description="test">
            <ReadFile path=".planning/REQUIREMENTS.md" as="REQS" optional />
          </Command>
        );
      `;
      const result = parseCommand(tsx, 'test.tsx');

      const readFileNode = result.children.find((c: any) => c.kind === 'readFile');
      expect(readFileNode).toMatchObject({
        kind: 'readFile',
        path: '.planning/REQUIREMENTS.md',
        varName: 'REQS',
        required: false,
      });
    });

    it('handles optional={true} syntax', () => {
      const tsx = `
        import { Command, ReadFile } from 'react-agentic';
        export default (
          <Command name="test" description="test">
            <ReadFile path="file.md" as="FILE" optional={true} />
          </Command>
        );
      `;
      const result = parseCommand(tsx, 'test.tsx');

      const readFileNode = result.children.find((c: any) => c.kind === 'readFile');
      expect(readFileNode?.required).toBe(false);
    });
  });

  describe('error cases', () => {
    it('throws when path prop missing', () => {
      const tsx = `
        import { Command, ReadFile } from 'react-agentic';
        export default (
          <Command name="test" description="test">
            <ReadFile as="STATE" />
          </Command>
        );
      `;
      expect(() => parseCommand(tsx, 'test.tsx')).toThrow(/path/i);
    });

    it('throws when as prop missing', () => {
      const tsx = `
        import { Command, ReadFile } from 'react-agentic';
        export default (
          <Command name="test" description="test">
            <ReadFile path=".planning/STATE.md" />
          </Command>
        );
      `;
      expect(() => parseCommand(tsx, 'test.tsx')).toThrow(/as/i);
    });
  });
});
```
  </action>
  <verify>
- tests/parser/meta-prompting.test.ts exists
- npm run test:run -- tests/parser/meta-prompting.test.ts passes
  </verify>
  <done>ReadFile transformer tests validate required/optional behavior and error handling</done>
</task>

<task type="auto">
  <name>Task 2: Add ReadFile emitter tests</name>
  <files>
    tests/emitter/meta-prompting.test.ts
  </files>
  <action>
Create tests/emitter/meta-prompting.test.ts:

```typescript
/**
 * Meta-prompting emitter tests
 *
 * Tests for ReadFile emission patterns.
 */

import { describe, it, expect } from 'vitest';
import { MarkdownEmitter } from '../../src/emitter/emitter.js';
import type { ReadFileNode } from '../../src/ir/nodes.js';

describe('emitReadFile', () => {
  const emitter = new MarkdownEmitter({ minify: false });

  describe('required files', () => {
    it('emits VAR=$(cat path) for required file', () => {
      const node: ReadFileNode = {
        kind: 'readFile',
        path: '.planning/STATE.md',
        varName: 'STATE_CONTENT',
        required: true,
      };

      const result = emitter.emitBlock(node);
      expect(result).toBe('```bash\nSTATE_CONTENT=$(cat .planning/STATE.md)\n```');
    });

    it('quotes path with variable reference', () => {
      const node: ReadFileNode = {
        kind: 'readFile',
        path: '${PHASE_DIR}/*-CONTEXT.md',
        varName: 'CONTEXT',
        required: true,
      };

      const result = emitter.emitBlock(node);
      expect(result).toBe('```bash\nCONTEXT=$(cat "${PHASE_DIR}/*-CONTEXT.md")\n```');
    });

    it('quotes path with spaces', () => {
      const node: ReadFileNode = {
        kind: 'readFile',
        path: 'my file.md',
        varName: 'CONTENT',
        required: true,
      };

      const result = emitter.emitBlock(node);
      expect(result).toBe('```bash\nCONTENT=$(cat "my file.md")\n```');
    });
  });

  describe('optional files', () => {
    it('emits VAR=$(cat path 2>/dev/null) for optional file', () => {
      const node: ReadFileNode = {
        kind: 'readFile',
        path: '.planning/REQUIREMENTS.md',
        varName: 'REQS',
        required: false,
      };

      const result = emitter.emitBlock(node);
      expect(result).toBe('```bash\nREQS=$(cat .planning/REQUIREMENTS.md 2>/dev/null)\n```');
    });

    it('quotes and suppresses errors for optional file with variable', () => {
      const node: ReadFileNode = {
        kind: 'readFile',
        path: '${PHASE_DIR}/*-RESEARCH.md',
        varName: 'RESEARCH',
        required: false,
      };

      const result = emitter.emitBlock(node);
      expect(result).toBe('```bash\nRESEARCH=$(cat "${PHASE_DIR}/*-RESEARCH.md" 2>/dev/null)\n```');
    });
  });
});
```
  </action>
  <verify>
- tests/emitter/meta-prompting.test.ts exists
- npm run test:run -- tests/emitter/meta-prompting.test.ts passes
  </verify>
  <done>ReadFile emitter tests validate bash output patterns</done>
</task>

<task type="auto">
  <name>Task 3: Add documentation</name>
  <files>
    docs/meta-prompting.md
    docs/grammar.md
    docs/README.md
  </files>
  <action>
1. Create docs/meta-prompting.md:

```markdown
# Meta-Prompting Components

Components for composing structured context from file reads into typed XML blocks for agent consumption.

## Concept

Meta-prompting enables **runtime file reading** with bash instructions (like GSD's `VAR=$(cat path)` pattern), not compile-time file embedding. The gathered context is then structured into XML blocks that Claude parses and uses.

## Components

### ReadFile (Primitive)

Read a single file into a shell variable at runtime.

```tsx
import { ReadFile } from 'react-agentic';

// Required file - fails if missing
<ReadFile path=".planning/STATE.md" as="STATE_CONTENT" />

// Optional file - empty string if missing
<ReadFile path=".planning/CONTEXT.md" as="CONTEXT" optional />

// Path with variable reference
<ReadFile path="${PHASE_DIR}/*-RESEARCH.md" as="RESEARCH" optional />
```

**Emits:**
```bash
STATE_CONTENT=$(cat .planning/STATE.md)
CONTEXT=$(cat .planning/CONTEXT.md 2>/dev/null)
RESEARCH=$(cat "${PHASE_DIR}/*-RESEARCH.md" 2>/dev/null)
```

### Composites

Semantic wrappers for organizing context composition:

```tsx
import { ReadFile } from 'react-agentic';
import {
  MetaPrompt,
  GatherContext,
  ComposeContext,
  InlineField,
  Preamble
} from 'react-agentic/composites';
```

| Component | Purpose |
|-----------|---------|
| `MetaPrompt` | Top-level wrapper for context composition |
| `GatherContext` | Groups `ReadFile` components |
| `ComposeContext` | Wraps content in named XML block |
| `InlineField` | Renders `**Key:** value` markdown |
| `Preamble` | Renders intro text in blockquote |

## Pattern: GSD-Style Context Gathering

The meta-prompting pattern follows GSD's approach: gather files, then compose into structured context.

```tsx
import { Command, ReadFile, SpawnAgent } from 'react-agentic';
import {
  MetaPrompt,
  GatherContext,
  ComposeContext,
  InlineField,
  Preamble
} from 'react-agentic/composites';

export default (
  <Command name="plan" description="Create phase plans">
    <MetaPrompt>
      {/* Step 1: Gather context files */}
      <GatherContext>
        <ReadFile path=".planning/STATE.md" as="STATE" />
        <ReadFile path=".planning/ROADMAP.md" as="ROADMAP" />
        <ReadFile path=".planning/REQUIREMENTS.md" as="REQS" optional />
      </GatherContext>

      {/* Step 2: Compose into structured XML */}
      <ComposeContext name="planning_context">
        <Preamble>
          You will use this context to create executable phase plans.
          Output consumed by /execute-phase.
        </Preamble>

        <InlineField name="Phase" value={8} />
        <InlineField name="Mode" value="standard" />

        {/* Reference gathered variables in markdown */}
        **Project State:**
        $STATE

        **Roadmap:**
        $ROADMAP
      </ComposeContext>
    </MetaPrompt>

    <SpawnAgent agent="planner" />
  </Command>
);
```

**Emits:**
```markdown
\`\`\`bash
STATE=$(cat .planning/STATE.md)
ROADMAP=$(cat .planning/ROADMAP.md)
REQS=$(cat .planning/REQUIREMENTS.md 2>/dev/null)
\`\`\`

<planning_context>

> You will use this context to create executable phase plans.
> Output consumed by /execute-phase.

**Phase:** 8
**Mode:** standard

**Project State:**
$STATE

**Roadmap:**
$ROADMAP

</planning_context>

Task(planner, {...})
```

## ReadFile vs ReadFiles

Both components serve file reading but with different use cases:

| Aspect | `ReadFiles` | `ReadFile` |
|--------|------------|------------|
| **Syntax** | `files={defineFiles({...})}` | `path="..." as="..."` |
| **Output** | Single bash block for all files | One bash block per file |
| **Best for** | Batch reads, all files known upfront | Semantic grouping, composition |
| **Example** | GSD Step 7 pattern | MetaPrompt/GatherContext pattern |

Use `ReadFiles` when you have a fixed set of files. Use `ReadFile` when building compositional patterns with semantic structure.

## Variable References

For dynamic values from runtime variables, use the `<Ref>` component manually:

```tsx
import { Ref, useRuntimeVar } from 'react-agentic';

const ctx = useRuntimeVar<{ phase: number }>('CTX');

// Static value - use InlineField
<InlineField name="Mode" value="standard" />

// Dynamic value - use Ref directly
**Phase:** <Ref value={ctx.phase} />
```

## Best Practices

1. **Group related reads** - Use `GatherContext` to visually group file reads
2. **Use meaningful variable names** - `STATE_CONTENT` is clearer than `S`
3. **Mark optional files** - Use `optional` prop to avoid errors on missing files
4. **Quote paths with variables** - Emitter handles this automatically
5. **Structure with ComposeContext** - Name your XML blocks semantically

## See Also

- [Runtime System](runtime.md) - `useRuntimeVar`, `Ref`, `runtimeFn`
- [Structured Components](structured-components.md) - `Table`, `List`
- [Grammar Specification](grammar.md) - Full element reference
```

2. Update docs/grammar.md - Add ReadFile entry in the Elements section:

Add after ReadFiles entry:
```markdown
### ReadFile

Single file read to shell variable.

**Props:**
| Prop | Type | Required | Description |
|------|------|----------|-------------|
| `path` | `string` | Yes | File path (may include shell variables) |
| `as` | `string` | Yes | Shell variable name for content |
| `optional` | `boolean` | No | Suppress error if file missing |

**Example:**
```tsx
<ReadFile path=".planning/STATE.md" as="STATE_CONTENT" />
<ReadFile path="${PHASE_DIR}/*-CONTEXT.md" as="CONTEXT" optional />
```

**Output:**
```markdown
\`\`\`bash
STATE_CONTENT=$(cat .planning/STATE.md)
CONTEXT=$(cat "${PHASE_DIR}/*-CONTEXT.md" 2>/dev/null)
\`\`\`
```
```

3. Update docs/README.md - Add link to meta-prompting.md in the documentation index table.

Add row:
```markdown
| [Meta-Prompting](meta-prompting.md) | Context composition | ReadFile, GatherContext, ComposeContext |
```
  </action>
  <verify>
- docs/meta-prompting.md exists with full content
- docs/grammar.md includes ReadFile entry
- docs/README.md links to meta-prompting.md
  </verify>
  <done>Documentation complete with user guide, grammar entry, and index link</done>
</task>

</tasks>

<verification>
```bash
# Run all tests
npm run test:run

# Specifically run meta-prompting tests
npm run test:run -- tests/parser/meta-prompting.test.ts tests/emitter/meta-prompting.test.ts

# Verify docs exist
ls -la docs/meta-prompting.md

# Verify grammar updated
grep -n "ReadFile" docs/grammar.md

# Verify README updated
grep -n "meta-prompting" docs/README.md
```
</verification>

<success_criteria>
1. Transformer tests pass for required/optional ReadFile
2. Emitter tests pass for bash output patterns
3. Error case tests validate prop requirements
4. docs/meta-prompting.md explains full pattern with examples
5. docs/grammar.md includes ReadFile specification
6. docs/README.md links to meta-prompting guide
7. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/36-meta-prompting-components/36-03-SUMMARY.md`
</output>
