---
phase: 26-parser-refactoring
plan: 05
type: gap-closure
wave: 4
depends_on: ["26-04"]
files_modified:
  - src/parser/parser.ts
  - src/parser/transformer.ts
autonomous: true

must_haves:
  truths:
    - "parser.ts is a slim coordinator that re-exports from utils/ modules"
    - "transformer.ts is a slim coordinator that delegates to transformers/ modules"
    - "All existing tests pass after refactoring"
    - "Build passes with no TypeScript errors"
    - "Public API unchanged (no breaking changes to imports)"
  artifacts:
    - path: "src/parser/parser.ts"
      provides: "Re-exports from utils/index.ts"
      max_lines: 60
    - path: "src/parser/transformer.ts"
      provides: "Slim Transformer class delegating to transformers/"
      max_lines: 250
  key_links:
    - from: "src/parser/parser.ts"
      to: "src/parser/utils/index.ts"
      via: "export * from './utils/index.js'"
      pattern: "export.*from.*utils"
    - from: "src/parser/transformer.ts"
      to: "src/parser/transformers/index.ts"
      via: "imports transform functions"
      pattern: "import.*from.*transformers"
---

<objective>
Create slim coordinators for parser.ts and transformer.ts

Purpose: Complete Phase 26 by making original files delegate to extracted modules
Output: parser.ts (~50 lines) re-exports, transformer.ts (~200 lines) coordinator
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/26-parser-refactoring/26-VERIFICATION.md
@.planning/phases/26-parser-refactoring/26-04-SUMMARY.md
@src/parser/parser.ts
@src/parser/transformer.ts
@src/parser/utils/index.ts
@src/parser/transformers/index.ts
@src/parser/transformers/types.ts
@src/parser/transformers/dispatch.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert parser.ts to slim re-export coordinator</name>
  <files>
    src/parser/parser.ts
  </files>
  <action>
Replace parser.ts (1255 lines) with re-exports from utils/ (~50 lines):

```typescript
/**
 * ts-morph Parser - TSX file parsing and JSX AST extraction
 *
 * This module re-exports all parser utilities from the utils/ directory.
 * The actual implementations live in focused submodules for maintainability.
 *
 * @see ./utils/index.ts for the complete API
 */

// Re-export all parser utilities
export * from './utils/index.js';

// For backward compatibility, also re-export InputProperty types from IR
// (some external code may import these from parser.ts)
export type { InputProperty, InputPropertyValue, StateSchema, StateSchemaField } from '../ir/nodes.js';
```

This replaces all 1255 lines of implementation with simple re-exports.

The utils/index.ts already exports all the public APIs:
- createProject, parseFile, parseSource (from ./project.js)
- getElementName, getJsxChildren, getAttributeValue, etc. (from ./jsx-traversal.js)
- extractText, extractInlineText, normalizeWhitespace (from ./text-extraction.js)
- resolveSpreadAttribute, extractObjectLiteralProps (from ./spread-resolution.js)
- resolveComponentImport, extractJsxFromComponent (from ./component-resolution.js)
- resolveTypeImport, extractInterfaceProperties (from ./type-resolution.js)
- extractVariableDeclarations, extractTypeArguments, etc. (from ./variable-extraction.js)

Note: Verify that all symbols currently exported from parser.ts are available via utils/index.ts before replacing.
  </action>
  <verify>
    `npx tsc --noEmit src/parser/parser.ts && wc -l src/parser/parser.ts` shows <60 lines and no errors
  </verify>
  <done>
    parser.ts is slim re-export coordinator (<60 lines)
  </done>
</task>

<task type="auto">
  <name>Task 2: Convert transformer.ts to slim delegation coordinator</name>
  <files>
    src/parser/transformer.ts
  </files>
  <action>
Replace transformer.ts (3956 lines) with slim coordinator (~200 lines):

```typescript
/**
 * Transformer - JSX AST to IR Node transformation
 *
 * Converts parsed JSX elements from ts-morph into IR nodes for emission to Markdown.
 *
 * This module provides the Transformer class which coordinates transformation
 * by delegating to focused transformer modules in the transformers/ directory.
 *
 * @see ./transformers/index.ts for the complete list of transformer functions
 */

import {
  Node,
  JsxElement,
  JsxSelfClosingElement,
  JsxFragment,
  SourceFile,
} from 'ts-morph';
import { TranspileError, getNodeLocation, getSourceCode } from '../cli/errors.js';
import type {
  DocumentNode,
  AgentDocumentNode,
  SkillDocumentNode,
  MCPConfigDocumentNode,
  StateDocumentNode,
} from '../ir/index.js';
import type { TransformContext } from './transformers/types.js';
import type { ExtractedVariable } from './utils/index.js';
import { getElementName, extractVariableDeclarations } from './utils/index.js';
import {
  transformCommand,
  transformAgent,
  transformSkill,
  transformMCPConfig,
  transformState,
  extractOutputDeclarations,
  extractStateRefDeclarations,
} from './transformers/index.js';

// Re-export isCustomComponent for external use
export { isCustomComponent } from './transformers/shared.js';

export class Transformer {
  /** Source file for component resolution (optional) */
  private sourceFile: SourceFile | undefined;
  /** Visited paths for circular import detection */
  private visitedPaths: Set<string> = new Set();
  /** Extracted useVariable declarations */
  private variables: Map<string, ExtractedVariable> = new Map();
  /** Extracted useOutput declarations: identifier name -> agent name */
  private outputs: Map<string, string> = new Map();
  /** Extracted useStateRef declarations: identifier name -> state key */
  private stateRefs: Map<string, string> = new Map();

  /**
   * Create a TranspileError with source location context
   */
  private createError(message: string, node: Node): TranspileError {
    const location = getNodeLocation(node);
    const sourceCode = getSourceCode(node.getSourceFile());
    return new TranspileError(message, location, sourceCode);
  }

  /**
   * Create the transformation context for passing to transformer functions
   */
  private createContext(): TransformContext {
    return {
      sourceFile: this.sourceFile,
      visitedPaths: this.visitedPaths,
      variables: this.variables,
      outputs: this.outputs,
      stateRefs: this.stateRefs,
      renderPropsContext: undefined,
      createError: (message, node) => this.createError(message, node),
    };
  }

  /**
   * Transform a root JSX element/fragment into a DocumentNode
   *
   * @param node - The root JSX element/fragment to transform
   * @param sourceFile - Optional source file for component composition resolution
   */
  transform(
    node: JsxElement | JsxSelfClosingElement | JsxFragment,
    sourceFile?: SourceFile
  ): DocumentNode | AgentDocumentNode | SkillDocumentNode | MCPConfigDocumentNode | StateDocumentNode {
    // Initialize state
    this.sourceFile = sourceFile;
    this.visitedPaths = new Set();
    this.variables = new Map();
    this.outputs = new Map();
    this.stateRefs = new Map();

    // Extract declarations from source file
    if (sourceFile) {
      this.visitedPaths.add(sourceFile.getFilePath());
      this.variables = extractVariableDeclarations(sourceFile);
      this.outputs = extractOutputDeclarations(sourceFile);
      this.stateRefs = extractStateRefDeclarations(sourceFile);
    }

    // Create context for transformer functions
    const ctx = this.createContext();

    // Handle fragments (should contain single document element)
    if (Node.isJsxFragment(node)) {
      const children = node.getJsxChildren().filter(
        (child) => Node.isJsxElement(child) || Node.isJsxSelfClosingElement(child)
      );
      if (children.length !== 1) {
        throw new TranspileError('Fragment must contain exactly one document element');
      }
      node = children[0] as JsxElement | JsxSelfClosingElement;
    }

    // Route to appropriate document transformer
    const name = getElementName(node);

    switch (name) {
      case 'Command':
        return transformCommand(node, ctx);
      case 'Agent':
        return transformAgent(node, ctx);
      case 'Skill':
        return transformSkill(node, ctx);
      case 'MCPConfig':
        return transformMCPConfig(node, ctx);
      case 'State':
        return transformState(node, ctx);
      default:
        throw this.createError(
          `Root element must be <Command>, <Agent>, <Skill>, <MCPConfig>, or <State>, got <${name}>`,
          node
        );
    }
  }
}

/**
 * Convenience function to create a transformer and transform a node
 */
export function transform(
  node: JsxElement | JsxSelfClosingElement | JsxFragment,
  sourceFile?: SourceFile
): DocumentNode | AgentDocumentNode | SkillDocumentNode | MCPConfigDocumentNode | StateDocumentNode {
  const transformer = new Transformer();
  return transformer.transform(node, sourceFile);
}
```

This replaces 3956 lines with ~150 lines of coordinator code.

Key changes:
1. All transform methods removed - they now live in transformers/ modules
2. Transformer class only coordinates: initializes context, routes to appropriate document transformer
3. createContext() builds TransformContext for passing to transformer functions
4. transform() method routes based on element name to document transformers
5. All actual transformation logic delegated to transformers/index.ts exports
  </action>
  <verify>
    `npx tsc --noEmit src/parser/transformer.ts && wc -l src/parser/transformer.ts` shows <250 lines and no errors
  </verify>
  <done>
    transformer.ts is slim coordinator (<250 lines) delegating to transformers/
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify build and run test suite</name>
  <files>
    src/parser/index.ts
  </files>
  <action>
Verify the refactoring maintains public API compatibility:

1. Verify src/parser/index.ts exports (should be unchanged):
```typescript
export * from './parser.js';
export * from './transformer.js';
```

2. Run full build:
```bash
npm run build
```

3. Run parser tests:
```bash
npm test -- tests/parser/
```

Expected: Some tests may fail due to error message changes (see 26-06 plan).
The coordinator changes should not introduce new failures.

4. Verify public API by checking imports in other files:
```bash
grep -r "from '../parser" src/ --include="*.ts" | head -20
grep -r "from './parser" src/ --include="*.ts" | head -20
```

All imports should continue to work with the re-export coordinator.
  </action>
  <verify>
    `npm run build` passes with no TypeScript errors
  </verify>
  <done>
    Build passes, public API unchanged
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. parser.ts is <60 lines (re-exports from utils/)
2. transformer.ts is <250 lines (coordinator delegating to transformers/)
3. `npm run build` passes
4. Public API unchanged (imports still work)
</verification>

<success_criteria>
- [ ] parser.ts replaced with re-exports (<60 lines)
- [ ] transformer.ts replaced with coordinator (<250 lines)
- [ ] `npm run build` passes with no TypeScript errors
- [ ] Public API unchanged (no import breakage)
</success_criteria>

<output>
After completion, create `.planning/phases/26-parser-refactoring/26-05-SUMMARY.md`
</output>
