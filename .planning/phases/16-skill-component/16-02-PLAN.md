---
phase: 16-skill-component
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - src/parser/transformer.ts
autonomous: true

must_haves:
  truths:
    - "Skill component transforms to SkillDocumentNode"
    - "SkillFile children extracted and stored in files array"
    - "SkillStatic props extracted and stored in statics array"
    - "Skill children (excluding SkillFile/SkillStatic) become body content"
  artifacts:
    - path: "src/parser/transformer.ts"
      provides: "transformSkill, transformSkillFile, transformSkillStatic methods"
      contains: "transformSkill"
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/ir/nodes.ts"
      via: "SkillDocumentNode creation"
      pattern: "kind: 'skillDocument'"
---

<objective>
Implement transformer methods for Skill, SkillFile, and SkillStatic components.

Purpose: Parse TSX skill definitions into IR nodes for emission
Output: Working transformation from Skill JSX to SkillDocumentNode IR
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-skill-component/16-RESEARCH.md
@.planning/phases/16-skill-component/16-01-SUMMARY.md

# Existing patterns to follow
@src/parser/transformer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add transformSkill method following transformAgent pattern</name>
  <files>src/parser/transformer.ts</files>
  <action>
1. Add 'Skill', 'SkillFile', 'SkillStatic' to SPECIAL_COMPONENTS set

2. Update imports to include new node types:
```typescript
import type {
  // ... existing imports ...
  SkillDocumentNode,
  SkillFrontmatterNode,
  SkillFileNode,
  SkillStaticNode,
} from '../ir/index.js';
```

3. Update transform() method to handle Skill at root level:
```typescript
if (name === 'Skill') {
  return this.transformSkill(node);
}
```

4. Add transformSkill method (following transformAgent pattern):
```typescript
private transformSkill(node: JsxElement | JsxSelfClosingElement): SkillDocumentNode {
  const openingElement = Node.isJsxElement(node)
    ? node.getOpeningElement()
    : node;

  // Extract required props
  const name = getAttributeValue(openingElement, 'name');
  const description = getAttributeValue(openingElement, 'description');

  if (!name) {
    throw this.createError('Skill requires name prop', openingElement);
  }
  if (!description) {
    throw this.createError('Skill requires description prop', openingElement);
  }

  // Validate skill name (lowercase, numbers, hyphens only)
  if (!/^[a-z0-9-]+$/.test(name)) {
    throw this.createError(
      `Skill name must be lowercase letters, numbers, and hyphens only: '${name}'`,
      openingElement
    );
  }

  // Extract optional props
  const disableModelInvocation = this.getBooleanAttribute(openingElement, 'disableModelInvocation');
  const userInvocable = this.getBooleanAttribute(openingElement, 'userInvocable');
  const allowedTools = getArrayAttributeValue(openingElement, 'allowedTools');
  const argumentHint = getAttributeValue(openingElement, 'argumentHint');
  const model = getAttributeValue(openingElement, 'model');
  const context = getAttributeValue(openingElement, 'context') as 'fork' | undefined;
  const agent = getAttributeValue(openingElement, 'agent');

  // Build frontmatter
  const frontmatter: SkillFrontmatterNode = {
    kind: 'skillFrontmatter',
    name,
    description,
    ...(disableModelInvocation !== undefined && { disableModelInvocation }),
    ...(userInvocable !== undefined && { userInvocable }),
    ...(allowedTools && allowedTools.length > 0 && { allowedTools }),
    ...(argumentHint && { argumentHint }),
    ...(model && { model }),
    ...(context && { context }),
    ...(agent && { agent }),
  };

  // Process children: separate body content, SkillFile, and SkillStatic
  const { children, files, statics } = this.processSkillChildren(node);

  return {
    kind: 'skillDocument',
    frontmatter,
    children,
    files,
    statics,
  };
}
```

5. Add helper to extract boolean attributes:
```typescript
private getBooleanAttribute(
  element: JsxOpeningElement | JsxSelfClosingElement,
  name: string
): boolean | undefined {
  const attr = element.getAttribute(name);
  if (!attr || !Node.isJsxAttribute(attr)) return undefined;

  const init = attr.getInitializer();
  // Boolean attribute without value: disableModelInvocation (means true)
  if (!init) return true;

  // JSX expression: disableModelInvocation={true}
  if (Node.isJsxExpression(init)) {
    const expr = init.getExpression();
    if (expr && (expr.getText() === 'true' || expr.getText() === 'false')) {
      return expr.getText() === 'true';
    }
  }

  return undefined;
}
```
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors in transformer.ts</verify>
  <done>transformSkill method parses Skill component into SkillDocumentNode</done>
</task>

<task type="auto">
  <name>Task 2: Add processSkillChildren to separate body, files, and statics</name>
  <files>src/parser/transformer.ts</files>
  <action>
Add method to process Skill children, separating them into three categories:

```typescript
/**
 * Process Skill children into body content, SkillFile nodes, and SkillStatic nodes
 */
private processSkillChildren(node: JsxElement | JsxSelfClosingElement): {
  children: BlockNode[];
  files: SkillFileNode[];
  statics: SkillStaticNode[];
} {
  if (Node.isJsxSelfClosingElement(node)) {
    return { children: [], files: [], statics: [] };
  }

  const children: BlockNode[] = [];
  const files: SkillFileNode[] = [];
  const statics: SkillStaticNode[] = [];
  const jsxChildren = node.getJsxChildren();

  for (const child of jsxChildren) {
    // Skip whitespace-only text
    if (Node.isJsxText(child)) {
      const text = extractText(child);
      if (!text) continue;
    }

    if (Node.isJsxElement(child) || Node.isJsxSelfClosingElement(child)) {
      const childName = getElementName(child);

      if (childName === 'SkillFile') {
        files.push(this.transformSkillFile(child));
        continue;
      }

      if (childName === 'SkillStatic') {
        statics.push(this.transformSkillStatic(child));
        continue;
      }
    }

    // Regular body content
    const block = this.transformToBlock(child);
    if (block) children.push(block);
  }

  return { children, files, statics };
}

/**
 * Transform SkillFile element to SkillFileNode
 */
private transformSkillFile(node: JsxElement | JsxSelfClosingElement): SkillFileNode {
  const openingElement = Node.isJsxElement(node)
    ? node.getOpeningElement()
    : node;

  const name = getAttributeValue(openingElement, 'name');
  if (!name) {
    throw this.createError('SkillFile requires name prop', openingElement);
  }

  // Transform children as file content
  const children = Node.isJsxElement(node)
    ? this.transformBlockChildren(node.getJsxChildren())
    : [];

  return {
    kind: 'skillFile',
    name,
    children,
  };
}

/**
 * Transform SkillStatic element to SkillStaticNode
 */
private transformSkillStatic(node: JsxElement | JsxSelfClosingElement): SkillStaticNode {
  const openingElement = Node.isJsxElement(node)
    ? node.getOpeningElement()
    : node;

  const src = getAttributeValue(openingElement, 'src');
  if (!src) {
    throw this.createError('SkillStatic requires src prop', openingElement);
  }

  const dest = getAttributeValue(openingElement, 'dest');

  return {
    kind: 'skillStatic',
    src,
    ...(dest && { dest }),
  };
}
```

Note: extractText is already imported from parser.js
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors</verify>
  <done>SkillFile and SkillStatic children transformed into separate node arrays</done>
</task>

</tasks>

<verification>
```bash
# Type check passes
npx tsc --noEmit

# Skill added to SPECIAL_COMPONENTS
grep -n "SPECIAL_COMPONENTS" src/parser/transformer.ts

# New transform methods exist
grep -n "transformSkill\|transformSkillFile\|transformSkillStatic" src/parser/transformer.ts
```
</verification>

<success_criteria>
- [ ] 'Skill', 'SkillFile', 'SkillStatic' added to SPECIAL_COMPONENTS
- [ ] transform() routes Skill to transformSkill
- [ ] transformSkill extracts all frontmatter props
- [ ] Skill name validation enforces lowercase-hyphenated format
- [ ] processSkillChildren separates body, files, and statics
- [ ] transformSkillFile extracts name and transforms children
- [ ] transformSkillStatic extracts src and optional dest
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/16-skill-component/16-02-SUMMARY.md`
</output>
