---
phase: 09-agent-transpilation
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/emitter/emitter.ts
  - src/cli/commands/build.ts
  - tests/emitter/agent-emitter.test.ts
autonomous: true

must_haves:
  truths:
    - "AgentDocumentNode emits to valid GSD-format markdown (tools as string, not array)"
    - "Agent output routes to .claude/agents/ directory (not .claude/commands/)"
    - "Agent with folder prop routes to nested path (.claude/agents/{folder}/{name}.md)"
    - "CLI creates nested directories when folder prop specifies nested path"
    - "End-to-end: Agent TSX file builds to correct output path with correct content"
  artifacts:
    - path: "src/emitter/emitter.ts"
      provides: "emitAgent method for AgentDocumentNode emission"
      contains: "emitAgent"
    - path: "src/emitter/emitter.ts"
      provides: "emitAgentFrontmatter method for GSD format"
      contains: "emitAgentFrontmatter"
    - path: "src/cli/commands/build.ts"
      provides: "Output routing based on document kind"
      contains: "agentDocument"
    - path: "tests/emitter/agent-emitter.test.ts"
      provides: "Agent emission tests"
      min_lines: 60
  key_links:
    - from: "src/cli/commands/build.ts"
      to: "src/emitter/emitter.ts"
      via: "emitAgent import and call"
      pattern: "emitAgent"
    - from: "src/cli/commands/build.ts"
      to: "doc.kind check"
      via: "Document kind routing"
      pattern: "doc\\.kind === 'agentDocument'"
---

<objective>
Add Agent emission and output routing to complete Agent transpilation.

Purpose: Enable Agent TSX files to produce GSD-format markdown in the correct `.claude/agents/` output directory, with support for folder-based namespacing.

Output: Working end-to-end Agent transpilation from TSX to `.claude/agents/{folder?}/{basename}.md`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-agent-transpilation/09-01-SUMMARY.md
@.planning/phases/09-agent-transpilation/09-RESEARCH.md

@src/emitter/emitter.ts
@src/cli/commands/build.ts
@src/ir/nodes.ts
@src/parser/transformer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add emitAgent and emitAgentFrontmatter methods</name>
  <files>src/emitter/emitter.ts</files>
  <action>
Add Agent emission methods to MarkdownEmitter class.

**Step 1: Add imports**
Add AgentDocumentNode and AgentFrontmatterNode to the import:
```typescript
import type {
  AgentDocumentNode,
  AgentFrontmatterNode,
  // ... existing imports
} from '../ir/index.js';
```

**Step 2: Add emitAgentFrontmatter private method**
GSD format uses `tools` as space-separated string (not array like Command's `allowed-tools`):
```typescript
/**
 * Emit Agent frontmatter (GSD format: tools as string)
 */
private emitAgentFrontmatter(node: AgentFrontmatterNode): string {
  const data: Record<string, unknown> = {
    name: node.name,
    description: node.description,
  };
  if (node.tools) {
    data.tools = node.tools;
  }
  if (node.color) {
    data.color = node.color;
  }
  return matter.stringify('', data).trimEnd();
}
```

**Step 3: Add emitAgent public method**
Follow emit() pattern but uses emitAgentFrontmatter:
```typescript
/**
 * Emit an AgentDocumentNode to markdown
 */
emitAgent(doc: AgentDocumentNode): string {
  const parts: string[] = [];

  // Agent frontmatter (GSD format)
  parts.push(this.emitAgentFrontmatter(doc.frontmatter));

  // Body content (same as Command)
  for (const child of doc.children) {
    parts.push(this.emitBlock(child));
  }

  // Join with double newlines for block separation, then ensure single trailing newline
  const result = parts.join('\n\n');
  return result ? result + '\n' : '';
}
```

**Step 4: Add convenience function**
Add at the bottom of the file:
```typescript
/**
 * Convenience function for emitting an agent document
 */
export function emitAgent(doc: AgentDocumentNode): string {
  const emitter = new MarkdownEmitter();
  return emitter.emitAgent(doc);
}
```

**Important:** Do NOT modify the existing emit() function - it remains for DocumentNode (Command).
  </action>
  <verify>
Run `npm run typecheck` - should pass.
Run `npm run build` - dist/emitter/emitter.d.ts should export emitAgent.
  </verify>
  <done>
emitAgentFrontmatter produces GSD-format YAML (name, description, tools as string, color). emitAgent produces complete markdown with frontmatter and body. Convenience function emitAgent exported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update build.ts for Agent output routing</name>
  <files>src/cli/commands/build.ts</files>
  <action>
Modify build command to route Agent output to `.claude/agents/` directory.

**Step 1: Update imports**
Add emitAgent import and AgentDocumentNode type:
```typescript
import { createProject, findRootJsxElement, transform, emit, emitAgent } from '../../index.js';
import type { AgentDocumentNode } from '../../ir/index.js';
```

Also add getAttributeValue for folder prop extraction:
```typescript
import { createProject, findRootJsxElement, transform, emit, emitAgent, getAttributeValue } from '../../index.js';
```

**Step 2: Modify runBuild to handle document kind**
After `const doc = transform(root, sourceFile);`, add document-kind-aware output routing:

```typescript
// Transform to IR (pass sourceFile for error location context)
const doc = transform(root, sourceFile);

// Determine output path and emit based on document type
let markdown: string;
let outputPath: string;
const basename = path.basename(inputFile, '.tsx');

if (doc.kind === 'agentDocument') {
  // Agent: emit with GSD format
  markdown = emitAgent(doc);

  // Get folder prop for output path (need to re-parse for this)
  // The folder prop affects output path but is not in frontmatter
  const root2 = findRootJsxElement(sourceFile);
  const folder = root2 && (Node.isJsxElement(root2) || Node.isJsxSelfClosingElement(root2))
    ? getAttributeValue(
        Node.isJsxElement(root2) ? root2.getOpeningElement() : root2,
        'folder'
      )
    : undefined;

  // Route to .claude/agents/{folder?}/{basename}.md
  const agentDir = folder
    ? path.join('.claude/agents', folder)
    : '.claude/agents';
  outputPath = path.join(agentDir, `${basename}.md`);
} else {
  // Command: emit with standard format, use --out option
  markdown = emit(doc);
  outputPath = path.join(options.out, `${basename}.md`);
}
```

**Step 3: Update mkdir to handle per-file directories**
Move mkdir inside the file loop since Agent files may have different output directories:
```typescript
// Write file (ensure directory exists first)
const outputDir = path.dirname(outputPath);
await mkdir(outputDir, { recursive: true });
await writeFile(outputPath, markdown, 'utf-8');
```

Remove the single `await mkdir(options.out, { recursive: true });` that was outside the loop.

**Step 4: Add Node import**
At the top, add Node to ts-morph imports:
```typescript
import { Node } from 'ts-morph';
import type { Project } from 'ts-morph';
```

**Note:** The folder prop extraction is a bit awkward (re-finding root element), but this keeps folder out of the IR (it's a build concern, not a document concern). An alternative would be to add folder to AgentDocumentNode, but CONTEXT.md suggests keeping it as build-time-only.
  </action>
  <verify>
Run `npm run typecheck` - should pass.
Run `npm run build` - should succeed.
Manual test: Create Agent TSX, run build, verify output in .claude/agents/.
  </verify>
  <done>
Agent documents route to .claude/agents/. folder prop creates nested directories. mkdir called per-file to handle different output directories. Command documents still route to --out option (default .claude/commands/).
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Agent emitter tests</name>
  <files>tests/emitter/agent-emitter.test.ts</files>
  <action>
Create Agent emission tests following the pattern in existing emitter tests.

**Test setup:**
```typescript
import { describe, it, expect } from 'vitest';
import { emitAgent } from '../../src/emitter/emitter.js';
import type { AgentDocumentNode, AgentFrontmatterNode } from '../../src/ir/index.js';

function createAgentDoc(
  frontmatter: Omit<AgentFrontmatterNode, 'kind'>,
  children: AgentDocumentNode['children'] = []
): AgentDocumentNode {
  return {
    kind: 'agentDocument',
    frontmatter: { kind: 'agentFrontmatter', ...frontmatter },
    children,
  };
}
```

**Test cases (at least 6):**

1. **Basic Agent emission** - name and description only
2. **Agent with all frontmatter fields** - name, description, tools, color
3. **Agent frontmatter uses tools as string** - verify NOT array format
4. **Agent with body content** - heading + paragraph
5. **Agent omits undefined optional fields** - no tools/color in output
6. **Empty Agent (no body)** - frontmatter only

**Example tests:**
```typescript
describe('Agent emission', () => {
  it('emits Agent with required fields only', () => {
    const doc = createAgentDoc({
      name: 'minimal-agent',
      description: 'Minimal agent description',
    });

    const output = emitAgent(doc);

    expect(output).toContain('---');
    expect(output).toContain('name: minimal-agent');
    expect(output).toContain('description: Minimal agent description');
    expect(output).not.toContain('tools:');
    expect(output).not.toContain('color:');
  });

  it('emits tools as string (not array)', () => {
    const doc = createAgentDoc({
      name: 'tool-agent',
      description: 'Agent with tools',
      tools: 'Read Grep Glob',
    });

    const output = emitAgent(doc);

    // Should be: tools: Read Grep Glob
    // NOT: tools:\n  - Read\n  - Grep\n  - Glob
    expect(output).toContain('tools: Read Grep Glob');
    expect(output).not.toMatch(/tools:\s*\n\s+-/);
  });

  it('emits Agent with body content', () => {
    const doc = createAgentDoc(
      {
        name: 'content-agent',
        description: 'Agent with content',
      },
      [
        { kind: 'heading', level: 1, children: [{ kind: 'text', value: 'Role' }] },
        { kind: 'paragraph', children: [{ kind: 'text', value: 'You are a helpful agent.' }] },
      ]
    );

    const output = emitAgent(doc);

    expect(output).toContain('# Role');
    expect(output).toContain('You are a helpful agent.');
  });
});
```

Ensure tests verify GSD format specifically (tools as string, not YAML array).
  </action>
  <verify>
Run `npm test tests/emitter/agent-emitter.test.ts` - all tests pass.
Run `npm test` - all tests pass (no regressions).
  </verify>
  <done>
6+ tests covering Agent emission: required fields, all fields, tools as string format, body content, omitted optional fields, empty body.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Type checking:** `npm run typecheck` passes
2. **Build:** `npm run build` succeeds
3. **Tests:** `npm test` - all tests pass including new Agent emitter tests
4. **End-to-end verification:**

Create test file `src/app/test-agent.tsx`:
```tsx
import { Agent } from 'react-agentic';

export default function TestAgent() {
  return (
    <Agent
      name="test-agent"
      description="A test agent for verification"
      tools="Read Grep Glob"
      color="cyan"
    >
      <h1>Role</h1>
      <p>You are a test agent for verifying the transpilation pipeline.</p>
    </Agent>
  );
}
```

Run: `npm run build -- src/app/test-agent.tsx`

Expected output at `.claude/agents/test-agent.md`:
```markdown
---
name: test-agent
description: A test agent for verification
tools: Read Grep Glob
color: cyan
---

# Role

You are a test agent for verifying the transpilation pipeline.
```

**Folder prop verification:**
Create `src/app/team-agent.tsx` with `folder="my-team"`:
```tsx
<Agent name="team-helper" description="..." folder="my-team">
```

Run build, verify output at `.claude/agents/my-team/team-agent.md`.
</verification>

<success_criteria>
- emitAgent produces valid GSD-format markdown
- emitAgentFrontmatter outputs tools as string (not YAML array)
- Optional fields (tools, color) omitted when undefined
- Agent files output to .claude/agents/ directory
- folder prop creates nested directories
- Command files still output to --out directory (default .claude/commands/)
- 6+ emission tests covering all scenarios
- End-to-end Agent TSX -> markdown works correctly
- All tests pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/09-agent-transpilation/09-02-SUMMARY.md`
</output>
