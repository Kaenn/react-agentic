---
phase: 34-agent-contract-components
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/parser/transformers/contract.ts
  - src/parser/transformers/document.ts
  - src/parser/transformers/dispatch.ts
autonomous: true

must_haves:
  truths:
    - "Contract components inside Agent are transformed to IR nodes"
    - "Role, UpstreamInput, DownstreamConsumer, Methodology, StructuredReturns transform correctly"
    - "Return components inside StructuredReturns transform to ReturnNode"
  artifacts:
    - path: "src/parser/transformers/contract.ts"
      provides: "Contract component transformation functions"
      exports: ["transformRole", "transformUpstreamInput", "transformDownstreamConsumer", "transformMethodology", "transformStructuredReturns"]
    - path: "src/parser/transformers/document.ts"
      provides: "Updated Agent transformer with contract component handling"
      contains: "contract component"
  key_links:
    - from: "src/parser/transformers/dispatch.ts"
      to: "src/parser/transformers/contract.ts"
      via: "import and case handling"
      pattern: "case 'Role'"
---

# Plan 34-02: Parser Transformers for Contract Components

<objective>
Create parser transformers that convert contract component JSX elements to their corresponding IR nodes inside Agent transformation.

Purpose: Enable the compiler to recognize and transform Role, UpstreamInput, DownstreamConsumer, Methodology, StructuredReturns, and Return components.
Output: New contract.ts transformer file, updates to document.ts and dispatch.ts.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-agent-contract-components/34-CONTEXT.md
@.planning/phases/34-agent-contract-components/34-RESEARCH.md

Source files:
@src/parser/transformers/document.ts
@src/parser/transformers/dispatch.ts
@src/parser/transformers/types.ts
@src/ir/nodes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Contract Transformers</name>
  <files>src/parser/transformers/contract.ts</files>
  <action>
Create new file `src/parser/transformers/contract.ts`:

```typescript
/**
 * Contract Component Transformers
 *
 * Transforms agent contract components to IR nodes:
 * - Role → RoleNode
 * - UpstreamInput → UpstreamInputNode
 * - DownstreamConsumer → DownstreamConsumerNode
 * - Methodology → MethodologyNode
 * - StructuredReturns → StructuredReturnsNode (with Return children)
 */

import {
  Node,
  JsxElement,
  JsxSelfClosingElement,
} from 'ts-morph';
import type {
  RoleNode,
  UpstreamInputNode,
  DownstreamConsumerNode,
  MethodologyNode,
  StructuredReturnsNode,
  ReturnNode,
  BaseBlockNode,
} from '../../ir/nodes.js';
import { getElementName, getAttributeValue } from '../utils/index.js';
import type { TransformContext } from './types.js';
import { transformBlockChildren as dispatchTransformBlockChildren } from './dispatch.js';

// ============================================================================
// Helper
// ============================================================================

/**
 * Get transformBlockChildren function from context or fallback to dispatch
 */
function getTransformBlockChildren(ctx: TransformContext) {
  return ctx.transformBlockChildren ?? dispatchTransformBlockChildren;
}

// ============================================================================
// Simple Container Transformers
// ============================================================================

/**
 * Transform Role component to RoleNode
 */
export function transformRole(
  node: JsxElement | JsxSelfClosingElement,
  ctx: TransformContext
): RoleNode {
  const children = Node.isJsxElement(node)
    ? getTransformBlockChildren(ctx)(node.getJsxChildren(), ctx)
    : [];

  return {
    kind: 'role',
    children: children as BaseBlockNode[],
  };
}

/**
 * Transform UpstreamInput component to UpstreamInputNode
 */
export function transformUpstreamInput(
  node: JsxElement | JsxSelfClosingElement,
  ctx: TransformContext
): UpstreamInputNode {
  const children = Node.isJsxElement(node)
    ? getTransformBlockChildren(ctx)(node.getJsxChildren(), ctx)
    : [];

  return {
    kind: 'upstreamInput',
    children: children as BaseBlockNode[],
  };
}

/**
 * Transform DownstreamConsumer component to DownstreamConsumerNode
 */
export function transformDownstreamConsumer(
  node: JsxElement | JsxSelfClosingElement,
  ctx: TransformContext
): DownstreamConsumerNode {
  const children = Node.isJsxElement(node)
    ? getTransformBlockChildren(ctx)(node.getJsxChildren(), ctx)
    : [];

  return {
    kind: 'downstreamConsumer',
    children: children as BaseBlockNode[],
  };
}

/**
 * Transform Methodology component to MethodologyNode
 */
export function transformMethodology(
  node: JsxElement | JsxSelfClosingElement,
  ctx: TransformContext
): MethodologyNode {
  const children = Node.isJsxElement(node)
    ? getTransformBlockChildren(ctx)(node.getJsxChildren(), ctx)
    : [];

  return {
    kind: 'methodology',
    children: children as BaseBlockNode[],
  };
}

// ============================================================================
// StructuredReturns Transformer
// ============================================================================

/**
 * Transform Return component to ReturnNode
 * Only valid inside StructuredReturns
 */
export function transformReturn(
  node: JsxElement | JsxSelfClosingElement,
  ctx: TransformContext
): ReturnNode {
  const opening = Node.isJsxElement(node) ? node.getOpeningElement() : node;

  const status = getAttributeValue(opening, 'status');
  if (!status) {
    throw ctx.createError('Return requires status prop', node);
  }

  const children = Node.isJsxElement(node)
    ? getTransformBlockChildren(ctx)(node.getJsxChildren(), ctx)
    : [];

  return {
    kind: 'return',
    status,
    children: children as BaseBlockNode[],
  };
}

/**
 * Transform StructuredReturns component to StructuredReturnsNode
 * Contains Return children only
 */
export function transformStructuredReturns(
  node: JsxElement | JsxSelfClosingElement,
  ctx: TransformContext
): StructuredReturnsNode {
  if (Node.isJsxSelfClosingElement(node)) {
    throw ctx.createError('StructuredReturns must have Return children', node);
  }

  const returns: ReturnNode[] = [];

  for (const child of node.getJsxChildren()) {
    // Skip whitespace-only text
    if (Node.isJsxText(child)) {
      const text = child.getText().trim();
      if (!text) continue;
      // Non-empty text inside StructuredReturns is an error
      throw ctx.createError(
        'StructuredReturns can only contain Return components, not text',
        child
      );
    }

    if (Node.isJsxElement(child) || Node.isJsxSelfClosingElement(child)) {
      const childName = getElementName(child);
      if (childName === 'Return') {
        returns.push(transformReturn(child, ctx));
      } else {
        throw ctx.createError(
          `StructuredReturns can only contain Return components, not <${childName}>`,
          child
        );
      }
    }
  }

  if (returns.length === 0) {
    throw ctx.createError('StructuredReturns must have at least one Return child', node);
  }

  return {
    kind: 'structuredReturns',
    returns,
  };
}

// ============================================================================
// Contract Component Detection
// ============================================================================

/**
 * Check if element name is a contract component
 */
export function isContractComponent(name: string): boolean {
  return [
    'Role',
    'UpstreamInput',
    'DownstreamConsumer',
    'Methodology',
    'StructuredReturns',
    'Return',
  ].includes(name);
}
```
  </action>
  <verify>
```bash
cd /Users/glenninizan/workspace/react-agentic/react-agentic && npx tsc --noEmit 2>&1 | head -20
```
TypeScript should compile without errors.
  </verify>
  <done>Contract transformer file exists with all transformation functions</done>
</task>

<task type="auto">
  <name>Task 2: Register Transformers in Dispatch</name>
  <files>src/parser/transformers/dispatch.ts</files>
  <action>
In `src/parser/transformers/dispatch.ts`, add imports and cases for contract components.

Add import at the top (after existing transformer imports):
```typescript
import {
  transformRole,
  transformUpstreamInput,
  transformDownstreamConsumer,
  transformMethodology,
  transformStructuredReturns,
  isContractComponent,
} from './contract.js';
```

In the `dispatchBlockTransform` function's switch statement (or if-else chain for element names), add cases for contract components:

```typescript
// Contract components (inside Agent)
case 'Role':
  return transformRole(node, ctx);
case 'UpstreamInput':
  return transformUpstreamInput(node, ctx);
case 'DownstreamConsumer':
  return transformDownstreamConsumer(node, ctx);
case 'Methodology':
  return transformMethodology(node, ctx);
case 'StructuredReturns':
  return transformStructuredReturns(node, ctx);
case 'Return':
  // Return outside StructuredReturns - this is handled by StructuredReturns transformer
  // If we get here, it means Return was used outside StructuredReturns
  throw ctx.createError('Return component can only be used inside StructuredReturns', node);
```
  </action>
  <verify>
```bash
cd /Users/glenninizan/workspace/react-agentic/react-agentic && npx tsc --noEmit 2>&1 | head -20
```
TypeScript should compile without errors.
  </verify>
  <done>Dispatch.ts routes contract component names to their transformers</done>
</task>

<task type="auto">
  <name>Task 3: Update Transformer Index Export</name>
  <files>src/parser/transformers/index.ts</files>
  <action>
Add export for contract transformers in `src/parser/transformers/index.ts`:

```typescript
// Contract component transformers
export {
  transformRole,
  transformUpstreamInput,
  transformDownstreamConsumer,
  transformMethodology,
  transformStructuredReturns,
  transformReturn,
  isContractComponent,
} from './contract.js';
```
  </action>
  <verify>
```bash
cd /Users/glenninizan/workspace/react-agentic/react-agentic && npm run build 2>&1 | head -30
```
Build should succeed.
  </verify>
  <done>Contract transformers are exported from transformers/index.ts</done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

```bash
cd /Users/glenninizan/workspace/react-agentic/react-agentic

# Build succeeds
npm run build

# Transformer file exists
ls src/parser/transformers/contract.ts

# Functions are exported
grep -l "transformRole" dist/parser/transformers/index.d.ts
```

Expected:
- Build succeeds with no errors
- contract.ts exists with transformation functions
- Exports are available from transformers/index.ts
</verification>

<success_criteria>
- [ ] src/parser/transformers/contract.ts exists with all transform functions
- [ ] dispatch.ts has cases for all 6 contract component names
- [ ] transformers/index.ts exports contract transformer functions
- [ ] npm run build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/34-agent-contract-components/34-02-SUMMARY.md`
</output>
