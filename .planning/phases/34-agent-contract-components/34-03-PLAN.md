---
phase: 34-agent-contract-components
plan: 03
type: execute
wave: 2
depends_on: ["34-01", "34-02"]
files_modified:
  - src/emitter/emitter.ts
  - src/parser/transformers/document.ts
autonomous: true

must_haves:
  truths:
    - "Contract components emit as snake_case XML blocks"
    - "StructuredReturns emits with ## headings for each Return status"
    - "Validation enforces ordering: Role → UpstreamInput → DownstreamConsumer → Methodology → StructuredReturns"
    - "Duplicate contract components cause compile error"
    - "If Agent has status type generic, StructuredReturns is required"
    - "StructuredReturns must be exhaustive for declared status type"
  artifacts:
    - path: "src/emitter/emitter.ts"
      provides: "Contract node emission logic"
      contains: "emitContractComponent"
    - path: "src/parser/transformers/document.ts"
      provides: "Contract component validation in transformAgent"
      contains: "validateContractComponents"
  key_links:
    - from: "src/emitter/emitter.ts"
      to: "src/ir/nodes.ts"
      via: "switch case handling"
      pattern: "case 'role'"
---

# Plan 34-03: Emitter and Validation Logic

<objective>
Add emission logic for contract nodes and compile-time validation rules for ordering, uniqueness, and exhaustiveness.

Purpose: Contract components must render correctly as markdown and validation must catch errors at compile time.
Output: Emitter cases for contract nodes, validation function in document transformer.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-agent-contract-components/34-CONTEXT.md
@.planning/phases/34-agent-contract-components/34-RESEARCH.md

Source files:
@src/emitter/emitter.ts
@src/parser/transformers/document.ts
@src/ir/nodes.ts

Prior plan summaries (if needed):
@.planning/phases/34-agent-contract-components/34-01-SUMMARY.md
@.planning/phases/34-agent-contract-components/34-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Emitter Cases for Contract Nodes</name>
  <files>src/emitter/emitter.ts</files>
  <action>
In `src/emitter/emitter.ts`, add import for new node types (if not using wildcard import):

Find the import block for node types and add:
```typescript
import type {
  // ... existing imports ...
  RoleNode,
  UpstreamInputNode,
  DownstreamConsumerNode,
  MethodologyNode,
  StructuredReturnsNode,
  ReturnNode,
} from '../ir/index.js';
```

In the `emitBlock` method's switch statement, add cases for contract nodes (before the default case):

```typescript
case 'role':
  return this.emitContractComponent('role', node as RoleNode);
case 'upstreamInput':
  return this.emitContractComponent('upstream_input', node as UpstreamInputNode);
case 'downstreamConsumer':
  return this.emitContractComponent('downstream_consumer', node as DownstreamConsumerNode);
case 'methodology':
  return this.emitContractComponent('methodology', node as MethodologyNode);
case 'structuredReturns':
  return this.emitStructuredReturns(node as StructuredReturnsNode);
```

Add helper methods to the MarkdownEmitter class:

```typescript
/**
 * Emit a contract component as XML block with snake_case tag name
 */
private emitContractComponent(
  tagName: string,
  node: RoleNode | UpstreamInputNode | DownstreamConsumerNode | MethodologyNode
): string {
  const children = node.children.map(c => this.emitBlock(c)).join('\n\n');
  // Indent children for readability
  return `<${tagName}>\n${children}\n</${tagName}>`;
}

/**
 * Emit StructuredReturns with ## headings for each status
 */
private emitStructuredReturns(node: StructuredReturnsNode): string {
  const sections = node.returns.map(returnNode => {
    const heading = `## ${returnNode.status}`;
    const content = returnNode.children
      .map(c => this.emitBlock(c))
      .join('\n\n');
    return content ? `${heading}\n\n${content}` : heading;
  }).join('\n\n');

  return `<structured_returns>\n\n${sections}\n\n</structured_returns>`;
}
```
  </action>
  <verify>
```bash
cd /Users/glenninizan/workspace/react-agentic/react-agentic && npx tsc --noEmit 2>&1 | head -30
```
TypeScript should compile without errors.
  </verify>
  <done>Emitter has cases for all contract node types with correct snake_case tag output</done>
</task>

<task type="auto">
  <name>Task 2: Add Contract Validation in Agent Transformer</name>
  <files>src/parser/transformers/document.ts</files>
  <action>
In `src/parser/transformers/document.ts`, add validation logic to the `transformAgent` function.

After the children are transformed (around line 487 where `return { kind: 'agentDocument', ... }` is), add validation:

```typescript
// Add this helper function at the top of the file (after imports)
import type {
  RoleNode,
  UpstreamInputNode,
  DownstreamConsumerNode,
  MethodologyNode,
  StructuredReturnsNode,
} from '../../ir/nodes.js';
import { Node as TsMorphNode } from 'ts-morph';

/**
 * Contract component kinds in required order
 */
const CONTRACT_COMPONENT_ORDER = [
  'role',
  'upstreamInput',
  'downstreamConsumer',
  'methodology',
  'structuredReturns',
] as const;

type ContractKind = typeof CONTRACT_COMPONENT_ORDER[number];

/**
 * Extract status type from Agent generic parameter
 * Returns undefined if no status type specified or type not found
 */
function extractAgentStatusType(
  node: JsxElement | JsxSelfClosingElement,
  ctx: TransformContext
): string[] | undefined {
  const opening = TsMorphNode.isJsxElement(node) ? node.getOpeningElement() : node;
  const tagNameNode = opening.getTagNameNode();

  // Get the expression - might be just "Agent" or "Agent<StatusType>"
  const typeArgs = tagNameNode.getType().getTypeArguments();
  if (typeArgs.length === 0) return undefined;

  // First type argument is the status type
  const statusType = typeArgs[0];
  if (!statusType) return undefined;

  // If it's a union type, extract all literals
  if (statusType.isUnion()) {
    const literals: string[] = [];
    for (const unionType of statusType.getUnionTypes()) {
      if (unionType.isStringLiteral()) {
        literals.push(unionType.getLiteralValue() as string);
      }
    }
    return literals.length > 0 ? literals : undefined;
  }

  // If it's a single string literal
  if (statusType.isStringLiteral()) {
    return [statusType.getLiteralValue() as string];
  }

  // Not a string literal type - can't validate
  return undefined;
}

/**
 * Validate contract components in agent children
 * - At most one of each type
 * - Must appear in correct order (can be interleaved with other content)
 * - If statusType exists, StructuredReturns is required
 * - StructuredReturns must be exhaustive for statusType
 */
function validateContractComponents(
  children: BaseBlockNode[],
  statusTypes: string[] | undefined,
  ctx: TransformContext,
  node: Node
): void {
  // Count occurrences of each contract component type
  const counts: Partial<Record<ContractKind, number>> = {};
  let structuredReturns: StructuredReturnsNode | undefined;

  for (const child of children) {
    const kind = child.kind as ContractKind;
    if (CONTRACT_COMPONENT_ORDER.includes(kind)) {
      counts[kind] = (counts[kind] || 0) + 1;
      if (kind === 'structuredReturns') {
        structuredReturns = child as StructuredReturnsNode;
      }
    }
  }

  // Check for duplicates
  for (const [kind, count] of Object.entries(counts)) {
    if (count > 1) {
      const componentName = kindToComponentName(kind as ContractKind);
      throw ctx.createError(
        `Agent can only have one <${componentName}> component (found ${count})`,
        node
      );
    }
  }

  // Check ordering (filter to only contract components, verify they're in order)
  let lastIndex = -1;
  for (const child of children) {
    const kind = child.kind as ContractKind;
    const currentIndex = CONTRACT_COMPONENT_ORDER.indexOf(kind);
    if (currentIndex !== -1) {
      if (currentIndex < lastIndex) {
        throw ctx.createError(
          'Contract components must appear in order: Role → UpstreamInput → DownstreamConsumer → Methodology → StructuredReturns',
          node
        );
      }
      lastIndex = currentIndex;
    }
  }

  // If Agent has status type, StructuredReturns is required
  if (statusTypes && statusTypes.length > 0 && !structuredReturns) {
    throw ctx.createError(
      `Agent with status type must include <StructuredReturns> documenting all status values`,
      node
    );
  }

  // Validate exhaustiveness if both statusTypes and StructuredReturns exist
  if (statusTypes && statusTypes.length > 0 && structuredReturns) {
    const documentedStatuses = new Set(
      structuredReturns.returns.map(r => r.status)
    );

    // Check for missing statuses
    const missing = statusTypes.filter(s => !documentedStatuses.has(s));
    if (missing.length > 0) {
      throw ctx.createError(
        `StructuredReturns must document all statuses. Missing: ${missing.join(', ')}`,
        node
      );
    }

    // Check for extra statuses
    const extra = Array.from(documentedStatuses).filter(s => !statusTypes.includes(s));
    if (extra.length > 0) {
      throw ctx.createError(
        `StructuredReturns contains undeclared statuses: ${extra.join(', ')}`,
        node
      );
    }
  }
}

/**
 * Convert IR node kind to component name for error messages
 */
function kindToComponentName(kind: ContractKind): string {
  switch (kind) {
    case 'role': return 'Role';
    case 'upstreamInput': return 'UpstreamInput';
    case 'downstreamConsumer': return 'DownstreamConsumer';
    case 'methodology': return 'Methodology';
    case 'structuredReturns': return 'StructuredReturns';
  }
}
```

Then in the `transformAgent` function, extract status type and call validation before the return statement:

```typescript
// Before: return { kind: 'agentDocument', frontmatter, children: children as BaseBlockNode[] };

// Extract status type from Agent generic (if any)
const statusTypes = extractAgentStatusType(node, ctx);

// Add validation (with status type for exhaustiveness check)
validateContractComponents(children as BaseBlockNode[], statusTypes, ctx, node);

return { kind: 'agentDocument', frontmatter, children: children as BaseBlockNode[] };
```
  </action>
  <verify>
```bash
cd /Users/glenninizan/workspace/react-agentic/react-agentic && npm run build 2>&1 | head -30
```
Build should succeed.
  </verify>
  <done>Contract component validation enforces ordering and uniqueness rules</done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

```bash
cd /Users/glenninizan/workspace/react-agentic/react-agentic

# Build succeeds
npm run build

# Run existing tests to ensure no regressions
npm test 2>&1 | tail -20
```

Expected:
- Build succeeds with no errors
- Existing tests pass
- Emitter handles all contract node types
- Validation prevents duplicate/misordered contract components
</verification>

<success_criteria>
- [ ] Emitter has emitContractComponent and emitStructuredReturns methods
- [ ] All 5 contract node kinds have cases in emitBlock switch
- [ ] validateContractComponents function exists in document.ts
- [ ] transformAgent calls validateContractComponents
- [ ] Status type extraction from Agent generic implemented
- [ ] Exhaustiveness validation for StructuredReturns implemented
- [ ] npm run build succeeds
- [ ] npm test passes (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/34-agent-contract-components/34-03-SUMMARY.md`
</output>
