---
phase: 34-agent-contract-components
plan: 03
type: execute
wave: 2
depends_on: ["34-01", "34-02"]
files_modified:
  - src/emitter/emitter.ts
  - src/parser/transformers/document.ts
autonomous: true

must_haves:
  truths:
    - "Contract components emit as snake_case XML blocks"
    - "StructuredReturns emits with ## headings for each Return status"
    - "Validation enforces ordering: Role → UpstreamInput → DownstreamConsumer → Methodology → StructuredReturns"
    - "Duplicate contract components cause compile error"
  artifacts:
    - path: "src/emitter/emitter.ts"
      provides: "Contract node emission logic"
      contains: "emitContractComponent"
    - path: "src/parser/transformers/document.ts"
      provides: "Contract component validation in transformAgent"
      contains: "validateContractComponents"
  key_links:
    - from: "src/emitter/emitter.ts"
      to: "src/ir/nodes.ts"
      via: "switch case handling"
      pattern: "case 'role'"
---

# Plan 34-03: Emitter and Validation Logic

<objective>
Add emission logic for contract nodes and compile-time validation rules for ordering, uniqueness, and exhaustiveness.

Purpose: Contract components must render correctly as markdown and validation must catch errors at compile time.
Output: Emitter cases for contract nodes, validation function in document transformer.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-agent-contract-components/34-CONTEXT.md
@.planning/phases/34-agent-contract-components/34-RESEARCH.md

Source files:
@src/emitter/emitter.ts
@src/parser/transformers/document.ts
@src/ir/nodes.ts

Prior plan summaries (if needed):
@.planning/phases/34-agent-contract-components/34-01-SUMMARY.md
@.planning/phases/34-agent-contract-components/34-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Emitter Cases for Contract Nodes</name>
  <files>src/emitter/emitter.ts</files>
  <action>
In `src/emitter/emitter.ts`, add import for new node types (if not using wildcard import):

Find the import block for node types and add:
```typescript
import type {
  // ... existing imports ...
  RoleNode,
  UpstreamInputNode,
  DownstreamConsumerNode,
  MethodologyNode,
  StructuredReturnsNode,
  ReturnNode,
} from '../ir/index.js';
```

In the `emitBlock` method's switch statement, add cases for contract nodes (before the default case):

```typescript
case 'role':
  return this.emitContractComponent('role', node as RoleNode);
case 'upstreamInput':
  return this.emitContractComponent('upstream_input', node as UpstreamInputNode);
case 'downstreamConsumer':
  return this.emitContractComponent('downstream_consumer', node as DownstreamConsumerNode);
case 'methodology':
  return this.emitContractComponent('methodology', node as MethodologyNode);
case 'structuredReturns':
  return this.emitStructuredReturns(node as StructuredReturnsNode);
```

Add helper methods to the MarkdownEmitter class:

```typescript
/**
 * Emit a contract component as XML block with snake_case tag name
 */
private emitContractComponent(
  tagName: string,
  node: RoleNode | UpstreamInputNode | DownstreamConsumerNode | MethodologyNode
): string {
  const children = node.children.map(c => this.emitBlock(c)).join('\n\n');
  // Indent children for readability
  return `<${tagName}>\n${children}\n</${tagName}>`;
}

/**
 * Emit StructuredReturns with ## headings for each status
 */
private emitStructuredReturns(node: StructuredReturnsNode): string {
  const sections = node.returns.map(returnNode => {
    const heading = `## ${returnNode.status}`;
    const content = returnNode.children
      .map(c => this.emitBlock(c))
      .join('\n\n');
    return content ? `${heading}\n\n${content}` : heading;
  }).join('\n\n');

  return `<structured_returns>\n\n${sections}\n\n</structured_returns>`;
}
```
  </action>
  <verify>
```bash
cd /Users/glenninizan/workspace/react-agentic/react-agentic && npx tsc --noEmit 2>&1 | head -30
```
TypeScript should compile without errors.
  </verify>
  <done>Emitter has cases for all contract node types with correct snake_case tag output</done>
</task>

<task type="auto">
  <name>Task 2: Add Contract Validation in Agent Transformer</name>
  <files>src/parser/transformers/document.ts</files>
  <action>
In `src/parser/transformers/document.ts`, add validation logic to the `transformAgent` function.

After the children are transformed (around line 487 where `return { kind: 'agentDocument', ... }` is), add validation:

```typescript
// Add this helper function at the top of the file (after imports)
import type {
  RoleNode,
  UpstreamInputNode,
  DownstreamConsumerNode,
  MethodologyNode,
  StructuredReturnsNode,
} from '../../ir/nodes.js';

/**
 * Contract component kinds in required order
 */
const CONTRACT_COMPONENT_ORDER = [
  'role',
  'upstreamInput',
  'downstreamConsumer',
  'methodology',
  'structuredReturns',
] as const;

type ContractKind = typeof CONTRACT_COMPONENT_ORDER[number];

/**
 * Validate contract components in agent children
 * - At most one of each type
 * - Must appear in correct order (can be interleaved with other content)
 */
function validateContractComponents(
  children: BaseBlockNode[],
  ctx: TransformContext,
  node: Node
): void {
  // Count occurrences of each contract component type
  const counts: Partial<Record<ContractKind, number>> = {};

  for (const child of children) {
    const kind = child.kind as ContractKind;
    if (CONTRACT_COMPONENT_ORDER.includes(kind)) {
      counts[kind] = (counts[kind] || 0) + 1;
    }
  }

  // Check for duplicates
  for (const [kind, count] of Object.entries(counts)) {
    if (count > 1) {
      const componentName = kindToComponentName(kind as ContractKind);
      throw ctx.createError(
        `Agent can only have one <${componentName}> component (found ${count})`,
        node
      );
    }
  }

  // Check ordering (filter to only contract components, verify they're in order)
  let lastIndex = -1;
  for (const child of children) {
    const kind = child.kind as ContractKind;
    const currentIndex = CONTRACT_COMPONENT_ORDER.indexOf(kind);
    if (currentIndex !== -1) {
      if (currentIndex < lastIndex) {
        throw ctx.createError(
          'Contract components must appear in order: Role → UpstreamInput → DownstreamConsumer → Methodology → StructuredReturns',
          node
        );
      }
      lastIndex = currentIndex;
    }
  }
}

/**
 * Convert IR node kind to component name for error messages
 */
function kindToComponentName(kind: ContractKind): string {
  switch (kind) {
    case 'role': return 'Role';
    case 'upstreamInput': return 'UpstreamInput';
    case 'downstreamConsumer': return 'DownstreamConsumer';
    case 'methodology': return 'Methodology';
    case 'structuredReturns': return 'StructuredReturns';
  }
}
```

Then in the `transformAgent` function, call validation before the return statement:

```typescript
// Before: return { kind: 'agentDocument', frontmatter, children: children as BaseBlockNode[] };

// Add validation
validateContractComponents(children as BaseBlockNode[], ctx, node);

return { kind: 'agentDocument', frontmatter, children: children as BaseBlockNode[] };
```
  </action>
  <verify>
```bash
cd /Users/glenninizan/workspace/react-agentic/react-agentic && npm run build 2>&1 | head -30
```
Build should succeed.
  </verify>
  <done>Contract component validation enforces ordering and uniqueness rules</done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

```bash
cd /Users/glenninizan/workspace/react-agentic/react-agentic

# Build succeeds
npm run build

# Run existing tests to ensure no regressions
npm test 2>&1 | tail -20
```

Expected:
- Build succeeds with no errors
- Existing tests pass
- Emitter handles all contract node types
- Validation prevents duplicate/misordered contract components
</verification>

<success_criteria>
- [ ] Emitter has emitContractComponent and emitStructuredReturns methods
- [ ] All 5 contract node kinds have cases in emitBlock switch
- [ ] validateContractComponents function exists in document.ts
- [ ] transformAgent calls validateContractComponents
- [ ] npm run build succeeds
- [ ] npm test passes (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/34-agent-contract-components/34-03-SUMMARY.md`
</output>
