---
phase: 14-agent-output-schema
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ir/nodes.ts
  - src/parser/transformer.ts
autonomous: true

must_haves:
  truths:
    - "AgentFrontmatterNode has optional outputType field"
    - "transformAgent extracts second type parameter as outputType"
    - "Single type parameter usage still works (TInput only)"
    - "TypeReference reused for outputType (same as inputType)"
  artifacts:
    - path: "src/ir/nodes.ts"
      provides: "outputType field on AgentFrontmatterNode"
      contains: "outputType?: TypeReference"
    - path: "src/parser/transformer.ts"
      provides: "Second type param extraction in transformAgent"
      contains: "typeArgs[1]"
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/ir/nodes.ts"
      via: "transformAgent creates AgentFrontmatterNode with outputType"
      pattern: "outputType && { outputType }"
---

<objective>
Extend IR and transformer to extract TOutput type parameter from Agent component.

Purpose: Enable the emitter to access the output type interface for generating `<structured_returns>`. The AgentFrontmatterNode gains an outputType field (TypeReference), and transformAgent is updated to extract the second generic type argument.

Output: Updated AgentFrontmatterNode interface, transformAgent extracts second type param.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-agent-output-schema/14-RESEARCH.md

@src/ir/nodes.ts
@src/parser/transformer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add outputType to AgentFrontmatterNode</name>
  <files>src/ir/nodes.ts</files>
  <action>
Extend the AgentFrontmatterNode interface to include outputType. Find the existing interface (around line 258) and add the new field:

```typescript
/**
 * Agent YAML frontmatter data
 * Uses GSD format: tools as space-separated string, not array like Command
 */
export interface AgentFrontmatterNode {
  kind: 'agentFrontmatter';
  name: string;              // Required: agent identifier (e.g., 'researcher')
  description: string;       // Required: agent purpose
  tools?: string;            // Optional: space-separated tool names (e.g., 'Read Grep Glob')
  color?: string;            // Optional: terminal color (e.g., 'cyan')
  inputType?: TypeReference; // Optional: generic type parameter if provided (e.g., 'ResearcherInput')
  outputType?: TypeReference; // Optional: second generic type parameter (e.g., 'ResearcherOutput')
}
```

Add the `outputType` field after `inputType` with a similar comment pattern.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Verify field exists: `grep "outputType" src/ir/nodes.ts`
  </verify>
  <done>AgentFrontmatterNode has outputType?: TypeReference field.</done>
</task>

<task type="auto">
  <name>Task 2: Extract outputType in transformAgent</name>
  <files>src/parser/transformer.ts</files>
  <action>
Modify the transformAgent method to extract the second type parameter. Find the section that extracts inputType (around line 264-272) and extend it:

Current code:
```typescript
// Extract generic type argument if present
const typeArgs = extractTypeArguments(node);
let inputType: TypeReference | undefined;
if (typeArgs && typeArgs.length > 0) {
  inputType = {
    kind: 'typeReference',
    name: typeArgs[0],
    resolved: false,  // Will be resolved in validation phase
  };
}
```

Change to:
```typescript
// Extract generic type arguments if present (TInput, TOutput)
const typeArgs = extractTypeArguments(node);
let inputType: TypeReference | undefined;
let outputType: TypeReference | undefined;

if (typeArgs && typeArgs.length > 0) {
  inputType = {
    kind: 'typeReference',
    name: typeArgs[0],
    resolved: false,  // Will be resolved in validation phase
  };
}
if (typeArgs && typeArgs.length > 1) {
  outputType = {
    kind: 'typeReference',
    name: typeArgs[1],
    resolved: false,  // Will be resolved in validation phase
  };
}
```

Then update the frontmatter construction (around line 275-282) to include outputType:

Current code:
```typescript
const frontmatter: AgentFrontmatterNode = {
  kind: 'agentFrontmatter',
  name,
  description,
  ...(tools && { tools }),
  ...(color && { color }),
  ...(inputType && { inputType }),
};
```

Change to:
```typescript
const frontmatter: AgentFrontmatterNode = {
  kind: 'agentFrontmatter',
  name,
  description,
  ...(tools && { tools }),
  ...(color && { color }),
  ...(inputType && { inputType }),
  ...(outputType && { outputType }),
};
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Verify extraction: `grep -A20 "Extract generic type arguments" src/parser/transformer.ts`
  </verify>
  <done>transformAgent extracts both type parameters. outputType populated when Agent has two generic args.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. IR field: `grep "outputType" src/ir/nodes.ts`
3. Transformer extracts: `grep "typeArgs\[1\]" src/parser/transformer.ts`
4. Frontmatter spreads outputType: `grep "outputType &&" src/parser/transformer.ts`
</verification>

<success_criteria>
- AgentFrontmatterNode.outputType is optional TypeReference
- transformAgent extracts typeArgs[1] as outputType when present
- Existing single-param `<Agent<TInput>>` continues to work (outputType undefined)
- Two-param `<Agent<TInput, TOutput>>` populates both inputType and outputType
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-agent-output-schema/14-02-SUMMARY.md`
</output>
