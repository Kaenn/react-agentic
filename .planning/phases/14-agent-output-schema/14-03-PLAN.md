---
phase: 14-agent-output-schema
plan: 03
type: execute
wave: 2
depends_on: [14-02]
files_modified:
  - src/emitter/emitter.ts
  - src/app/basic/test-output-schema.tsx
autonomous: true

must_haves:
  truths:
    - "Agent with TOutput emits structured_returns section"
    - "structured_returns contains status-specific templates"
    - "Output interface properties appear in generated templates"
    - "Agent without TOutput has no structured_returns section"
  artifacts:
    - path: "src/emitter/emitter.ts"
      provides: "emitStructuredReturns method"
      contains: "emitStructuredReturns"
    - path: "src/app/basic/test-output-schema.tsx"
      provides: "Test agent with TOutput generic"
      contains: "Agent<"
  key_links:
    - from: "src/emitter/emitter.ts"
      to: "parser.ts"
      via: "Uses resolveTypeImport and extractInterfaceProperties"
      pattern: "resolveTypeImport.*extractInterfaceProperties"
---

<objective>
Add emitter support for auto-generating `<structured_returns>` section from TOutput interface.

Purpose: When an Agent has a TOutput type parameter, the emitter should generate a `<structured_returns>` section documenting the expected output format. This section shows status-specific field templates based on the interface properties.

Output: emitStructuredReturns method in emitter.ts, test agent file demonstrating the feature.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-agent-output-schema/14-RESEARCH.md
@.planning/phases/14-agent-output-schema/14-02-SUMMARY.md

@src/emitter/emitter.ts
@src/parser/parser.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add emitStructuredReturns to emitter</name>
  <files>src/emitter/emitter.ts</files>
  <action>
The emitter needs to generate a `<structured_returns>` section when outputType is present. This requires access to the source file for type resolution, so we need to update the emitAgent method signature.

1. First, add imports at the top of emitter.ts:
```typescript
import { SourceFile } from 'ts-morph';
import { resolveTypeImport, extractInterfaceProperties } from '../parser/parser.js';
```

2. Update the emitAgent method to accept sourceFile and call emitStructuredReturns:
```typescript
/**
 * Emit an AgentDocumentNode to markdown
 * @param doc - The agent document node
 * @param sourceFile - Optional source file for type resolution (needed for structured_returns)
 */
emitAgent(doc: AgentDocumentNode, sourceFile?: SourceFile): string {
  const parts: string[] = [];

  // Agent frontmatter (GSD format)
  parts.push(this.emitAgentFrontmatter(doc.frontmatter));

  // Body content (same as Command)
  for (const child of doc.children) {
    parts.push(this.emitBlock(child));
  }

  // Auto-generate structured_returns if outputType present
  if (doc.frontmatter.outputType && sourceFile) {
    const structuredReturns = this.emitStructuredReturns(doc.frontmatter.outputType, sourceFile);
    if (structuredReturns) {
      parts.push(structuredReturns);
    }
  }

  // Join with double newlines for block separation, then ensure single trailing newline
  const result = parts.join('\n\n');
  return result ? result + '\n' : '';
}
```

3. Add the emitStructuredReturns method (add after emitElse method):
```typescript
/**
 * Generate <structured_returns> section from output type interface
 *
 * Resolves the TypeReference to its interface definition, extracts properties,
 * and generates status-specific templates based on field names.
 */
private emitStructuredReturns(outputType: TypeReference, sourceFile: SourceFile): string | null {
  // Resolve the interface
  const resolved = resolveTypeImport(outputType.name, sourceFile);
  if (!resolved?.interface) {
    return null;
  }

  // Extract properties
  const props = extractInterfaceProperties(resolved.interface);
  if (props.length === 0) {
    return null;
  }

  // Find status property (should always exist if extending BaseOutput)
  const statusProp = props.find(p => p.name === 'status');
  const otherProps = props.filter(p => p.name !== 'status' && p.name !== 'message');

  // Generate template showing all fields
  const lines: string[] = [
    '<structured_returns>',
    '',
    '## Output Format',
    '',
    'Return a YAML code block with the following structure:',
    '',
    '```yaml',
    'status: SUCCESS | BLOCKED | NOT_FOUND | ERROR | CHECKPOINT',
  ];

  // Add message if in interface
  const messageProp = props.find(p => p.name === 'message');
  if (messageProp) {
    lines.push('message: "Human-readable status message"');
  }

  // Add other fields
  for (const prop of otherProps) {
    const required = prop.required ? '' : '  # optional';
    const typeHint = this.formatTypeHint(prop.type);
    lines.push(`${prop.name}: ${typeHint}${required}`);
  }

  lines.push('```');

  // Add status-specific guidance
  lines.push('');
  lines.push('### Status Codes');
  lines.push('');
  lines.push('- **SUCCESS**: Task completed successfully');
  lines.push('- **BLOCKED**: Cannot proceed, needs external input');
  lines.push('- **NOT_FOUND**: Requested resource not found');
  lines.push('- **ERROR**: Execution error occurred');
  lines.push('- **CHECKPOINT**: Milestone reached, pausing for verification');

  lines.push('');
  lines.push('</structured_returns>');

  return lines.join('\n');
}

/**
 * Format a TypeScript type as a hint for YAML output
 */
private formatTypeHint(type: string): string {
  // Handle common types
  if (type === 'string') return '"..."';
  if (type === 'number') return '0';
  if (type === 'boolean') return 'true | false';
  if (type.includes('[]')) return '[...]';
  if (type.includes("'HIGH'") || type.includes("'MEDIUM'") || type.includes("'LOW'")) {
    return 'HIGH | MEDIUM | LOW';
  }
  // For complex types, show placeholder
  return `<${type.replace(/['"]/g, '')}>`;
}
```

4. Also need to import TypeReference in emitter.ts. Update the import from ir:
```typescript
import type {
  AgentDocumentNode,
  AgentFrontmatterNode,
  AssignNode,
  BlockNode,
  BlockquoteNode,
  CodeBlockNode,
  DocumentNode,
  ElseNode,
  FrontmatterNode,
  HeadingNode,
  IfNode,
  InlineNode,
  InputPropertyValue,
  ListItemNode,
  ListNode,
  ParagraphNode,
  SpawnAgentInput,
  SpawnAgentNode,
  TypeReference,
  XmlBlockNode,
} from '../ir/index.js';
```

5. Update the convenience function at the bottom:
```typescript
/**
 * Convenience function for emitting an agent document
 */
export function emitAgent(doc: AgentDocumentNode, sourceFile?: SourceFile): string {
  const emitter = new MarkdownEmitter();
  return emitter.emitAgent(doc, sourceFile);
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Verify method exists: `grep "emitStructuredReturns" src/emitter/emitter.ts`
  </verify>
  <done>emitStructuredReturns method generates structured_returns XML section from output interface. emitAgent calls it when outputType present.</done>
</task>

<task type="auto">
  <name>Task 2: Update CLI to pass sourceFile to emitAgent</name>
  <files>src/cli/build.ts</files>
  <action>
The CLI's build command needs to pass the sourceFile to emitAgent for type resolution. Find where emitAgent is called and update it.

Look for the section that handles agent documents (search for "emitAgent" in build.ts) and ensure sourceFile is passed:

```typescript
// When emitting agent document
if (ir.kind === 'agentDocument') {
  output = emitAgent(ir, sourceFile);  // Pass sourceFile for structured_returns
}
```

The sourceFile is already available in the build function context (it's used for transformation).
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Verify sourceFile passed: `grep "emitAgent.*sourceFile" src/cli/build.ts`
  </verify>
  <done>CLI passes sourceFile to emitAgent enabling type resolution for structured_returns.</done>
</task>

<task type="auto">
  <name>Task 3: Create test agent with output schema</name>
  <files>src/app/basic/test-output-schema.tsx</files>
  <action>
Create a test file demonstrating the TOutput feature:

```tsx
/**
 * Test file for Phase 14: Agent Output Schema
 *
 * Tests:
 * - Agent with TInput and TOutput type parameters
 * - Output interface extending BaseOutput
 * - Auto-generated structured_returns section
 */

import { Agent, BaseOutput } from '../../jsx.js';

// Input contract (same as before)
export interface AnalyzerInput {
  filePath: string;
  depth: 'shallow' | 'deep';
}

// Output contract extending BaseOutput
export interface AnalyzerOutput extends BaseOutput {
  // SUCCESS fields
  confidence?: 'HIGH' | 'MEDIUM' | 'LOW';
  findings?: string[];
  metrics?: {
    linesAnalyzed: number;
    issuesFound: number;
  };
  // BLOCKED fields
  blockedBy?: string;
  // NOT_FOUND fields
  searchedPaths?: string[];
}

export default function TestOutputSchema() {
  return (
    <Agent<AnalyzerInput, AnalyzerOutput>
      name="test-analyzer"
      description="Analyzes code for quality issues"
      tools="Read Grep Glob"
    >
      <h1>Role</h1>
      <p>You are a code analyzer that examines files for quality issues.</p>

      <h2>Process</h2>
      <ol>
        <li>Read the specified file</li>
        <li>Analyze based on depth setting</li>
        <li>Report findings with confidence level</li>
      </ol>
    </Agent>
  );
}
```

This agent has:
- TInput = AnalyzerInput (the input contract)
- TOutput = AnalyzerOutput (extends BaseOutput with status-specific fields)

When built, the output should include a `<structured_returns>` section.
  </action>
  <verify>
Build the test file: `node dist/cli/index.js build "src/app/basic/test-output-schema.tsx"`
Verify output contains structured_returns: `grep -A5 "structured_returns" .claude/agents/test-analyzer.md`
  </verify>
  <done>Test agent demonstrates TOutput feature. Built output includes auto-generated structured_returns section.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Build test: `npm run build && node dist/cli/index.js build "src/app/basic/test-output-schema.tsx"`
3. Output has structured_returns: `grep "structured_returns" .claude/agents/test-analyzer.md`
4. Output shows fields: `grep -E "(confidence|findings|metrics)" .claude/agents/test-analyzer.md`
5. Backward compat: Build existing agent without TOutput, verify no structured_returns section
</verification>

<success_criteria>
- emitStructuredReturns generates valid XML section from TOutput interface
- Generated section shows all interface properties with type hints
- Status codes documented in generated section
- Agent with TOutput has structured_returns in output markdown
- Agent without TOutput has no structured_returns (backward compatible)
- Test agent builds successfully with visible structured_returns section
</success_criteria>

<output>
After completion, create `.planning/phases/14-agent-output-schema/14-03-SUMMARY.md`
</output>
