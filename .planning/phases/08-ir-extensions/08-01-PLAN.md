---
phase: 08-ir-extensions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ir/nodes.ts
  - tests/ir/agent-nodes.test.ts
autonomous: true

must_haves:
  truths:
    - "AgentDocumentNode type can be instantiated with required frontmatter and children"
    - "AgentFrontmatterNode includes name, description (required) and tools, color (optional)"
    - "SpawnAgentNode captures agent, model, description, and prompt fields"
    - "TypeReference stores name and optional sourceFile and resolved fields"
    - "TypeScript compilation succeeds with all new types in IRNode union"
  artifacts:
    - path: "src/ir/nodes.ts"
      provides: "AgentDocumentNode, AgentFrontmatterNode, SpawnAgentNode, TypeReference interfaces"
      contains: "kind: 'agentDocument'"
    - path: "tests/ir/agent-nodes.test.ts"
      provides: "Type instantiation tests for all new IR nodes"
      min_lines: 50
  key_links:
    - from: "AgentDocumentNode"
      to: "AgentFrontmatterNode"
      via: "frontmatter property"
      pattern: "frontmatter: AgentFrontmatterNode"
    - from: "SpawnAgentNode"
      to: "BlockNode union"
      via: "union member"
      pattern: "SpawnAgentNode"
    - from: "new nodes"
      to: "IRNode union"
      via: "discriminated union"
      pattern: "AgentDocumentNode|AgentFrontmatterNode|TypeReference"
---

<objective>
Extend the IR layer with node types needed to represent Agent documents and SpawnAgent invocations.

Purpose: Foundation types that enable Phases 9-11 (Agent transpilation, SpawnAgent component, type safety)
Output: Four new IR node interfaces added to discriminated union with compile-time exhaustiveness checking
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-ir-extensions/08-RESEARCH.md
@src/ir/nodes.ts
@tests/emitter/document.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IR node interfaces for Agent framework</name>
  <files>src/ir/nodes.ts</files>
  <action>
Add four new node interfaces to src/ir/nodes.ts following the existing discriminated union pattern:

1. **AgentFrontmatterNode** (after FrontmatterNode, around line 175):
```typescript
/**
 * Agent YAML frontmatter data
 * Uses GSD format: tools as space-separated string, not array like Command
 */
export interface AgentFrontmatterNode {
  kind: 'agentFrontmatter';
  name: string;              // Required: agent identifier (e.g., 'researcher')
  description: string;       // Required: agent purpose
  tools?: string;            // Optional: space-separated tool names (e.g., 'Read Grep Glob')
  color?: string;            // Optional: terminal color (e.g., 'cyan')
}
```

2. **AgentDocumentNode** (after DocumentNode, around line 185):
```typescript
/**
 * Agent document root node
 * Similar to DocumentNode but with required AgentFrontmatterNode
 */
export interface AgentDocumentNode {
  kind: 'agentDocument';
  frontmatter: AgentFrontmatterNode;  // Required for agents (vs optional for Command)
  children: BlockNode[];
}
```

3. **SpawnAgentNode** (add to Block Nodes section, around line 163):
```typescript
/**
 * SpawnAgent invocation within a Command
 * Emits as Task() syntax in markdown
 */
export interface SpawnAgentNode {
  kind: 'spawnAgent';
  agent: string;           // Agent name/reference (e.g., 'gsd-researcher')
  model: string;           // Model to use (supports {variable} syntax)
  description: string;     // Human-readable task description
  prompt: string;          // Task prompt (supports {variable} and template literals)
}
```

4. **TypeReference** (add to Special Nodes section, around line 190):
```typescript
/**
 * Reference to a TypeScript type across files
 * Used for tracking Agent interface imports in SpawnAgent
 * Actual validation happens in Phase 11
 */
export interface TypeReference {
  kind: 'typeReference';
  name: string;            // Type/interface name (e.g., 'ResearcherInput')
  sourceFile?: string;     // Relative path to defining file
  resolved?: boolean;      // Whether type was successfully resolved
}
```

5. **Update BlockNode union** to include SpawnAgentNode:
```typescript
export type BlockNode =
  | HeadingNode
  | ParagraphNode
  | ListNode
  | CodeBlockNode
  | BlockquoteNode
  | ThematicBreakNode
  | XmlBlockNode
  | RawMarkdownNode
  | SpawnAgentNode;        // NEW: SpawnAgent is a block-level element
```

6. **Update IRNode union** to include all new types:
```typescript
export type IRNode =
  | BlockNode
  | InlineNode
  | FrontmatterNode
  | AgentFrontmatterNode    // NEW
  | ListItemNode
  | DocumentNode
  | AgentDocumentNode       // NEW
  | TypeReference;          // NEW
```

Note: assertNever already exists and will provide compile-time exhaustiveness checking. No changes needed to assertNever itself - TypeScript will error if switch statements don't handle new types.
  </action>
  <verify>Run `npm run typecheck` - should pass with no errors. Run `npm run build` to verify compilation succeeds.</verify>
  <done>All four interfaces defined with correct discriminator kinds, BlockNode includes SpawnAgentNode, IRNode union includes all new types.</done>
</task>

<task type="auto">
  <name>Task 2: Add IR node instantiation tests</name>
  <files>tests/ir/agent-nodes.test.ts</files>
  <action>
Create new test file `tests/ir/agent-nodes.test.ts` following the pattern in `tests/emitter/document.test.ts`:

```typescript
import { describe, expect, it } from 'vitest';
import type {
  AgentDocumentNode,
  AgentFrontmatterNode,
  SpawnAgentNode,
  TypeReference,
} from '../../src/index.js';

describe('AgentFrontmatterNode', () => {
  it('creates with required fields only', () => {
    const node: AgentFrontmatterNode = {
      kind: 'agentFrontmatter',
      name: 'researcher',
      description: 'Research topics using available tools',
    };
    expect(node.kind).toBe('agentFrontmatter');
    expect(node.name).toBe('researcher');
    expect(node.description).toBe('Research topics using available tools');
    expect(node.tools).toBeUndefined();
    expect(node.color).toBeUndefined();
  });

  it('creates with all optional fields', () => {
    const node: AgentFrontmatterNode = {
      kind: 'agentFrontmatter',
      name: 'full-agent',
      description: 'Full featured agent',
      tools: 'Read Grep Glob WebFetch',
      color: 'cyan',
    };
    expect(node.tools).toBe('Read Grep Glob WebFetch');
    expect(node.color).toBe('cyan');
  });
});

describe('AgentDocumentNode', () => {
  it('creates with frontmatter and empty children', () => {
    const frontmatter: AgentFrontmatterNode = {
      kind: 'agentFrontmatter',
      name: 'test-agent',
      description: 'A test agent',
    };
    const doc: AgentDocumentNode = {
      kind: 'agentDocument',
      frontmatter,
      children: [],
    };
    expect(doc.kind).toBe('agentDocument');
    expect(doc.frontmatter.name).toBe('test-agent');
    expect(doc.children).toHaveLength(0);
  });

  it('creates with frontmatter and block children', () => {
    const frontmatter: AgentFrontmatterNode = {
      kind: 'agentFrontmatter',
      name: 'doc-agent',
      description: 'Agent with content',
    };
    const doc: AgentDocumentNode = {
      kind: 'agentDocument',
      frontmatter,
      children: [
        { kind: 'heading', level: 1, children: [{ kind: 'text', value: 'Role' }] },
        { kind: 'paragraph', children: [{ kind: 'text', value: 'You are a researcher.' }] },
      ],
    };
    expect(doc.children).toHaveLength(2);
    expect(doc.children[0].kind).toBe('heading');
  });
});

describe('SpawnAgentNode', () => {
  it('creates with all required fields', () => {
    const node: SpawnAgentNode = {
      kind: 'spawnAgent',
      agent: 'gsd-researcher',
      model: '{researcher_model}',
      description: 'Research the topic thoroughly',
      prompt: 'Research {topic} and summarize findings',
    };
    expect(node.kind).toBe('spawnAgent');
    expect(node.agent).toBe('gsd-researcher');
    expect(node.model).toBe('{researcher_model}');
    expect(node.description).toBe('Research the topic thoroughly');
    expect(node.prompt).toBe('Research {topic} and summarize findings');
  });

  it('preserves variable placeholders in prompt', () => {
    const node: SpawnAgentNode = {
      kind: 'spawnAgent',
      agent: 'analyzer',
      model: 'sonnet',
      description: 'Analyze code',
      prompt: `<context>
Analyze {file_path} for:
- {analysis_type}
- Performance issues
</context>`,
    };
    expect(node.prompt).toContain('{file_path}');
    expect(node.prompt).toContain('{analysis_type}');
  });
});

describe('TypeReference', () => {
  it('creates with name only', () => {
    const ref: TypeReference = {
      kind: 'typeReference',
      name: 'ResearcherInput',
    };
    expect(ref.kind).toBe('typeReference');
    expect(ref.name).toBe('ResearcherInput');
    expect(ref.sourceFile).toBeUndefined();
    expect(ref.resolved).toBeUndefined();
  });

  it('creates with source file reference', () => {
    const ref: TypeReference = {
      kind: 'typeReference',
      name: 'ResearcherInput',
      sourceFile: './agents/researcher.tsx',
      resolved: false,
    };
    expect(ref.sourceFile).toBe('./agents/researcher.tsx');
    expect(ref.resolved).toBe(false);
  });

  it('tracks resolution status', () => {
    const resolved: TypeReference = {
      kind: 'typeReference',
      name: 'AnalyzerOutput',
      sourceFile: './agents/analyzer.tsx',
      resolved: true,
    };
    expect(resolved.resolved).toBe(true);
  });
});

describe('IR union type checking', () => {
  it('SpawnAgentNode is assignable to BlockNode', () => {
    // TypeScript compile-time check - if this compiles, the union is correct
    const block: import('../../src/index.js').BlockNode = {
      kind: 'spawnAgent',
      agent: 'test',
      model: 'sonnet',
      description: 'Test',
      prompt: 'Test prompt',
    };
    expect(block.kind).toBe('spawnAgent');
  });
});
```

Ensure the tests directory structure exists: create `tests/ir/` directory if it doesn't exist.
  </action>
  <verify>Run `npm test` - all new tests should pass. Run `npm run typecheck` to verify type assignments are valid.</verify>
  <done>Test file exists with tests for all four new node types, all tests pass, type assignments compile correctly.</done>
</task>

</tasks>

<verification>
Phase verification checklist:
1. `npm run typecheck` passes - no TypeScript errors
2. `npm run build` succeeds - transpilation works
3. `npm test` passes - all tests including new IR node tests
4. New types are exported from `src/index.ts` via the `src/ir/index.ts` re-export
5. Discriminated union pattern preserved - each node has unique `kind` literal
</verification>

<success_criteria>
- AgentDocumentNode compiles and can be instantiated with frontmatter and children
- AgentFrontmatterNode has typed fields: name (string), description (string), tools (string?), color (string?)
- SpawnAgentNode has all four required fields: agent, model, description, prompt
- TypeReference stores name, sourceFile, and resolved status
- SpawnAgentNode is part of BlockNode union
- All new types are part of IRNode union
- Existing tests still pass (no regressions)
- New tests verify type instantiation works correctly
</success_criteria>

<output>
After completion, create `.planning/phases/08-ir-extensions/08-01-SUMMARY.md`
</output>
