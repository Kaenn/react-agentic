---
phase: 22-semantic-components
plan: 04
type: execute
wave: 4
depends_on: ["22-03"]
files_modified:
  - src/emitter/emitter.ts
autonomous: true

must_haves:
  truths:
    - "Semantic components compile successfully to correct markdown output"
    - "Test command with ExecutionContext emits <execution_context> with @ paths"
    - "Test command with SuccessCriteria emits <success_criteria> with checkbox items"
    - "Test command with OfferNext emits <offer_next> with route bullets"
  artifacts:
    - path: "src/emitter/emitter.ts"
      provides: "Emit semantic IR nodes to markdown"
      contains: "executionContext"
  key_links:
    - from: "src/emitter/emitter.ts"
      to: "markdown output"
      via: "emitBlock switch"
      pattern: "case 'executionContext'"
---

<objective>
Implement emitter logic for semantic IR nodes and verify end-to-end compilation.

Purpose: Wire the second half of the build pipeline (IR nodes -> markdown) for semantic components.
Output: Working end-to-end compilation of all semantic components.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-semantic-components/22-CONTEXT.md
@.planning/phases/22-semantic-components/22-RESEARCH.md
@.planning/phases/22-semantic-components/22-03-SUMMARY.md

@src/emitter/emitter.ts
@src/ir/nodes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add emitter cases for semantic IR nodes</name>
  <files>src/emitter/emitter.ts</files>
  <action>
**1. Add import for new IR types:**
```typescript
import type {
  // ... existing
  ExecutionContextNode,
  SuccessCriteriaNode,
  OfferNextNode,
} from '../ir/index.js';
```

**2. Add switch cases in emitBlock method:**

```typescript
case 'executionContext':
  return this.emitExecutionContext(node);
case 'successCriteria':
  return this.emitSuccessCriteria(node);
case 'offerNext':
  return this.emitOfferNext(node);
```

**3. Implement emitter methods:**

```typescript
/**
 * Emit ExecutionContext as XML with @-prefixed paths
 *
 * Output:
 * <execution_context>
 * @path/to/file1.md
 * @path/to/file2.md
 * </execution_context>
 */
private emitExecutionContext(node: ExecutionContextNode): string {
  const lines: string[] = ['<execution_context>'];

  // Add paths with prefix
  for (const path of node.paths) {
    lines.push(`${node.prefix}${path}`);
  }

  // Add children if present
  if (node.children.length > 0) {
    lines.push('');
    for (const child of node.children) {
      lines.push(this.emitBlock(child));
    }
  }

  lines.push('</execution_context>');
  return lines.join('\n');
}

/**
 * Emit SuccessCriteria as XML with checkbox list
 *
 * Output:
 * <success_criteria>
 * - [ ] First criterion
 * - [x] Pre-checked item
 * </success_criteria>
 */
private emitSuccessCriteria(node: SuccessCriteriaNode): string {
  const lines: string[] = ['<success_criteria>'];

  for (const item of node.items) {
    const checkbox = item.checked ? '[x]' : '[ ]';
    lines.push(`- ${checkbox} ${item.text}`);
  }

  lines.push('</success_criteria>');
  return lines.join('\n');
}

/**
 * Emit OfferNext as XML with route bullet list
 *
 * Output:
 * <offer_next>
 * - **Route Name**: Description
 *   `/path/to/command`
 * </offer_next>
 */
private emitOfferNext(node: OfferNextNode): string {
  const lines: string[] = ['<offer_next>'];

  for (const route of node.routes) {
    if (route.description) {
      lines.push(`- **${route.name}**: ${route.description}`);
    } else {
      lines.push(`- **${route.name}**`);
    }
    lines.push(`  \`${route.path}\``);
  }

  lines.push('</offer_next>');
  return lines.join('\n');
}
```

Note: XmlSection and wrapper components (DeviationRules, etc.) use existing `emitXmlBlock` - no new emitter code needed for them.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Emitter produces correct markdown for all semantic IR nodes</done>
</task>

<task type="auto">
  <name>Task 2: Verify build and test end-to-end</name>
  <files>-</files>
  <action>
**1. Run full build:**
```bash
npm run build
```

**2. Create a test file to verify compilation:**
Create a temporary test at `src/app/test-semantic.tsx`:
```tsx
import { Command, ExecutionContext, SuccessCriteria, OfferNext, XmlSection, DeviationRules } from '../jsx.js';

export default (
  <Command name="test-semantic" description="Test semantic components">
    <ExecutionContext paths={["file1.md", "file2.md"]} />

    <SuccessCriteria items={[
      "First criterion",
      { text: "Pre-checked", checked: true },
      "Third criterion"
    ]} />

    <OfferNext routes={[
      { name: "Execute", description: "Run it", path: "/gsd:execute" },
      { name: "Skip", path: "/skip" }
    ]} />

    <XmlSection name="custom_section">
      <p>Custom content</p>
    </XmlSection>

    <DeviationRules>
      <p>Deviation handling rules</p>
    </DeviationRules>
  </Command>
);
```

**3. Run CLI build on test file:**
```bash
node dist/cli/index.js build src/app/test-semantic.tsx --dry-run
```

**4. Verify output contains:**
- `<execution_context>` with @file1.md, @file2.md
- `<success_criteria>` with checkbox items
- `<offer_next>` with route bullets
- `<custom_section>` from XmlSection
- `<deviation_rules>` from DeviationRules

**5. Clean up test file:**
```bash
rm src/app/test-semantic.tsx
```
  </action>
  <verify>Full build passes and test file compiles to expected markdown</verify>
  <done>All semantic components transform and emit correctly through the full pipeline</done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. Test file produces correct markdown output:
   - execution_context with @-prefixed paths
   - success_criteria with - [ ] checkboxes
   - offer_next with route bullets
   - Custom XML sections with snake_case names
3. No TypeScript errors
</verification>

<success_criteria>
- ExecutionContext emits `<execution_context>` with @ paths
- SuccessCriteria emits `<success_criteria>` with checkbox list
- OfferNext emits `<offer_next>` with bullet list routes
- XmlSection emits custom `<{name}>` tags
- Wrapper components emit snake_case XML tags (deviation_rules, etc.)
- All components work inside Command and Agent bodies
</success_criteria>

<output>
After completion, create `.planning/phases/22-semantic-components/22-04-SUMMARY.md`
</output>
