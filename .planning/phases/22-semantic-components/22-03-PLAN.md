---
phase: 22-semantic-components
plan: 03
type: execute
wave: 3
depends_on: ["22-02"]
files_modified:
  - src/parser/transformer.ts
  - src/emitter/emitter.ts
autonomous: true

must_haves:
  truths:
    - "ExecutionContext emits <execution_context> with @-prefixed paths one per line"
    - "SuccessCriteria emits <success_criteria> with - [ ] or - [x] checkbox items"
    - "OfferNext emits <offer_next> with bullet list routes"
    - "XmlSection emits custom <{name}> tags with children"
    - "DeviationRules/CommitRules/WaveExecution/CheckpointHandling emit snake_case XML tags"
  artifacts:
    - path: "src/parser/transformer.ts"
      provides: "Transform semantic components to IR nodes"
      contains: "ExecutionContext"
    - path: "src/emitter/emitter.ts"
      provides: "Emit semantic IR nodes to markdown"
      contains: "executionContext"
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/ir/nodes.ts"
      via: "creates IR nodes"
      pattern: "kind: 'executionContext'"
    - from: "src/emitter/emitter.ts"
      to: "markdown output"
      via: "emitBlock switch"
      pattern: "case 'executionContext'"
---

<objective>
Implement transformer and emitter logic for all semantic components to produce correct markdown output.

Purpose: Wire the component stubs through the build pipeline so they transform to IR nodes and emit to markdown.
Output: Working end-to-end compilation of all semantic components.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-semantic-components/22-CONTEXT.md
@.planning/phases/22-semantic-components/22-RESEARCH.md
@.planning/phases/22-semantic-components/22-01-SUMMARY.md
@.planning/phases/22-semantic-components/22-02-SUMMARY.md

@src/parser/transformer.ts
@src/emitter/emitter.ts
@src/ir/nodes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add transformer cases for semantic components</name>
  <files>src/parser/transformer.ts</files>
  <action>
**1. Add semantic components to SPECIAL_COMPONENTS set:**
```typescript
const SPECIAL_COMPONENTS = new Set([
  // ... existing
  'ExecutionContext', 'SuccessCriteria', 'OfferNext', 'XmlSection',
  'DeviationRules', 'CommitRules', 'WaveExecution', 'CheckpointHandling'
]);
```

**2. Add import for new IR types at top of file:**
```typescript
import type {
  // ... existing imports
  ExecutionContextNode,
  SuccessCriteriaNode,
  SuccessCriteriaItemData,
  OfferNextNode,
  OfferNextRouteData,
} from '../ir/index.js';
```

**3. Add transformer cases in transformToBlock method:**

For **ExecutionContext**:
- Extract `paths` array prop using `getArrayAttributeValue`
- Extract optional `prefix` prop (default: '@')
- Transform any children
- Return `ExecutionContextNode`

For **SuccessCriteria**:
- Extract `items` array prop
- Parse each item: if string, create `{text: item, checked: false}`; if object with `text` and `checked`, use as-is
- Return `SuccessCriteriaNode`

For **OfferNext**:
- Extract `routes` array prop (objects with name, description?, path)
- Return `OfferNextNode`

For **XmlSection**:
- Extract `name` prop
- Transform children
- Return existing `XmlBlockNode` with provided name

For **DeviationRules, CommitRules, WaveExecution, CheckpointHandling**:
- Transform children
- Return `XmlBlockNode` with snake_case name (deviation_rules, commit_rules, wave_execution, checkpoint_handling)

Helper for PascalCase to snake_case:
```typescript
function toSnakeCase(name: string): string {
  return name.replace(/([A-Z])/g, '_$1').toLowerCase().replace(/^_/, '');
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Transformer recognizes all semantic components and creates correct IR nodes</done>
</task>

<task type="auto">
  <name>Task 2: Add emitter cases for semantic IR nodes</name>
  <files>src/emitter/emitter.ts</files>
  <action>
**1. Add import for new IR types:**
```typescript
import type {
  // ... existing
  ExecutionContextNode,
  SuccessCriteriaNode,
  OfferNextNode,
} from '../ir/index.js';
```

**2. Add switch cases in emitBlock method:**

```typescript
case 'executionContext':
  return this.emitExecutionContext(node);
case 'successCriteria':
  return this.emitSuccessCriteria(node);
case 'offerNext':
  return this.emitOfferNext(node);
```

**3. Implement emitter methods:**

```typescript
/**
 * Emit ExecutionContext as XML with @-prefixed paths
 *
 * Output:
 * <execution_context>
 * @path/to/file1.md
 * @path/to/file2.md
 * </execution_context>
 */
private emitExecutionContext(node: ExecutionContextNode): string {
  const lines: string[] = ['<execution_context>'];

  // Add paths with prefix
  for (const path of node.paths) {
    lines.push(`${node.prefix}${path}`);
  }

  // Add children if present
  if (node.children.length > 0) {
    lines.push('');
    for (const child of node.children) {
      lines.push(this.emitBlock(child));
    }
  }

  lines.push('</execution_context>');
  return lines.join('\n');
}

/**
 * Emit SuccessCriteria as XML with checkbox list
 *
 * Output:
 * <success_criteria>
 * - [ ] First criterion
 * - [x] Pre-checked item
 * </success_criteria>
 */
private emitSuccessCriteria(node: SuccessCriteriaNode): string {
  const lines: string[] = ['<success_criteria>'];

  for (const item of node.items) {
    const checkbox = item.checked ? '[x]' : '[ ]';
    lines.push(`- ${checkbox} ${item.text}`);
  }

  lines.push('</success_criteria>');
  return lines.join('\n');
}

/**
 * Emit OfferNext as XML with route bullet list
 *
 * Output:
 * <offer_next>
 * - **Route Name**: Description
 *   `/path/to/command`
 * </offer_next>
 */
private emitOfferNext(node: OfferNextNode): string {
  const lines: string[] = ['<offer_next>'];

  for (const route of node.routes) {
    if (route.description) {
      lines.push(`- **${route.name}**: ${route.description}`);
    } else {
      lines.push(`- **${route.name}**`);
    }
    lines.push(`  \`${route.path}\``);
  }

  lines.push('</offer_next>');
  return lines.join('\n');
}
```

Note: XmlSection and wrapper components (DeviationRules, etc.) use existing `emitXmlBlock` - no new emitter code needed for them.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Emitter produces correct markdown for all semantic IR nodes</done>
</task>

<task type="auto">
  <name>Task 3: Verify build and test end-to-end</name>
  <files>-</files>
  <action>
**1. Run full build:**
```bash
npm run build
```

**2. Create a test file to verify compilation:**
Create a temporary test at `src/app/test-semantic.tsx`:
```tsx
import { Command, ExecutionContext, SuccessCriteria, OfferNext, XmlSection, DeviationRules } from '../jsx.js';

export default (
  <Command name="test-semantic" description="Test semantic components">
    <ExecutionContext paths={["file1.md", "file2.md"]} />

    <SuccessCriteria items={[
      "First criterion",
      { text: "Pre-checked", checked: true },
      "Third criterion"
    ]} />

    <OfferNext routes={[
      { name: "Execute", description: "Run it", path: "/gsd:execute" },
      { name: "Skip", path: "/skip" }
    ]} />

    <XmlSection name="custom_section">
      <p>Custom content</p>
    </XmlSection>

    <DeviationRules>
      <p>Deviation handling rules</p>
    </DeviationRules>
  </Command>
);
```

**3. Run CLI build on test file:**
```bash
node dist/cli/index.js build src/app/test-semantic.tsx --dry-run
```

**4. Verify output contains:**
- `<execution_context>` with @file1.md, @file2.md
- `<success_criteria>` with checkbox items
- `<offer_next>` with route bullets
- `<custom_section>` from XmlSection
- `<deviation_rules>` from DeviationRules

**5. Clean up test file:**
```bash
rm src/app/test-semantic.tsx
```
  </action>
  <verify>Full build passes and test file compiles to expected markdown</verify>
  <done>All semantic components transform and emit correctly through the full pipeline</done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. Test file produces correct markdown output:
   - execution_context with @-prefixed paths
   - success_criteria with - [ ] checkboxes
   - offer_next with route bullets
   - Custom XML sections with snake_case names
3. No TypeScript errors
</verification>

<success_criteria>
- ExecutionContext emits `<execution_context>` with @ paths
- SuccessCriteria emits `<success_criteria>` with checkbox list
- OfferNext emits `<offer_next>` with bullet list routes
- XmlSection emits custom `<{name}>` tags
- Wrapper components emit snake_case XML tags (deviation_rules, etc.)
- All components work inside Command and Agent bodies
</success_criteria>

<output>
After completion, create `.planning/phases/22-semantic-components/22-03-SUMMARY.md`
</output>
