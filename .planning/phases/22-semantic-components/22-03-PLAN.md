---
phase: 22-semantic-components
plan: 03
type: execute
wave: 3
depends_on: ["22-02"]
files_modified:
  - src/parser/transformer.ts
autonomous: true

must_haves:
  truths:
    - "Semantic components compile successfully via npm run build"
    - "Test command using semantic components produces valid markdown"
    - "All 8 semantic components are recognized by the transformer"
  artifacts:
    - path: "src/parser/transformer.ts"
      provides: "Transform semantic components to IR nodes"
      contains: "ExecutionContext"
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/ir/nodes.ts"
      via: "creates IR nodes"
      pattern: "kind: 'executionContext'"
    - from: "src/parser/transformer.ts"
      to: "src/workflow/sections/semantic.ts"
      via: "component recognition"
      pattern: "SPECIAL_COMPONENTS.*ExecutionContext"
---

<objective>
Implement transformer logic for all semantic components to convert JSX elements to IR nodes.

Purpose: Wire the component stubs through the first half of the build pipeline (JSX -> IR nodes).
Output: Transformer recognizes all semantic components and produces correct IR nodes.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-semantic-components/22-CONTEXT.md
@.planning/phases/22-semantic-components/22-RESEARCH.md
@.planning/phases/22-semantic-components/22-01-SUMMARY.md
@.planning/phases/22-semantic-components/22-02-SUMMARY.md

@src/parser/transformer.ts
@src/ir/nodes.ts
@src/workflow/sections/semantic.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify stub exports before transformer work</name>
  <files>-</files>
  <action>
Before adding transformer logic, verify all expected exports exist in semantic.ts:

**1. Read semantic.ts and verify exports:**
```bash
grep -E "^export (function|interface)" src/workflow/sections/semantic.ts
```

**Expected exports (from Plan 01 and 02):**
- `export interface ExecutionContextProps`
- `export interface SuccessCriteriaItem`
- `export interface SuccessCriteriaProps`
- `export interface XmlSectionProps`
- `export interface OfferNextRoute`
- `export interface OfferNextProps`
- `export interface XmlWrapperProps`
- `export function ExecutionContext`
- `export function SuccessCriteria`
- `export function XmlSection`
- `export function OfferNext`
- `export function DeviationRules`
- `export function CommitRules`
- `export function WaveExecution`
- `export function CheckpointHandling`

**2. Verify IR nodes exist:**
```bash
grep -E "kind: '(executionContext|successCriteria|offerNext)'" src/ir/nodes.ts
```

If any exports are missing, STOP and report - Plan 01/02 must be executed first.
  </action>
  <verify>All 8 component exports and 3 IR node types found</verify>
  <done>Stubs verified, ready for transformer implementation</done>
</task>

<task type="auto">
  <name>Task 2: Add transformer cases for semantic components</name>
  <files>src/parser/transformer.ts</files>
  <action>
**1. Add toSnakeCase helper as module-level utility function at top of transformer.ts after imports:**
```typescript
/**
 * Convert PascalCase component name to snake_case XML tag name
 * Example: DeviationRules -> deviation_rules
 */
function toSnakeCase(name: string): string {
  return name.replace(/([A-Z])/g, '_$1').toLowerCase().replace(/^_/, '');
}
```

**2. Add semantic components to SPECIAL_COMPONENTS set:**
```typescript
const SPECIAL_COMPONENTS = new Set([
  // ... existing
  'ExecutionContext', 'SuccessCriteria', 'OfferNext', 'XmlSection',
  'DeviationRules', 'CommitRules', 'WaveExecution', 'CheckpointHandling'
]);
```

**3. Add import for new IR types at top of file:**
```typescript
import type {
  // ... existing imports
  ExecutionContextNode,
  SuccessCriteriaNode,
  SuccessCriteriaItemData,
  OfferNextNode,
  OfferNextRouteData,
} from '../ir/index.js';
```

**4. Add transformer cases in transformToBlock method:**

For **ExecutionContext**:
- Extract `paths` array prop using `getArrayAttributeValue`
- Extract optional `prefix` prop (default: '@')
- Transform any children
- Return `ExecutionContextNode`

For **SuccessCriteria**:
- Extract `items` array prop
- Parse each item: if string, create `{text: item, checked: false}`; if object with `text` and `checked`, use as-is
- Return `SuccessCriteriaNode`

For **OfferNext**:
- Extract `routes` array prop (objects with name, description?, path)
- Return `OfferNextNode`

For **XmlSection**:
- Extract `name` prop
- Transform children
- Return existing `XmlBlockNode` with provided name

For **DeviationRules, CommitRules, WaveExecution, CheckpointHandling**:
- Transform children
- Return `XmlBlockNode` with snake_case name using `toSnakeCase()` helper (deviation_rules, commit_rules, wave_execution, checkpoint_handling)
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Transformer recognizes all semantic components and creates correct IR nodes</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run build` passes
3. toSnakeCase function exists at module level in transformer.ts
</verification>

<success_criteria>
- All 8 semantic components recognized by transformer
- ExecutionContext, SuccessCriteria, OfferNext create their specific IR nodes
- XmlSection and wrapper components create XmlBlockNode with correct snake_case names
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/22-semantic-components/22-03-SUMMARY.md`
</output>
