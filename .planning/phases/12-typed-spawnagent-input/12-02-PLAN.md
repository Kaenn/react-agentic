---
phase: 12-typed-spawnagent-input
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/parser/transformer.ts
  - src/parser/parser.ts
autonomous: true

must_haves:
  truths:
    - "SpawnAgent with input={varRef} parses to SpawnAgentInput.type='variable'"
    - "SpawnAgent with input={{...}} parses to SpawnAgentInput.type='object'"
    - "SpawnAgent children text becomes extraInstructions string"
    - "Error thrown if both prompt and input provided"
    - "Existing prompt-based SpawnAgent still works"
  artifacts:
    - path: "src/parser/transformer.ts"
      provides: "Extended transformSpawnAgent handling input prop"
      contains: "extractInputProp"
    - path: "src/parser/parser.ts"
      provides: "Utility to detect VariableRef identifier"
      contains: "extractInputObjectLiteral"
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/ir/nodes.ts"
      via: "SpawnAgentInput type construction"
      pattern: "type: 'variable'|type: 'object'"
---

<objective>
Parse SpawnAgent input prop and children in transformer.

Purpose: Enable SpawnAgent to accept typed input (VariableRef or object literal) and children as extra instructions.

Output:
- Transformer parses `input` prop and creates SpawnAgentInput IR node
- Transformer extracts children text as extraInstructions
- Validation: error if both `prompt` and `input` provided
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-typed-spawnagent-input/12-RESEARCH.md
@.planning/phases/12-typed-spawnagent-input/12-01-SUMMARY.md

@src/parser/transformer.ts
@src/parser/parser.ts
@src/ir/nodes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add input prop parsing utilities</name>
  <files>src/parser/parser.ts</files>
  <action>
Add utilities to extract input prop value:

1. Add function to extract object literal for SpawnAgent input:
```typescript
/**
 * Extract SpawnAgent input object literal properties
 * Handles: { propName: "value" }, { propName: {placeholder} }, { propName: varRef }
 *
 * Returns InputProperty[] with proper InputPropertyValue types
 */
export function extractInputObjectLiteral(
  objLiteral: ObjectLiteralExpression,
  variables: Map<string, ExtractedVariable>
): InputProperty[] {
  // For each property:
  // - String literal: { type: 'string', value: str }
  // - Template with {var}: detect {placeholder} pattern -> { type: 'placeholder', name: var }
  // - Identifier referencing variable: { type: 'variable', name: envName }
  // - Other string: { type: 'string', value: str }
}
```

2. Add function to detect if identifier is a VariableRef:
```typescript
/**
 * Check if an identifier references a useVariable result
 */
export function isVariableRef(
  identifier: Identifier,
  variables: Map<string, ExtractedVariable>
): boolean {
  return variables.has(identifier.getText());
}
```

Import InputProperty, InputPropertyValue from nodes.ts (or define inline - they're simple types).
  </action>
  <verify>Run `npm run build` - compiles without errors</verify>
  <done>extractInputObjectLiteral and isVariableRef functions exist in parser.ts</done>
</task>

<task type="auto">
  <name>Task 2: Extend transformSpawnAgent for input prop</name>
  <files>src/parser/transformer.ts</files>
  <action>
Update transformSpawnAgent method:

1. Add extractInputProp method (similar to extractPromptProp):
```typescript
/**
 * Extract input prop - handles VariableRef identifier or object literal
 */
private extractInputProp(
  element: JsxOpeningElement | JsxSelfClosingElement
): SpawnAgentInput | undefined {
  const attr = element.getAttribute('input');
  if (!attr || !Node.isJsxAttribute(attr)) return undefined;

  const init = attr.getInitializer();
  if (!init || !Node.isJsxExpression(init)) return undefined;

  const expr = init.getExpression();
  if (!expr) return undefined;

  // Case 1: Identifier referencing useVariable result
  if (Node.isIdentifier(expr)) {
    const variable = this.variables.get(expr.getText());
    if (variable) {
      return { type: 'variable', variableName: variable.envName };
    }
    // Not a known variable - error
    throw this.createError(`Input '${expr.getText()}' not found. Use useVariable() or object literal.`, element);
  }

  // Case 2: Object literal
  if (Node.isObjectLiteralExpression(expr)) {
    const properties = extractInputObjectLiteral(expr, this.variables);
    return { type: 'object', properties };
  }

  throw this.createError('Input must be a VariableRef or object literal', element);
}
```

2. Add extractExtraInstructions method for children:
```typescript
/**
 * Extract extra instructions from SpawnAgent children
 * Treats children as raw text content (like Markdown component)
 */
private extractExtraInstructions(node: JsxElement): string | undefined {
  // Similar to transformMarkdown - extract text content from children
  // Return undefined if no children or only whitespace
}
```

3. Update transformSpawnAgent:
- Call extractInputProp() to get input
- Call extractExtraInstructions() if JsxElement (not self-closing)
- Validation: if both prompt AND input provided, throw error
- If input provided but no prompt, that's valid (prompt generated in emitter)
- If neither prompt nor input, throw error
- Include input and extraInstructions in returned SpawnAgentNode
  </action>
  <verify>Run `npm run build` - compiles without errors</verify>
  <done>transformSpawnAgent handles input prop, extraInstructions, and validates mutual exclusivity</done>
</task>

<task type="auto">
  <name>Task 3: Add transformer tests for input prop</name>
  <files>tests/parser/spawnagent-transformer.test.ts</files>
  <action>
Add test cases for input prop parsing:

1. Test VariableRef input:
```typescript
describe('input prop parsing', () => {
  it('transforms input with VariableRef', () => {
    const tsx = `
      const ctx = useVariable("CTX", { bash: \`echo hi\` });
      export default function Test() {
        return (
          <Command name="test" description="Test">
            <SpawnAgent input={ctx} agent="a" model="m" description="d" />
          </Command>
        );
      }`;
    const doc = transformTsx(tsx);
    const spawn = doc.children[0] as SpawnAgentNode;
    expect(spawn.input).toEqual({ type: 'variable', variableName: 'CTX' });
    expect(spawn.prompt).toBeUndefined();
  });
});
```

2. Test object literal input:
```typescript
it('transforms input with object literal', () => {
  const tsx = `export default function Test() {
    return (
      <Command name="test" description="Test">
        <SpawnAgent
          input={{ phase: "5", goal: "{goal_var}" }}
          agent="a" model="m" description="d"
        />
      </Command>
    );
  }`;
  const doc = transformTsx(tsx);
  const spawn = doc.children[0] as SpawnAgentNode;
  expect(spawn.input?.type).toBe('object');
  expect(spawn.input?.properties).toContainEqual({
    name: 'phase',
    value: { type: 'string', value: '5' }
  });
});
```

3. Test children as extraInstructions:
```typescript
it('extracts children as extraInstructions', () => {
  const tsx = `export default function Test() {
    return (
      <Command name="test" description="Test">
        <SpawnAgent input={{ phase: "5" }} agent="a" model="m" description="d">
          Additional context here.
        </SpawnAgent>
      </Command>
    );
  }`;
  const doc = transformTsx(tsx);
  const spawn = doc.children[0] as SpawnAgentNode;
  expect(spawn.extraInstructions).toContain('Additional context');
});
```

4. Test mutual exclusivity:
```typescript
it('throws if both prompt and input provided', () => {
  const tsx = `export default function Test() {
    return (
      <Command name="test" description="Test">
        <SpawnAgent
          prompt="old style"
          input={{ phase: "5" }}
          agent="a" model="m" description="d"
        />
      </Command>
    );
  }`;
  expect(() => transformTsx(tsx)).toThrow(/Cannot use both prompt and input/);
});
```

5. Test backward compatibility (prompt still works):
```typescript
it('still supports prompt prop (backward compat)', () => {
  const tsx = `export default function Test() {
    return (
      <Command name="test" description="Test">
        <SpawnAgent prompt="Do task" agent="a" model="m" description="d" />
      </Command>
    );
  }`;
  const doc = transformTsx(tsx);
  const spawn = doc.children[0] as SpawnAgentNode;
  expect(spawn.prompt).toBe('Do task');
  expect(spawn.input).toBeUndefined();
});
```
  </action>
  <verify>Run `npm test` - all tests pass including new input prop tests</verify>
  <done>Tests cover VariableRef input, object literal input, extraInstructions, mutual exclusivity, backward compat</done>
</task>

</tasks>

<verification>
- `npm run build` compiles without errors
- `npm test` passes all tests
- New tests verify input prop parsing
- Existing SpawnAgent tests still pass (backward compatibility)
</verification>

<success_criteria>
- SpawnAgent with `input={varRef}` creates SpawnAgentInput.type='variable'
- SpawnAgent with `input={{ key: value }}` creates SpawnAgentInput.type='object'
- SpawnAgent children text extracted as extraInstructions
- Error thrown when both prompt and input provided
- Existing prompt-based SpawnAgent unchanged (backward compat)
- {placeholder} patterns in object values preserved as placeholder type
</success_criteria>

<output>
After completion, create `.planning/phases/12-typed-spawnagent-input/12-02-SUMMARY.md`
</output>
