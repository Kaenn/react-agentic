---
phase: 12-typed-spawnagent-input
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/parser/transformer.ts
  - src/parser/parser.ts
autonomous: true

must_haves:
  truths:
    - "SpawnAgent with input={varRef} parses to SpawnAgentInput.type='variable'"
    - "SpawnAgent with input={{...}} parses to SpawnAgentInput.type='object'"
    - "SpawnAgent children text becomes extraInstructions string"
    - "Error thrown if both prompt and input provided"
    - "Error thrown if input object missing required interface properties"
    - "Existing prompt-based SpawnAgent still works"
  artifacts:
    - path: "src/parser/transformer.ts"
      provides: "Extended transformSpawnAgent handling input prop with validation"
      contains: "extractInputProp"
    - path: "src/parser/parser.ts"
      provides: "Utility to detect VariableRef identifier"
      contains: "extractInputObjectLiteral"
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/ir/nodes.ts"
      via: "SpawnAgentInput type construction"
      pattern: "type: 'variable'|type: 'object'"
    - from: "src/parser/transformer.ts"
      to: "src/parser/parser.ts"
      via: "extractInterfaceProperties for validation"
      pattern: "extractInterfaceProperties"
---

<objective>
Parse SpawnAgent input prop and children in transformer, with type validation.

Purpose: Enable SpawnAgent to accept typed input (VariableRef or object literal) and children as extra instructions. Validate input objects against the generic type parameter's interface at compile time.

Output:
- Transformer parses `input` prop and creates SpawnAgentInput IR node
- Transformer extracts children text as extraInstructions
- Validation: error if both `prompt` and `input` provided
- Validation: error if input object missing required properties from interface
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-typed-spawnagent-input/12-RESEARCH.md
@.planning/phases/12-typed-spawnagent-input/12-01-SUMMARY.md

@src/parser/transformer.ts
@src/parser/parser.ts
@src/ir/nodes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add input prop parsing utilities</name>
  <files>src/parser/parser.ts</files>
  <action>
Add utilities to extract input prop value:

1. Add function to extract object literal for SpawnAgent input:
```typescript
/**
 * Extract SpawnAgent input object literal properties
 * Handles: { propName: "value" }, { propName: {placeholder} }, { propName: varRef }
 *
 * Returns InputProperty[] with proper InputPropertyValue types
 */
export function extractInputObjectLiteral(
  objLiteral: ObjectLiteralExpression,
  variables: Map<string, ExtractedVariable>
): InputProperty[] {
  // For each property:
  // - String literal: { type: 'string', value: str }
  // - Template with {var}: detect {placeholder} pattern -> { type: 'placeholder', name: var }
  // - Identifier referencing variable: { type: 'variable', name: envName }
  // - Other string: { type: 'string', value: str }
}
```

2. Add function to detect if identifier is a VariableRef:
```typescript
/**
 * Check if an identifier references a useVariable result
 */
export function isVariableRef(
  identifier: Identifier,
  variables: Map<string, ExtractedVariable>
): boolean {
  return variables.has(identifier.getText());
}
```

Import InputProperty, InputPropertyValue from nodes.ts (or define inline - they're simple types).
  </action>
  <verify>Run `npm run build` - compiles without errors</verify>
  <done>extractInputObjectLiteral and isVariableRef functions exist in parser.ts</done>
</task>

<task type="auto">
  <name>Task 2: Extend transformSpawnAgent for input prop</name>
  <files>src/parser/transformer.ts</files>
  <action>
Update transformSpawnAgent method:

1. Add extractInputProp method (similar to extractPromptProp):
```typescript
/**
 * Extract input prop - handles VariableRef identifier or object literal
 */
private extractInputProp(
  element: JsxOpeningElement | JsxSelfClosingElement
): SpawnAgentInput | undefined {
  const attr = element.getAttribute('input');
  if (!attr || !Node.isJsxAttribute(attr)) return undefined;

  const init = attr.getInitializer();
  if (!init || !Node.isJsxExpression(init)) return undefined;

  const expr = init.getExpression();
  if (!expr) return undefined;

  // Case 1: Identifier referencing useVariable result
  if (Node.isIdentifier(expr)) {
    const variable = this.variables.get(expr.getText());
    if (variable) {
      return { type: 'variable', variableName: variable.envName };
    }
    // Not a known variable - error
    throw this.createError(`Input '${expr.getText()}' not found. Use useVariable() or object literal.`, element);
  }

  // Case 2: Object literal
  if (Node.isObjectLiteralExpression(expr)) {
    const properties = extractInputObjectLiteral(expr, this.variables);
    return { type: 'object', properties };
  }

  throw this.createError('Input must be a VariableRef or object literal', element);
}
```

2. Add extractExtraInstructions method for children:
```typescript
/**
 * Extract extra instructions from SpawnAgent children
 * Treats children as raw text content (like Markdown component)
 */
private extractExtraInstructions(node: JsxElement): string | undefined {
  // Similar to transformMarkdown - extract text content from children
  // Return undefined if no children or only whitespace
}
```

3. Update transformSpawnAgent:
- Call extractInputProp() to get input
- Call extractExtraInstructions() if JsxElement (not self-closing)
- Validation: if both prompt AND input provided, throw error
- If input provided but no prompt, that's valid (prompt generated in emitter)
- If neither prompt nor input, throw error
- Include input and extraInstructions in returned SpawnAgentNode
  </action>
  <verify>Run `npm run build` - compiles without errors</verify>
  <done>transformSpawnAgent handles input prop, extraInstructions, and validates mutual exclusivity</done>
</task>

<task type="auto">
  <name>Task 3: Add input type validation against interface</name>
  <files>src/parser/transformer.ts</files>
  <action>
Add compile-time validation that input object properties match the SpawnAgent<T> type parameter's interface.

1. Add validation method:
```typescript
/**
 * Validate input object properties against SpawnAgent<T> type parameter.
 * Throws compile error if required interface properties are missing.
 */
private validateInputAgainstInterface(
  input: SpawnAgentInput,
  element: JsxOpeningElement | JsxSelfClosingElement
): void {
  // Only validate object literal inputs (VariableRef is runtime-checked)
  if (input.type !== 'object') return;

  // Extract SpawnAgent<T> type parameter from the element
  // Use existing type extraction patterns from Phase 11
  const typeArg = this.extractSpawnAgentTypeParam(element);
  if (!typeArg) return;  // No type param = no validation (backward compat)

  // Resolve the interface (local or imported)
  const resolved = resolveTypeImport(typeArg, this.sourceFile);
  if (!resolved?.interface) {
    // Interface not found - skip validation (warning logged elsewhere)
    return;
  }

  // Extract required properties from interface
  const interfaceProps = extractInterfaceProperties(resolved.interface);
  const requiredProps = interfaceProps.filter(p => p.required);

  // Get property names from input object
  const inputPropNames = input.properties.map(p => p.name);

  // Find missing required properties
  const missing = requiredProps.filter(p => !inputPropNames.includes(p.name));

  if (missing.length > 0) {
    const missingNames = missing.map(p => p.name).join(', ');
    throw this.createError(
      `SpawnAgent input missing required properties: ${missingNames}. ` +
      `Interface '${typeArg}' requires: ${requiredProps.map(p => p.name).join(', ')}`,
      element
    );
  }
}
```

2. Add extractSpawnAgentTypeParam helper:
```typescript
/**
 * Extract type argument from SpawnAgent<T> syntax
 * Returns the type name string (e.g., "ResearcherInput") or undefined
 */
private extractSpawnAgentTypeParam(
  element: JsxOpeningElement | JsxSelfClosingElement
): string | undefined {
  // Get the JSX element name (SpawnAgent)
  // Check for type arguments: <SpawnAgent<SomeType> ...>
  // Return the first type argument's name if present
  // Similar pattern to extractGenericTypeArg from Phase 11
}
```

3. Call validateInputAgainstInterface in transformSpawnAgent:
- After extracting input, call `this.validateInputAgainstInterface(input, element)`
- This ensures compile-time failure if required properties are missing

Import extractInterfaceProperties and resolveTypeImport from parser.ts if not already available.
  </action>
  <verify>Run `npm run build` - compiles without errors</verify>
  <done>Transformer validates input object against interface, throws error for missing required properties</done>
</task>

<task type="auto">
  <name>Task 4: Add transformer tests for input prop</name>
  <files>tests/parser/spawnagent-transformer.test.ts</files>
  <action>
Add test cases for input prop parsing and validation:

1. Test VariableRef input:
```typescript
describe('input prop parsing', () => {
  it('transforms input with VariableRef', () => {
    const tsx = `
      const ctx = useVariable("CTX", { bash: \`echo hi\` });
      export default function Test() {
        return (
          <Command name="test" description="Test">
            <SpawnAgent input={ctx} agent="a" model="m" description="d" />
          </Command>
        );
      }`;
    const doc = transformTsx(tsx);
    const spawn = doc.children[0] as SpawnAgentNode;
    expect(spawn.input).toEqual({ type: 'variable', variableName: 'CTX' });
    expect(spawn.prompt).toBeUndefined();
  });
});
```

2. Test object literal input:
```typescript
it('transforms input with object literal', () => {
  const tsx = `export default function Test() {
    return (
      <Command name="test" description="Test">
        <SpawnAgent
          input={{ phase: "5", goal: "{goal_var}" }}
          agent="a" model="m" description="d"
        />
      </Command>
    );
  }`;
  const doc = transformTsx(tsx);
  const spawn = doc.children[0] as SpawnAgentNode;
  expect(spawn.input?.type).toBe('object');
  expect(spawn.input?.properties).toContainEqual({
    name: 'phase',
    value: { type: 'string', value: '5' }
  });
});
```

3. Test children as extraInstructions:
```typescript
it('extracts children as extraInstructions', () => {
  const tsx = `export default function Test() {
    return (
      <Command name="test" description="Test">
        <SpawnAgent input={{ phase: "5" }} agent="a" model="m" description="d">
          Additional context here.
        </SpawnAgent>
      </Command>
    );
  }`;
  const doc = transformTsx(tsx);
  const spawn = doc.children[0] as SpawnAgentNode;
  expect(spawn.extraInstructions).toContain('Additional context');
});
```

4. Test mutual exclusivity:
```typescript
it('throws if both prompt and input provided', () => {
  const tsx = `export default function Test() {
    return (
      <Command name="test" description="Test">
        <SpawnAgent
          prompt="old style"
          input={{ phase: "5" }}
          agent="a" model="m" description="d"
        />
      </Command>
    );
  }`;
  expect(() => transformTsx(tsx)).toThrow(/Cannot use both prompt and input/);
});
```

5. Test input validation - missing required property throws:
```typescript
it('throws if input missing required interface property', () => {
  const tsx = `
    export interface TaskInput {
      goal: string;
      context: string;
      priority?: number;
    }

    export default function Test() {
      return (
        <Command name="test" description="Test">
          <SpawnAgent<TaskInput>
            input={{ goal: "Complete task" }}
            agent="a" model="m" description="d"
          />
        </Command>
      );
    }`;
  // Input provides 'goal' but missing required 'context'
  expect(() => transformTsx(tsx)).toThrow(/missing required properties.*context/i);
});
```

6. Test input validation - all required provided passes:
```typescript
it('passes validation when all required properties present', () => {
  const tsx = `
    export interface CompleteInput {
      a: string;
      b: string;
      c?: string;
    }

    export default function Test() {
      return (
        <Command name="test" description="Test">
          <SpawnAgent<CompleteInput>
            input={{ a: "value1", b: "value2" }}
            agent="a" model="m" description="d"
          />
        </Command>
      );
    }`;
  // Should not throw - required 'a' and 'b' are provided, 'c' is optional
  expect(() => transformTsx(tsx)).not.toThrow();
});
```

7. Test backward compatibility (prompt still works):
```typescript
it('still supports prompt prop (backward compat)', () => {
  const tsx = `export default function Test() {
    return (
      <Command name="test" description="Test">
        <SpawnAgent prompt="Do task" agent="a" model="m" description="d" />
      </Command>
    );
  }`;
  const doc = transformTsx(tsx);
  const spawn = doc.children[0] as SpawnAgentNode;
  expect(spawn.prompt).toBe('Do task');
  expect(spawn.input).toBeUndefined();
});
```
  </action>
  <verify>Run `npm test` - all tests pass including new input prop tests</verify>
  <done>Tests cover VariableRef input, object literal input, extraInstructions, mutual exclusivity, input validation against interface, backward compat</done>
</task>

</tasks>

<verification>
- `npm run build` compiles without errors
- `npm test` passes all tests
- New tests verify input prop parsing
- New tests verify transformer throws when input missing required interface properties
- Existing SpawnAgent tests still pass (backward compatibility)
</verification>

<success_criteria>
- SpawnAgent with `input={varRef}` creates SpawnAgentInput.type='variable'
- SpawnAgent with `input={{ key: value }}` creates SpawnAgentInput.type='object'
- SpawnAgent children text extracted as extraInstructions
- Error thrown when both prompt and input provided
- Error thrown when input object missing required interface properties (SC4)
- Existing prompt-based SpawnAgent unchanged (backward compat)
- {placeholder} patterns in object values preserved as placeholder type
</success_criteria>

<output>
After completion, create `.planning/phases/12-typed-spawnagent-input/12-02-SUMMARY.md`
</output>
