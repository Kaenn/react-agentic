---
phase: 12-typed-spawnagent-input
plan: 04
type: execute
wave: 3
depends_on: ["12-02"]
files_modified:
  - tests/validation/cross-file-validation.test.ts
  - docs/communication.md
autonomous: true

must_haves:
  truths:
    - "Validation detects missing required properties in object literal input"
    - "Validation passes when all required properties present"
    - "Documentation explains new input prop usage pattern"
  artifacts:
    - path: "tests/validation/cross-file-validation.test.ts"
      provides: "Tests for input object validation against interface"
      contains: "validates input object"
    - path: "docs/communication.md"
      provides: "Updated docs with input prop examples"
      contains: "input prop"
  key_links:
    - from: "tests/validation/cross-file-validation.test.ts"
      to: "src/parser/parser.ts"
      via: "Uses extractInterfaceProperties for validation"
      pattern: "extractInterfaceProperties"
---

<objective>
Add validation tests and update documentation for typed input.

Purpose: Ensure type mismatches are detected and developers have clear guidance on the new input prop pattern.

Output:
- Validation tests for object literal input against interface
- Updated communication.md documenting input prop usage
- Examples showing VariableRef and object literal patterns
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-typed-spawnagent-input/12-RESEARCH.md
@.planning/phases/12-typed-spawnagent-input/12-02-SUMMARY.md

@tests/validation/cross-file-validation.test.ts
@docs/communication.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add input validation tests</name>
  <files>tests/validation/cross-file-validation.test.ts</files>
  <action>
Add test cases for validating object literal input against interface:

1. Add describe block for input prop validation:
```typescript
describe('SpawnAgent input validation', () => {
  it('validates input object has required interface properties', () => {
    // Interface has required: goal, context; optional: priority
    // Input provides only: goal
    // Should detect missing: context
    const commandSource = `
      export interface TaskInput {
        goal: string;
        context: string;
        priority?: number;
      }

      export default function RunTask() {
        return (
          <Command name="run" description="Run task">
            <SpawnAgent<TaskInput>
              agent="worker"
              model="opus"
              description="Execute task"
              input={{ goal: "Complete task" }}
            />
          </Command>
        );
      }
    `;
    const commandFile = parseSource(project, commandSource, 'commands/validate.tsx');
    const root = findRootJsxElement(commandFile);
    const doc = transform(root!, commandFile);

    const spawnAgent = doc.children.find(c => c.kind === 'spawnAgent');
    expect(spawnAgent?.input).toBeDefined();
    expect(spawnAgent?.input?.type).toBe('object');

    // Resolve type and check required properties
    const resolved = resolveTypeImport('TaskInput', commandFile);
    const props = extractInterfaceProperties(resolved!.interface);
    const required = props.filter(p => p.required);

    // Get property names from input
    const inputProps = spawnAgent!.input!.properties.map(p => p.name);

    // Find missing required
    const missing = required.filter(p => !inputProps.includes(p.name));
    expect(missing.length).toBe(1);
    expect(missing[0].name).toBe('context');
  });

  it('passes validation when all required properties present', () => {
    const commandSource = `
      export interface CompleteInput {
        a: string;
        b: string;
        c?: string;
      }

      export default function Test() {
        return (
          <Command name="test" description="Test">
            <SpawnAgent<CompleteInput>
              agent="complete"
              model="opus"
              description="test"
              input={{ a: "value1", b: "value2" }}
            />
          </Command>
        );
      }
    `;
    const commandFile = parseSource(project, commandSource, 'commands/complete.tsx');
    const root = findRootJsxElement(commandFile);
    const doc = transform(root!, commandFile);

    const spawnAgent = doc.children.find(c => c.kind === 'spawnAgent');
    const resolved = resolveTypeImport('CompleteInput', commandFile);
    const props = extractInterfaceProperties(resolved!.interface);
    const required = props.filter(p => p.required);

    const inputProps = spawnAgent!.input!.properties.map(p => p.name);
    const missing = required.filter(p => !inputProps.includes(p.name));

    expect(missing.length).toBe(0);
  });

  it('handles placeholder values in input object', () => {
    const commandSource = `
      export interface DynamicInput {
        phase: string;
      }

      export default function Test() {
        return (
          <Command name="test" description="Test">
            <SpawnAgent<DynamicInput>
              agent="a"
              model="m"
              description="d"
              input={{ phase: "{phase_var}" }}
            />
          </Command>
        );
      }
    `;
    const commandFile = parseSource(project, commandSource, 'commands/dynamic.tsx');
    const root = findRootJsxElement(commandFile);
    const doc = transform(root!, commandFile);

    const spawnAgent = doc.children.find(c => c.kind === 'spawnAgent');
    expect(spawnAgent?.input?.type).toBe('object');
    // Placeholder should be detected
    const phaseValue = spawnAgent!.input!.properties.find(p => p.name === 'phase')?.value;
    expect(phaseValue?.type).toBe('placeholder');
  });
});
```
  </action>
  <verify>Run `npm test` - all validation tests pass</verify>
  <done>Tests verify input validation against interface, missing property detection, placeholder handling</done>
</task>

<task type="auto">
  <name>Task 2: Update communication documentation</name>
  <files>docs/communication.md</files>
  <action>
Update communication.md to document the new input prop pattern:

1. Add section for typed input (after existing SpawnAgent section):
```markdown
## Typed Input (Recommended)

Instead of writing prompts manually, use the `input` prop for type-safe communication:

### Object Literal Input

Pass structured data that matches the Agent's interface:

\`\`\`tsx
// Agent defines its input contract
export interface ResearcherInput {
  phase: string;
  goal: string;
  requirements?: string;
}

export function Researcher() {
  return (
    <Agent<ResearcherInput> name="researcher" description="Research topics">
      ...
    </Agent>
  );
}

// Command uses typed input
export default function PlanPhase() {
  return (
    <Command name="plan" description="Plan a phase">
      <SpawnAgent<ResearcherInput>
        input={{ phase: "{phase}", goal: "Complete research" }}
        agent="researcher"
        model="{model}"
        description="Research phase"
      />
    </Command>
  );
}
\`\`\`

Generated prompt:
\`\`\`
<phase>
{phase}
</phase>

<goal>
Complete research
</goal>
\`\`\`

### VariableRef Input

For dynamic data computed at runtime, use `useVariable`:

\`\`\`tsx
const context = useVariable("CONTEXT", {
  bash: \`cat \${PHASE_DIR}/context.json\`
});

<SpawnAgent<ResearcherInput>
  input={context}
  agent="researcher"
  model="{model}"
  description="Research with context"
/>
\`\`\`

Generated prompt:
\`\`\`
<input>
{context}
</input>
\`\`\`

### Extra Instructions

Children become additional instructions appended to the auto-generated prompt:

\`\`\`tsx
<SpawnAgent<ResearcherInput>
  input={{ phase: "{phase}", goal: "Research" }}
  agent="researcher"
  model="{model}"
  description="Research phase"
>
  Focus on technical requirements.
  Ignore marketing considerations.
</SpawnAgent>
\`\`\`
```

2. Add deprecation note to existing prompt section:
```markdown
> **Note:** The `prompt` prop is deprecated. Use `input` for type-safe communication.
> The `prompt` prop remains functional for backward compatibility.
```

3. Update the "Type Safety" section to mention input validation:
```markdown
### Input Validation

When using the `input` prop with an object literal, the compiler checks that:
- All required interface properties are provided
- Property names match the interface definition

Missing required properties are detected at compile time, not runtime.
```
  </action>
  <verify>Documentation renders correctly, examples are syntactically valid</verify>
  <done>docs/communication.md updated with input prop patterns, deprecation notice, validation info</done>
</task>

</tasks>

<verification>
- `npm test` passes all tests
- docs/communication.md has clear input prop documentation
- Examples show both VariableRef and object literal patterns
- Deprecation notice on prompt prop
</verification>

<success_criteria>
- Tests validate input object against interface properties
- Tests detect missing required properties
- Documentation explains input prop usage clearly
- VariableRef and object literal patterns both documented
- Deprecation notice added to prompt section
</success_criteria>

<output>
After completion, create `.planning/phases/12-typed-spawnagent-input/12-04-SUMMARY.md`
</output>
