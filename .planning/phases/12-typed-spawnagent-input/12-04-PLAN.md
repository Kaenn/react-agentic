---
phase: 12-typed-spawnagent-input
plan: 04
type: execute
wave: 3
depends_on: ["12-02"]
files_modified:
  - tests/validation/cross-file-validation.test.ts
  - docs/communication.md
autonomous: true

must_haves:
  truths:
    - "Cross-file validation tests verify transformer error behavior"
    - "Tests confirm transformer throws for imported interface type mismatches"
    - "Documentation explains new input prop usage pattern"
  artifacts:
    - path: "tests/validation/cross-file-validation.test.ts"
      provides: "Tests for cross-file input validation (imported interfaces)"
      contains: "cross-file input validation"
    - path: "docs/communication.md"
      provides: "Updated docs with input prop examples"
      contains: "input prop"
  key_links:
    - from: "tests/validation/cross-file-validation.test.ts"
      to: "src/parser/transformer.ts"
      via: "Verifies transformer throws on type mismatch"
      pattern: "expect.*toThrow"
---

<objective>
Add cross-file validation tests and update documentation for typed input.

Purpose: Verify transformer error behavior with imported interfaces and provide clear guidance on the new input prop pattern.

Output:
- Cross-file validation tests that verify transformer throws on type mismatch
- Updated communication.md documenting input prop usage
- Examples showing VariableRef and object literal patterns
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-typed-spawnagent-input/12-RESEARCH.md
@.planning/phases/12-typed-spawnagent-input/12-02-SUMMARY.md

@tests/validation/cross-file-validation.test.ts
@docs/communication.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cross-file input validation tests</name>
  <files>tests/validation/cross-file-validation.test.ts</files>
  <action>
Add test cases for cross-file input validation (where interface is imported from another file).

Note: Plan 12-02 adds tests for LOCAL interface validation. This plan tests IMPORTED interface validation - the cross-file scenario.

1. Add describe block for cross-file input validation:
```typescript
describe('SpawnAgent cross-file input validation', () => {
  it('throws when input missing required property from imported interface', () => {
    // Agent file exports interface
    const agentSource = `
      export interface ResearcherInput {
        topic: string;
        depth: string;
        format?: string;
      }

      export function Researcher() {
        return (
          <Agent<ResearcherInput> name="researcher" description="Research topics">
            ...
          </Agent>
        );
      }
    `;

    // Command imports interface and uses SpawnAgent with missing property
    const commandSource = `
      import { ResearcherInput } from '../agents/researcher';

      export default function Research() {
        return (
          <Command name="research" description="Do research">
            <SpawnAgent<ResearcherInput>
              agent="researcher"
              model="opus"
              description="Research task"
              input={{ topic: "TypeScript" }}
            />
          </Command>
        );
      }
    `;

    // Setup multi-file project
    const agentFile = parseSource(project, agentSource, 'agents/researcher.tsx');
    const commandFile = parseSource(project, commandSource, 'commands/research.tsx');

    // Transformer should throw because 'depth' is required but missing
    expect(() => {
      const root = findRootJsxElement(commandFile);
      transform(root!, commandFile);
    }).toThrow(/missing required properties.*depth/i);
  });

  it('passes when all required properties provided for imported interface', () => {
    const agentSource = `
      export interface TaskInput {
        name: string;
        priority: string;
        notes?: string;
      }

      export function TaskRunner() {
        return (
          <Agent<TaskInput> name="task-runner" description="Run tasks">
            ...
          </Agent>
        );
      }
    `;

    const commandSource = `
      import { TaskInput } from '../agents/task-runner';

      export default function RunTask() {
        return (
          <Command name="run" description="Run a task">
            <SpawnAgent<TaskInput>
              agent="task-runner"
              model="opus"
              description="Execute task"
              input={{ name: "Build", priority: "high" }}
            />
          </Command>
        );
      }
    `;

    const agentFile = parseSource(project, agentSource, 'agents/task-runner.tsx');
    const commandFile = parseSource(project, commandSource, 'commands/run.tsx');

    // Should not throw - 'name' and 'priority' are provided, 'notes' is optional
    expect(() => {
      const root = findRootJsxElement(commandFile);
      transform(root!, commandFile);
    }).not.toThrow();
  });

  it('handles placeholder values in cross-file input validation', () => {
    const agentSource = `
      export interface DynamicInput {
        phase: string;
        goal: string;
      }

      export function Planner() {
        return (
          <Agent<DynamicInput> name="planner" description="Plan phases">
            ...
          </Agent>
        );
      }
    `;

    const commandSource = `
      import { DynamicInput } from '../agents/planner';

      export default function Plan() {
        return (
          <Command name="plan" description="Plan phase">
            <SpawnAgent<DynamicInput>
              agent="planner"
              model="opus"
              description="Plan"
              input={{ phase: "{phase_num}", goal: "{goal_var}" }}
            />
          </Command>
        );
      }
    `;

    const agentFile = parseSource(project, agentSource, 'agents/planner.tsx');
    const commandFile = parseSource(project, commandSource, 'commands/plan.tsx');

    // Should pass - both required properties provided (as placeholders)
    expect(() => {
      const root = findRootJsxElement(commandFile);
      const doc = transform(root!, commandFile);
      const spawn = doc.children.find(c => c.kind === 'spawnAgent');
      expect(spawn?.input?.type).toBe('object');
    }).not.toThrow();
  });
});
```

Note: These tests verify that the TRANSFORMER throws errors for cross-file type mismatches, not manual validation code.
  </action>
  <verify>Run `npm test` - all validation tests pass</verify>
  <done>Tests verify transformer throws for cross-file type mismatches</done>
</task>

<task type="auto">
  <name>Task 2: Update communication documentation</name>
  <files>docs/communication.md</files>
  <action>
Update communication.md to document the new input prop pattern:

1. Add section for typed input (after existing SpawnAgent section):
```markdown
## Typed Input (Recommended)

Instead of writing prompts manually, use the `input` prop for type-safe communication:

### Object Literal Input

Pass structured data that matches the Agent's interface:

\`\`\`tsx
// Agent defines its input contract
export interface ResearcherInput {
  phase: string;
  goal: string;
  requirements?: string;
}

export function Researcher() {
  return (
    <Agent<ResearcherInput> name="researcher" description="Research topics">
      ...
    </Agent>
  );
}

// Command uses typed input
export default function PlanPhase() {
  return (
    <Command name="plan" description="Plan a phase">
      <SpawnAgent<ResearcherInput>
        input={{ phase: "{phase}", goal: "Complete research" }}
        agent="researcher"
        model="{model}"
        description="Research phase"
      />
    </Command>
  );
}
\`\`\`

Generated prompt:
\`\`\`
<phase>
{phase}
</phase>

<goal>
Complete research
</goal>
\`\`\`

### VariableRef Input

For dynamic data computed at runtime, use `useVariable`:

\`\`\`tsx
const context = useVariable("CONTEXT", {
  bash: \`cat \${PHASE_DIR}/context.json\`
});

<SpawnAgent<ResearcherInput>
  input={context}
  agent="researcher"
  model="{model}"
  description="Research with context"
/>
\`\`\`

Generated prompt:
\`\`\`
<input>
{context}
</input>
\`\`\`

### Extra Instructions

Children become additional instructions appended to the auto-generated prompt:

\`\`\`tsx
<SpawnAgent<ResearcherInput>
  input={{ phase: "{phase}", goal: "Research" }}
  agent="researcher"
  model="{model}"
  description="Research phase"
>
  Focus on technical requirements.
  Ignore marketing considerations.
</SpawnAgent>
\`\`\`
```

2. Add deprecation note to existing prompt section:
```markdown
> **Note:** The `prompt` prop is deprecated. Use `input` for type-safe communication.
> The `prompt` prop remains functional for backward compatibility.
```

3. Add "Compile-Time Validation" section:
```markdown
### Compile-Time Validation

When using the `input` prop with an object literal, the compiler validates that:
- All required interface properties are provided
- Property names match the interface definition

Missing required properties cause a **compile-time error**, not a runtime failure:

\`\`\`tsx
// Agent interface requires 'goal' and 'context'
export interface TaskInput {
  goal: string;
  context: string;
  priority?: number;  // optional
}

// This FAILS at compile time:
<SpawnAgent<TaskInput>
  input={{ goal: "Do something" }}  // ERROR: missing required property 'context'
  ...
/>

// This succeeds:
<SpawnAgent<TaskInput>
  input={{ goal: "Do something", context: "Project X" }}  // OK
  ...
/>
\`\`\`

This ensures type mismatches are caught before your command runs, not during execution.
```
  </action>
  <verify>Documentation renders correctly, examples are syntactically valid</verify>
  <done>docs/communication.md updated with input prop patterns, deprecation notice, compile-time validation info</done>
</task>

</tasks>

<verification>
- `npm test` passes all tests
- docs/communication.md has clear input prop documentation
- Examples show both VariableRef and object literal patterns
- Deprecation notice on prompt prop
- Compile-time validation section explains error behavior
</verification>

<success_criteria>
- Cross-file tests verify transformer throws for type mismatches
- Tests confirm placeholder values work in cross-file scenario
- Documentation explains input prop usage clearly
- VariableRef and object literal patterns both documented
- Deprecation notice added to prompt section
- Compile-time validation behavior documented
</success_criteria>

<output>
After completion, create `.planning/phases/12-typed-spawnagent-input/12-04-SUMMARY.md`
</output>
