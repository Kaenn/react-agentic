---
phase: 35-command-orchestration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ir/nodes.ts
  - src/workflow/agents/Agent.ts
  - src/workflow/agents/index.ts
  - src/parser/transformers/control.ts
  - src/parser/transformers/dispatch.ts
  - src/emitter/emitter.ts
  - tests/grammar/SemanticComponents/on-status-default.test.ts
autonomous: true

must_haves:
  truths:
    - "OnStatusDefault component can be used after OnStatus to catch unhandled statuses"
    - "OnStatusDefault emits as **On any other status:** header"
    - "Standalone OnStatusDefault without output prop throws error"
    - "OnStatusDefault with explicit output prop is valid"
  artifacts:
    - path: "src/ir/nodes.ts"
      provides: "OnStatusDefaultNode interface"
      contains: "kind: 'onStatusDefault'"
    - path: "src/workflow/agents/Agent.ts"
      provides: "OnStatusDefault component and props"
      exports: ["OnStatusDefault", "OnStatusDefaultProps"]
    - path: "src/parser/transformers/control.ts"
      provides: "transformOnStatusDefault function"
      exports: ["transformOnStatusDefault"]
    - path: "src/emitter/emitter.ts"
      provides: "emitOnStatusDefault method"
      contains: "On any other status:"
  key_links:
    - from: "src/parser/transformers/dispatch.ts"
      to: "transformOnStatusDefault"
      via: "OnStatus sibling detection"
      pattern: "OnStatusDefault"
    - from: "src/emitter/emitter.ts"
      to: "OnStatusDefaultNode"
      via: "case 'onStatusDefault'"
      pattern: "emitOnStatusDefault"
---

<objective>
Implement OnStatusDefault component for catch-all agent status handling.

Purpose: Allow commands to handle unexpected agent return statuses without explicitly listing all possible values. Follows the sibling component pattern established by If/Else.

Output: OnStatusDefault component with IR node, transformer (with sibling detection), emitter, and tests.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-command-orchestration/35-CONTEXT.md
@.planning/phases/35-command-orchestration/35-RESEARCH.md
@src/ir/nodes.ts
@src/workflow/agents/Agent.ts
@src/parser/transformers/control.ts
@src/parser/transformers/dispatch.ts
@src/emitter/emitter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add OnStatusDefaultNode IR and component stub</name>
  <files>src/ir/nodes.ts, src/workflow/agents/Agent.ts, src/workflow/agents/index.ts</files>
  <action>
1. Add OnStatusDefaultNode interface to src/ir/nodes.ts:

```typescript
/**
 * OnStatusDefault block - catch-all for unhandled agent statuses
 * Emits as **On any other status:** prose pattern
 */
export interface OnStatusDefaultNode {
  kind: 'onStatusDefault';
  /** Output reference from useOutput (inherited from preceding OnStatus) */
  outputRef: OutputReference;
  /** Block content for default case */
  children: BaseBlockNode[];
}
```

2. Add OnStatusDefaultNode to BaseBlockNode union type in nodes.ts

3. Add OnStatusDefaultProps interface to src/workflow/agents/Agent.ts:

```typescript
/**
 * Props for the OnStatusDefault component
 */
export interface OnStatusDefaultProps {
  /** Optional output reference (inherited from preceding OnStatus if not provided) */
  output?: { agent: string };
  /** Block content for default status handling */
  children?: ReactNode;
}
```

4. Add OnStatusDefault component function to src/workflow/agents/Agent.ts:

```typescript
/**
 * OnStatusDefault component - catch-all for unhandled agent statuses
 *
 * This is a compile-time component transformed by react-agentic.
 * Must follow OnStatus blocks or provide explicit output prop.
 *
 * @example
 * const output = useOutput<BuildOutput>("build-agent");
 *
 * <OnStatus output={output} status="SUCCESS">
 *   <p>Build succeeded</p>
 * </OnStatus>
 * <OnStatus output={output} status="FAILED">
 *   <p>Build failed</p>
 * </OnStatus>
 * <OnStatusDefault>
 *   <p>Unexpected status from build agent</p>
 * </OnStatusDefault>
 */
export function OnStatusDefault(_props: OnStatusDefaultProps): null {
  return null;
}
```

5. Export OnStatusDefault and OnStatusDefaultProps from src/workflow/agents/index.ts
  </action>
  <verify>
Run `npm run build` to verify TypeScript compilation passes. Check that OnStatusDefaultNode is in the BaseBlockNode union.
  </verify>
  <done>
OnStatusDefaultNode exists in IR. OnStatusDefault component with props exported from workflow/agents module.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add transformer with sibling detection</name>
  <files>src/parser/transformers/control.ts, src/parser/transformers/dispatch.ts, src/parser/transformers/index.ts</files>
  <action>
1. Add transformOnStatusDefault function to src/parser/transformers/control.ts:

```typescript
/**
 * Transform OnStatusDefault component to OnStatusDefaultNode
 * Handles catch-all for agent output statuses
 *
 * @param node - JSX element
 * @param ctx - Transform context
 * @param outputRef - Output reference from preceding OnStatus (sibling detection) or explicit prop
 */
export function transformOnStatusDefault(
  node: JsxElement | JsxSelfClosingElement,
  ctx: TransformContext,
  outputRef?: OutputReference
): OnStatusDefaultNode {
  const openingElement = Node.isJsxElement(node)
    ? node.getOpeningElement()
    : node;

  // Check for explicit output prop
  const outputAttr = openingElement.getAttribute('output');
  let resolvedOutputRef: OutputReference | undefined = outputRef;

  if (outputAttr && Node.isJsxAttribute(outputAttr)) {
    const outputInit = outputAttr.getInitializer();
    if (outputInit && Node.isJsxExpression(outputInit)) {
      const outputExpr = outputInit.getExpression();
      if (outputExpr && Node.isIdentifier(outputExpr)) {
        const outputIdentifier = outputExpr.getText();
        const agentName = ctx.outputs.get(outputIdentifier);
        if (agentName) {
          resolvedOutputRef = {
            kind: 'outputReference',
            agent: agentName,
          };
        }
      }
    }
  }

  // Validate we have an output reference
  if (!resolvedOutputRef) {
    throw ctx.createError(
      'OnStatusDefault must follow OnStatus blocks or provide output prop',
      openingElement
    );
  }

  // Transform children as block content
  const children = Node.isJsxElement(node)
    ? transformBlockChildren(node.getJsxChildren(), ctx)
    : [];

  return {
    kind: 'onStatusDefault',
    outputRef: resolvedOutputRef,
    children: children as BaseBlockNode[],
  };
}
```

2. Add OnStatusDefaultNode import to control.ts imports

3. Update dispatch.ts to handle OnStatus/OnStatusDefault sibling pairing:

In transformBlockChildren, update the OnStatus case to look for OnStatusDefault sibling:

```typescript
if (childName === 'OnStatus') {
  const onStatusNode = transformOnStatus(child, ctx);
  blocks.push(onStatusNode);

  // Check for OnStatusDefault sibling
  let nextIndex = i + 1;
  while (nextIndex < jsxChildren.length) {
    const sibling = jsxChildren[nextIndex];
    // Skip whitespace-only text
    if (Node.isJsxText(sibling)) {
      const text = extractText(sibling);
      if (!text) {
        nextIndex++;
        continue;
      }
    }
    // Check if next non-whitespace is OnStatusDefault
    if ((Node.isJsxElement(sibling) || Node.isJsxSelfClosingElement(sibling))
        && getElementName(sibling) === 'OnStatusDefault') {
      const onStatusDefaultNode = transformOnStatusDefault(sibling, ctx, onStatusNode.outputRef);
      blocks.push(onStatusDefaultNode);
      i = nextIndex; // Skip past OnStatusDefault in outer loop
    }
    break;
  }
  i++;
  continue;
}
```

4. Add standalone OnStatusDefault error in transformElement:

```typescript
// OnStatusDefault component - standalone is an error (must follow OnStatus as sibling OR have output prop)
if (name === 'OnStatusDefault') {
  // Allow with explicit output prop
  const openingElement = Node.isJsxElement(node)
    ? node.getOpeningElement()
    : node;
  const hasOutputProp = openingElement.getAttribute('output');
  if (!hasOutputProp) {
    throw ctx.createError('<OnStatusDefault> must follow <OnStatus> as sibling or provide output prop', node);
  }
  return transformOnStatusDefault(node, ctx);
}
```

5. Import transformOnStatusDefault in dispatch.ts

6. Export transformOnStatusDefault from src/parser/transformers/index.ts
  </action>
  <verify>
Run `npm run build` to verify TypeScript compilation. Manually verify dispatch routing logic handles OnStatus followed by OnStatusDefault.
  </verify>
  <done>
transformOnStatusDefault function exists. Sibling detection in dispatch handles OnStatus→OnStatusDefault pairing. Standalone OnStatusDefault with output prop is valid.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add emitter and tests</name>
  <files>src/emitter/emitter.ts, tests/grammar/SemanticComponents/on-status-default.test.ts</files>
  <action>
1. Add case for onStatusDefault in emitBlock switch in src/emitter/emitter.ts:

```typescript
case 'onStatusDefault':
  return this.emitOnStatusDefault(node);
```

2. Add emitOnStatusDefault method to Emitter class:

```typescript
/**
 * Emit OnStatusDefault node as prose pattern
 *
 * Output format:
 * **On any other status:**
 *
 * {content}
 */
private emitOnStatusDefault(node: OnStatusDefaultNode): string {
  const parts: string[] = [];

  // Emit default status header
  parts.push('**On any other status:**');

  // Emit block content with blank line after header
  for (const child of node.children) {
    parts.push(this.emitBlock(child));
  }

  return parts.join('\n\n');
}
```

3. Import OnStatusDefaultNode in emitter.ts

4. Create tests/grammar/SemanticComponents/on-status-default.test.ts:

```typescript
import { describe, it, expect } from 'vitest';
import { buildCommand } from '../../_helpers/buildCommand.js';

describe('<OnStatusDefault>', () => {
  describe('sibling pairing', () => {
    it('accepts OnStatusDefault after OnStatus', () => {
      const tsx = `
        import { Command, useOutput, OnStatus, OnStatusDefault } from 'react-agentic';

        interface TestOutput { result: string }

        export default function Doc() {
          const out = useOutput<TestOutput>("test-agent");
          return (
            <Command name="test" description="Test">
              <OnStatus output={out} status="SUCCESS">
                <p>Success!</p>
              </OnStatus>
              <OnStatusDefault>
                <p>Other status</p>
              </OnStatusDefault>
            </Command>
          );
        }
      `;
      const result = buildCommand(tsx);
      expect(result).toContain('**On SUCCESS:**');
      expect(result).toContain('**On any other status:**');
      expect(result).toContain('Other status');
    });

    it('accepts OnStatusDefault with explicit output prop', () => {
      const tsx = `
        import { Command, useOutput, OnStatusDefault } from 'react-agentic';

        interface TestOutput { result: string }

        export default function Doc() {
          const out = useOutput<TestOutput>("test-agent");
          return (
            <Command name="test" description="Test">
              <OnStatusDefault output={out}>
                <p>Default handling</p>
              </OnStatusDefault>
            </Command>
          );
        }
      `;
      const result = buildCommand(tsx);
      expect(result).toContain('**On any other status:**');
      expect(result).toContain('Default handling');
    });

    it('rejects standalone OnStatusDefault without output prop', () => {
      const tsx = `
        import { Command, OnStatusDefault } from 'react-agentic';

        export default function Doc() {
          return (
            <Command name="test" description="Test">
              <OnStatusDefault>
                <p>Default</p>
              </OnStatusDefault>
            </Command>
          );
        }
      `;
      expect(() => buildCommand(tsx)).toThrow(/OnStatusDefault must follow OnStatus/);
    });
  });

  describe('output correctness', () => {
    it('emits after multiple OnStatus blocks', () => {
      const tsx = `
        import { Command, useOutput, OnStatus, OnStatusDefault } from 'react-agentic';

        interface TestOutput { result: string }

        export default function Doc() {
          const out = useOutput<TestOutput>("test-agent");
          return (
            <Command name="test" description="Test">
              <OnStatus output={out} status="SUCCESS">
                <p>Success</p>
              </OnStatus>
              <OnStatus output={out} status="BLOCKED">
                <p>Blocked</p>
              </OnStatus>
              <OnStatus output={out} status="ERROR">
                <p>Error</p>
              </OnStatus>
              <OnStatusDefault>
                <p>Unexpected status</p>
              </OnStatusDefault>
            </Command>
          );
        }
      `;
      const result = buildCommand(tsx);
      expect(result).toContain('**On SUCCESS:**');
      expect(result).toContain('**On BLOCKED:**');
      expect(result).toContain('**On ERROR:**');
      expect(result).toContain('**On any other status:**');
      expect(result).toContain('Unexpected status');
    });

    it('handles empty OnStatusDefault', () => {
      const tsx = `
        import { Command, useOutput, OnStatus, OnStatusDefault } from 'react-agentic';

        interface TestOutput { result: string }

        export default function Doc() {
          const out = useOutput<TestOutput>("test-agent");
          return (
            <Command name="test" description="Test">
              <OnStatus output={out} status="SUCCESS">
                <p>Success</p>
              </OnStatus>
              <OnStatusDefault />
            </Command>
          );
        }
      `;
      const result = buildCommand(tsx);
      expect(result).toContain('**On SUCCESS:**');
      expect(result).toContain('**On any other status:**');
    });
  });
});
```
  </action>
  <verify>
Run `npm test tests/grammar/SemanticComponents/on-status-default.test.ts` to verify all tests pass. Run `npm test` to ensure no regressions.
  </verify>
  <done>
Emitter emits OnStatusDefault as "**On any other status:**". All tests pass. No regressions in existing tests.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with no TypeScript errors
2. `npm test tests/grammar/SemanticComponents/on-status-default.test.ts` - all 5 tests pass
3. `npm test` - full test suite passes (no regressions)
4. OnStatusDefault can be used after OnStatus blocks
5. OnStatusDefault with explicit output prop works standalone
6. Standalone OnStatusDefault without output throws helpful error
</verification>

<success_criteria>
- OnStatusDefaultNode exists in IR
- OnStatusDefault component exported from react-agentic
- Transformer handles sibling detection (OnStatus → OnStatusDefault)
- Transformer validates output prop requirement
- Emitter produces "**On any other status:**" output
- All new and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/35-command-orchestration/35-01-SUMMARY.md`
</output>
