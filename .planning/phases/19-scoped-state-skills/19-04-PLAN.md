---
phase: 19-scoped-state-skills
plan: 04
type: execute
wave: 3
depends_on: ["19-02", "19-03"]
files_modified:
  - src/emitter/state-emitter.ts
  - src/emitter/index.ts
  - src/cli/commands/build.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "emitState() generates multiple skill files from StateDocumentNode"
    - "Build command routes *.state.tsx files to state emitter"
    - "Generated skills output to .claude/skills/{state}.{op}.md"
    - "All CRUD skills (init, read, write, delete) are generated"
    - "Custom operations generate additional skill files"
    - "Main init skill orchestrates all discovered state init skills"
    - "Public API exports State and Operation components"
    - "TypeScript compiles without errors"
  artifacts:
    - path: "src/emitter/state-emitter.ts"
      provides: "emitState function, generateMainInitSkill function"
      exports: ["emitState", "generateMainInitSkill"]
    - path: "src/cli/commands/build.ts"
      provides: "State file routing, main init generation"
      contains: ".state.tsx"
    - path: "src/index.ts"
      provides: "Public API exports"
      exports: ["State", "Operation"]
  key_links:
    - from: "src/emitter/state-emitter.ts"
      to: "src/providers/sqlite.ts"
      via: "Uses provider to generate skills"
      pattern: "getProvider"
    - from: "src/cli/commands/build.ts"
      to: "src/emitter/state-emitter.ts"
      via: "Routes state files to emitter"
      pattern: "emitState"
---

<objective>
Implement state emitter and build command integration for multi-skill output.

Purpose: Complete the pipeline from State TSX to generated skill files. Each State definition produces 4+ skill files (init, read, write, delete, plus custom operations). Also generate a main init skill that orchestrates all state init skills.

Output: emitState function, build command routing for *.state.tsx, multi-file output to .claude/skills/, main init skill generation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-scoped-state-skills/19-CONTEXT.md
@.planning/phases/19-scoped-state-skills/19-RESEARCH.md
@.planning/phases/19-scoped-state-skills/19-01-SUMMARY.md
@.planning/phases/19-scoped-state-skills/19-02-SUMMARY.md
@.planning/phases/19-scoped-state-skills/19-03-SUMMARY.md
@src/emitter/emitter.ts
@src/emitter/index.ts
@src/cli/commands/build.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state emitter</name>
  <files>src/emitter/state-emitter.ts</files>
  <action>
Create new file src/emitter/state-emitter.ts:

```typescript
/**
 * State Emitter
 *
 * Generates multiple skill files from a StateDocumentNode.
 * Uses provider templates for storage-specific code generation.
 */

import type { StateDocumentNode } from '../ir/nodes.js';
import { getProvider, type GeneratedSkill, type ProviderContext } from '../providers/index.js';

/**
 * Result of emitting a State component
 */
export interface StateEmitResult {
  /** All generated skill files */
  skills: GeneratedSkill[];
  /** State name (for main init tracking) */
  stateName: string;
}

/**
 * Emit a StateDocumentNode to multiple skill files
 *
 * Generates:
 * - {state}.init.md - Schema/table creation
 * - {state}.read.md - Read state with optional field filter
 * - {state}.write.md - Update state field
 * - {state}.delete.md - Reset state to defaults
 * - {state}.{operation}.md - Custom operations
 *
 * @param doc - The state document node from transformer
 * @returns Array of generated skill files and state name
 */
export function emitState(doc: StateDocumentNode): StateEmitResult {
  const { state } = doc;

  // Get provider template
  const provider = getProvider(state.provider);

  // Build provider context
  const ctx: ProviderContext = {
    stateName: state.name,
    database: state.config.database,
    schema: state.schema
  };

  const skills: GeneratedSkill[] = [];

  // Generate CRUD skills
  skills.push(provider.generateInit(ctx));
  skills.push(provider.generateRead(ctx));
  skills.push(provider.generateWrite(ctx));
  skills.push(provider.generateDelete(ctx));

  // Generate custom operations
  for (const operation of state.operations) {
    skills.push(provider.generateOperation(ctx, operation));
  }

  return { skills, stateName: state.name };
}

/**
 * Generate a main init skill that invokes all state init skills
 *
 * This skill allows initializing all state tables with a single command.
 *
 * @param stateNames - Array of state names that have been generated
 * @returns Generated skill for init:all
 */
export function generateMainInitSkill(stateNames: string[]): GeneratedSkill {
  const invocations = stateNames.map(name => `# Initialize ${name} state
echo "Initializing ${name}..."
# Note: Claude will invoke /${name}:init skill`).join('\n\n');

  const skillList = stateNames.map(name => `- \`/${name}:init\``).join('\n');

  const content = `---
name: init.all
description: Initialize all state tables. Run once to set up all state storage.
allowed-tools:
  - Bash(sqlite3:*)
  - Bash(mkdir:*)
---

# Initialize All State

Initialize all registered state tables in the project.

## State Skills

This skill orchestrates the following init skills:

${skillList}

## Usage

Run this skill once when setting up a new project or after adding new state definitions.

## Process

The following state tables will be initialized:

${invocations}

**Note:** This skill should invoke each state's init skill in sequence. Claude should run each \`/{state}:init\` skill listed above.
`;

  return {
    filename: 'init.all.md',
    content
  };
}
```

This is a clean separation - the emitter orchestrates skill generation, the provider does the actual code generation.
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors.</verify>
  <done>emitState function exists that generates CRUD skills plus custom operations using provider templates. generateMainInitSkill function creates orchestration skill.</done>
</task>

<task type="auto">
  <name>Task 2: Update emitter index and build command</name>
  <files>src/emitter/index.ts, src/cli/commands/build.ts, src/index.ts</files>
  <action>
1. Add export to src/emitter/index.ts:

```typescript
export { emitState, generateMainInitSkill, type StateEmitResult } from './state-emitter.js';
```

2. Update src/cli/commands/build.ts to handle State files.

First, add imports at top (after line 24):
```typescript
import { emitState, generateMainInitSkill } from '../../emitter/state-emitter.js';
import type { StateDocumentNode } from '../../ir/nodes.js';
```

Then in the runBuild function, add StateDocumentNode handling. After the `doc.kind === 'document'` block (which ends around line 256), add a new else-if block:

```typescript
} else if (doc.kind === 'stateDocument') {
  // State: multi-file output to .claude/skills/
  const stateDoc = doc as StateDocumentNode;
  const result = emitState(stateDoc);

  // Track state name for main init generation (add allStateNames array at function start)
  allStateNames.push(result.stateName);

  // Write all skill files
  for (const skill of result.skills) {
    const skillPath = `.claude/skills/${skill.filename}`;
    results.push({
      inputFile,
      outputPath: skillPath,
      content: skill.content,
      size: Buffer.byteLength(skill.content, 'utf8'),
    });
  }
}
```

At the start of runBuild function (around line 178), add state name tracking:
```typescript
const allStateNames: string[] = [];
```

After the main for loop (after line 266), before the MCP config merge, add main init generation:
```typescript
// Generate main init skill if any states were processed
if (allStateNames.length > 0) {
  const mainInit = generateMainInitSkill(allStateNames);
  results.push({
    inputFile: 'generated',
    outputPath: `.claude/skills/${mainInit.filename}`,
    content: mainInit.content,
    size: Buffer.byteLength(mainInit.content, 'utf8'),
  });
}
```

3. Update src/index.ts to export State and Operation:

Find the exports section and add:
```typescript
export { State, Operation } from './jsx.js';
export type { StateProps, OperationProps, SQLiteConfig } from './jsx.js';
```

Also export provider types if useful:
```typescript
export { getProvider, type ProviderTemplate, type GeneratedSkill } from './providers/index.js';
```
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors. Test by creating a simple .state.tsx file and running build.</verify>
  <done>Build command routes *.state.tsx files to state emitter, outputs multiple skills to .claude/skills/, public API exports State and Operation components.</done>
</task>

<task type="auto">
  <name>Task 3: Verify TypeScript interface to SQL schema generation</name>
  <files>(verification task - no files modified)</files>
  <action>
This task verifies SSTATE-08: TypeScript interface defines state shape for SQL schema generation.

Create a test state file to verify the full pipeline:

```typescript
// Test file: src/app/state/releases.state.tsx
import { State, Operation } from 'react-agentic';

interface ReleasesState {
  lastVersion: string;
  bumpType: 'major' | 'minor' | 'patch';
  updatedAt: string;
}

export default function ReleasesState() {
  return (
    <State<ReleasesState>
      name="releases"
      provider="sqlite"
      config={{ database: ".state/releases.db" }}
    >
      <Operation name="record">
        {`UPDATE releases SET lastVersion = '$version', bumpType = '$bump_type' WHERE rowid = 1`}
      </Operation>
    </State>
  );
}
```

Build and verify:
1. Run build: `node dist/cli/index.js build "src/app/state/releases.state.tsx"`
2. Check generated `.claude/skills/releases.init.md`
3. Verify the SQL CREATE TABLE contains:
   - `lastVersion TEXT` (string -> TEXT)
   - `bumpType TEXT CHECK(bumpType IN ('major', 'minor', 'patch'))` (union -> TEXT with CHECK)
   - `updatedAt TEXT` (string -> TEXT)

This confirms:
- TypeScript interface `ReleasesState` was parsed
- Fields were extracted: lastVersion, bumpType, updatedAt
- Type mapping worked: string -> TEXT
- Enum constraint was generated from union type
  </action>
  <verify>
1. Build succeeds without errors
2. `grep -A 20 "CREATE TABLE" .claude/skills/releases.init.md` shows correct columns
3. `ls .claude/skills/releases.*.md` shows 5 files: init, read, write, delete, record
4. Schema mapping verified: lastVersion->TEXT, bumpType->TEXT with CHECK constraint
  </verify>
  <done>TypeScript interface correctly generates SQL schema: string->TEXT, union types->TEXT with CHECK constraints, all interface fields become table columns.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors
2. `grep -n "emitState" src/emitter/state-emitter.ts src/emitter/index.ts src/cli/commands/build.ts` shows the function across files
3. `grep -n "generateMainInitSkill" src/emitter/state-emitter.ts src/cli/commands/build.ts` shows main init generation
4. `grep -n "stateDocument" src/cli/commands/build.ts` shows file type handling
5. `grep -n "State\|Operation" src/index.ts` shows public exports
6. Create test file and verify multi-file output:
   - Build a test .state.tsx file
   - Check .claude/skills/ for generated files (init, read, write, delete, custom ops)
   - Check .claude/skills/init.all.md exists and lists all state init skills
7. **SSTATE-08 verification**: Confirm TypeScript interface (ReleasesState) generates correct SQL columns
</verification>

<success_criteria>
- emitState function generates StateEmitResult with skills array
- generateMainInitSkill function creates init.all.md
- Build command detects and routes StateDocumentNode
- CRUD skills (init, read, write, delete) generated
- Custom operations generate additional skills
- Skills output to .claude/skills/{state}.{op}.md
- Main init skill (init.all.md) generated with all state init skills listed
- Public API exports State, Operation, StateProps, OperationProps
- TypeScript interface correctly maps to SQL schema (SSTATE-08)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/19-scoped-state-skills/19-04-SUMMARY.md`
</output>
