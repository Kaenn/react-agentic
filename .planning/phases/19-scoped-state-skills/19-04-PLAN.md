---
phase: 19-scoped-state-skills
plan: 04
type: execute
wave: 3
depends_on: ["19-02", "19-03"]
files_modified:
  - src/emitter/state-emitter.ts
  - src/emitter/index.ts
  - src/cli/build.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "emitState() generates multiple skill files from StateDocumentNode"
    - "Build command routes *.state.tsx files to state emitter"
    - "Generated skills output to .claude/skills/{state}.{op}.md"
    - "All CRUD skills (init, read, write, delete) are generated"
    - "Custom operations generate additional skill files"
    - "Main init skill orchestrates all discovered state init skills"
    - "Public API exports State and Operation components"
    - "TypeScript compiles without errors"
  artifacts:
    - path: "src/emitter/state-emitter.ts"
      provides: "emitState function, generateMainInitSkill function"
      exports: ["emitState", "generateMainInitSkill"]
    - path: "src/cli/build.ts"
      provides: "State file routing, main init generation"
      contains: ".state.tsx"
    - path: "src/index.ts"
      provides: "Public API exports"
      exports: ["State", "Operation"]
  key_links:
    - from: "src/emitter/state-emitter.ts"
      to: "src/providers/sqlite.ts"
      via: "Uses provider to generate skills"
      pattern: "getProvider"
    - from: "src/cli/build.ts"
      to: "src/emitter/state-emitter.ts"
      via: "Routes state files to emitter"
      pattern: "emitState"
---

<objective>
Implement state emitter and build command integration for multi-skill output.

Purpose: Complete the pipeline from State TSX to generated skill files. Each State definition produces 4+ skill files (init, read, write, delete, plus custom operations). Also generate a main init skill that orchestrates all state init skills.

Output: emitState function, build command routing for *.state.tsx, multi-file output to .claude/skills/, main init skill generation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-scoped-state-skills/19-CONTEXT.md
@.planning/phases/19-scoped-state-skills/19-RESEARCH.md
@.planning/phases/19-scoped-state-skills/19-01-SUMMARY.md
@.planning/phases/19-scoped-state-skills/19-02-SUMMARY.md
@.planning/phases/19-scoped-state-skills/19-03-SUMMARY.md
@src/emitter/emitter.ts
@src/emitter/index.ts
@src/cli/build.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state emitter</name>
  <files>src/emitter/state-emitter.ts</files>
  <action>
Create new file src/emitter/state-emitter.ts:

```typescript
/**
 * State Emitter
 *
 * Generates multiple skill files from a StateDocumentNode.
 * Uses provider templates for storage-specific code generation.
 */

import type { StateDocumentNode } from '../ir/nodes.js';
import { getProvider, type GeneratedSkill, type ProviderContext } from '../providers/index.js';

/**
 * Result of emitting a State component
 */
export interface StateEmitResult {
  /** All generated skill files */
  skills: GeneratedSkill[];
  /** State name (for main init tracking) */
  stateName: string;
}

/**
 * Emit a StateDocumentNode to multiple skill files
 *
 * Generates:
 * - {state}.init.md - Schema/table creation
 * - {state}.read.md - Read state with optional field filter
 * - {state}.write.md - Update state field
 * - {state}.delete.md - Reset state to defaults
 * - {state}.{operation}.md - Custom operations
 *
 * @param doc - The state document node from transformer
 * @returns Array of generated skill files and state name
 */
export function emitState(doc: StateDocumentNode): StateEmitResult {
  const { state } = doc;

  // Get provider template
  const provider = getProvider(state.provider);

  // Build provider context
  const ctx: ProviderContext = {
    stateName: state.name,
    database: state.config.database,
    schema: state.schema
  };

  const skills: GeneratedSkill[] = [];

  // Generate CRUD skills
  skills.push(provider.generateInit(ctx));
  skills.push(provider.generateRead(ctx));
  skills.push(provider.generateWrite(ctx));
  skills.push(provider.generateDelete(ctx));

  // Generate custom operations
  for (const operation of state.operations) {
    skills.push(provider.generateOperation(ctx, operation));
  }

  return { skills, stateName: state.name };
}

/**
 * Generate a main init skill that invokes all state init skills
 *
 * This skill allows initializing all state tables with a single command.
 *
 * @param stateNames - Array of state names that have been generated
 * @returns Generated skill for init:all
 */
export function generateMainInitSkill(stateNames: string[]): GeneratedSkill {
  const invocations = stateNames.map(name => `# Initialize ${name} state
echo "Initializing ${name}..."
# Note: Claude will invoke /${name}:init skill`).join('\n\n');

  const skillList = stateNames.map(name => `- \`/${name}:init\``).join('\n');

  const content = `---
name: init.all
description: Initialize all state tables. Run once to set up all state storage.
allowed-tools:
  - Bash(sqlite3:*)
  - Bash(mkdir:*)
---

# Initialize All State

Initialize all registered state tables in the project.

## State Skills

This skill orchestrates the following init skills:

${skillList}

## Usage

Run this skill once when setting up a new project or after adding new state definitions.

## Process

The following state tables will be initialized:

${invocations}

**Note:** This skill should invoke each state's init skill in sequence. Claude should run each \`/{state}:init\` skill listed above.
`;

  return {
    filename: 'init.all.md',
    content
  };
}
```

This is a clean separation - the emitter orchestrates skill generation, the provider does the actual code generation.
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors.</verify>
  <done>emitState function exists that generates CRUD skills plus custom operations using provider templates. generateMainInitSkill function creates orchestration skill.</done>
</task>

<task type="auto">
  <name>Task 2: Update emitter index and build command</name>
  <files>src/emitter/index.ts, src/cli/build.ts, src/index.ts</files>
  <action>
1. Add export to src/emitter/index.ts:

```typescript
export { emitState, generateMainInitSkill, type StateEmitResult } from './state-emitter.js';
```

2. Update src/cli/build.ts to handle State files.

First, add imports:
```typescript
import { emitState, generateMainInitSkill } from '../emitter/state-emitter.js';
import type { StateDocumentNode } from '../ir/nodes.js';
```

Then update the buildFile function. Find where it handles different document types and add State handling.

After the MCPConfig handling block, add:

```typescript
// Handle State files (*.state.tsx)
if (doc.kind === 'stateDocument') {
  const stateDoc = doc as StateDocumentNode;
  const result = emitState(stateDoc);

  // Write all skill files
  const outputDir = path.join(path.dirname(srcPath), '../../.claude/skills');
  const results: BuildResult[] = [];

  for (const skill of result.skills) {
    const skillPath = path.join(outputDir, skill.filename);
    await fs.mkdir(path.dirname(skillPath), { recursive: true });
    await fs.writeFile(skillPath, skill.content);
    results.push({ path: skillPath, content: skill.content });
    console.log(`  Generated: ${skill.filename}`);
  }

  return results;
}
```

Also update the file detection logic. Find where it checks file extensions and add:

```typescript
// Check for state files
const isStateFile = srcPath.endsWith('.state.tsx');
```

And update any conditionals that route file types appropriately. State files should be routed to the transformer and produce StateDocumentNode.

The output directory calculation may need adjustment - state skills go to `.claude/skills/` relative to project root. Find a reliable way to locate project root (look for package.json or .claude directory going up).

3. Update src/index.ts to export State and Operation:

Find the exports section and add:
```typescript
export { State, Operation } from './jsx.js';
export type { StateProps, OperationProps, SQLiteConfig } from './jsx.js';
```

Also export provider types if useful:
```typescript
export { getProvider, type ProviderTemplate, type GeneratedSkill } from './providers/index.js';
```
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors. Test by creating a simple .state.tsx file and running build.</verify>
  <done>Build command routes *.state.tsx files to state emitter, outputs multiple skills to .claude/skills/, public API exports State and Operation components.</done>
</task>

<task type="auto">
  <name>Task 3: Generate main init skill on build</name>
  <files>src/cli/build.ts</files>
  <action>
Update the build command to track all state names during build and generate the main init skill at the end.

1. In the build command (or buildAll function if it exists), add tracking for state names:

```typescript
// Track all state names for main init generation
const allStateNames: string[] = [];
```

2. When processing state files, collect the state name:

```typescript
if (doc.kind === 'stateDocument') {
  const stateDoc = doc as StateDocumentNode;
  const result = emitState(stateDoc);

  // Track state name for main init skill
  allStateNames.push(result.stateName);

  // ... rest of skill writing ...
}
```

3. After all files are processed, generate the main init skill if any states were found:

```typescript
// Generate main init skill if any states were processed
if (allStateNames.length > 0) {
  const mainInitSkill = generateMainInitSkill(allStateNames);
  const skillPath = path.join(outputDir, mainInitSkill.filename);
  await fs.mkdir(path.dirname(skillPath), { recursive: true });
  await fs.writeFile(skillPath, mainInitSkill.content);
  console.log(`  Generated: ${mainInitSkill.filename} (orchestrates ${allStateNames.length} state init skills)`);
}
```

If the build command processes files individually (not in batch), you may need to:
- Add a separate CLI command like `build-states` that processes all *.state.tsx files
- Or use a glob pattern and batch processing
- Or store state names in a temporary file and generate main init at the end

The key requirement from CONTEXT.md is:
> "Also auto-generate a main init command that orchestrates all state init skills"

This ensures users can run a single `/init:all` skill to initialize all state tables.
  </action>
  <verify>
1. Run `npx tsc --noEmit` - should compile without errors
2. Build multiple state files and verify `init.all.md` is generated
3. Verify `init.all.md` lists all state init skills
  </verify>
  <done>Main init skill (init.all.md) is generated during build, orchestrating all discovered state init skills.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors
2. `grep -n "emitState" src/emitter/state-emitter.ts src/emitter/index.ts src/cli/build.ts` shows the function across files
3. `grep -n "generateMainInitSkill" src/emitter/state-emitter.ts src/cli/build.ts` shows main init generation
4. `grep -n "\.state\.tsx" src/cli/build.ts` shows file type detection
5. `grep -n "State\|Operation" src/index.ts` shows public exports
6. Create test file and verify multi-file output:
   - `echo 'test' > src/app/state/test.state.tsx`
   - Run build
   - Check .claude/skills/ for generated files
   - Check .claude/skills/init.all.md exists
</verification>

<success_criteria>
- emitState function generates StateEmitResult with skills array
- generateMainInitSkill function creates init.all.md
- Build command detects *.state.tsx files
- StateDocumentNode routed to emitState
- CRUD skills (init, read, write, delete) generated
- Custom operations generate additional skills
- Skills output to .claude/skills/{state}.{op}.md
- Main init skill (init.all.md) generated with all state init skills listed
- Public API exports State, Operation, StateProps, OperationProps
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/19-scoped-state-skills/19-04-SUMMARY.md`
</output>
