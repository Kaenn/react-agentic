---
phase: 19-scoped-state-skills
plan: 04
type: execute
wave: 3
depends_on: ["19-02", "19-03"]
files_modified:
  - src/emitter/state-emitter.ts
  - src/emitter/index.ts
  - src/cli/build.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "emitState() generates multiple skill files from StateDocumentNode"
    - "Build command routes *.state.tsx files to state emitter"
    - "Generated skills output to .claude/skills/{state}.{op}.md"
    - "All CRUD skills (init, read, write, delete) are generated"
    - "Custom operations generate additional skill files"
    - "Public API exports State and Operation components"
    - "TypeScript compiles without errors"
  artifacts:
    - path: "src/emitter/state-emitter.ts"
      provides: "emitState function"
      exports: ["emitState"]
    - path: "src/cli/build.ts"
      provides: "State file routing"
      contains: ".state.tsx"
    - path: "src/index.ts"
      provides: "Public API exports"
      exports: ["State", "Operation"]
  key_links:
    - from: "src/emitter/state-emitter.ts"
      to: "src/providers/sqlite.ts"
      via: "Uses provider to generate skills"
      pattern: "getProvider"
    - from: "src/cli/build.ts"
      to: "src/emitter/state-emitter.ts"
      via: "Routes state files to emitter"
      pattern: "emitState"
---

<objective>
Implement state emitter and build command integration for multi-skill output.

Purpose: Complete the pipeline from State TSX to generated skill files. Each State definition produces 4+ skill files (init, read, write, delete, plus custom operations).

Output: emitState function, build command routing for *.state.tsx, multi-file output to .claude/skills/
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-scoped-state-skills/19-CONTEXT.md
@.planning/phases/19-scoped-state-skills/19-RESEARCH.md
@.planning/phases/19-scoped-state-skills/19-01-SUMMARY.md
@.planning/phases/19-scoped-state-skills/19-02-SUMMARY.md
@.planning/phases/19-scoped-state-skills/19-03-SUMMARY.md
@src/emitter/emitter.ts
@src/emitter/index.ts
@src/cli/build.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state emitter</name>
  <files>src/emitter/state-emitter.ts</files>
  <action>
Create new file src/emitter/state-emitter.ts:

```typescript
/**
 * State Emitter
 *
 * Generates multiple skill files from a StateDocumentNode.
 * Uses provider templates for storage-specific code generation.
 */

import type { StateDocumentNode } from '../ir/nodes.js';
import { getProvider, type GeneratedSkill, type ProviderContext } from '../providers/index.js';

/**
 * Result of emitting a State component
 */
export interface StateEmitResult {
  /** All generated skill files */
  skills: GeneratedSkill[];
}

/**
 * Emit a StateDocumentNode to multiple skill files
 *
 * Generates:
 * - {state}.init.md - Schema/table creation
 * - {state}.read.md - Read state with optional field filter
 * - {state}.write.md - Update state field
 * - {state}.delete.md - Reset state to defaults
 * - {state}.{operation}.md - Custom operations
 *
 * @param doc - The state document node from transformer
 * @returns Array of generated skill files
 */
export function emitState(doc: StateDocumentNode): StateEmitResult {
  const { state } = doc;

  // Get provider template
  const provider = getProvider(state.provider);

  // Build provider context
  const ctx: ProviderContext = {
    stateName: state.name,
    database: state.config.database,
    schema: state.schema
  };

  const skills: GeneratedSkill[] = [];

  // Generate CRUD skills
  skills.push(provider.generateInit(ctx));
  skills.push(provider.generateRead(ctx));
  skills.push(provider.generateWrite(ctx));
  skills.push(provider.generateDelete(ctx));

  // Generate custom operations
  for (const operation of state.operations) {
    skills.push(provider.generateOperation(ctx, operation));
  }

  return { skills };
}
```

This is a clean separation - the emitter orchestrates skill generation, the provider does the actual code generation.
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors.</verify>
  <done>emitState function exists that generates CRUD skills plus custom operations using provider templates.</done>
</task>

<task type="auto">
  <name>Task 2: Update emitter index and build command</name>
  <files>src/emitter/index.ts, src/cli/build.ts, src/index.ts</files>
  <action>
1. Add export to src/emitter/index.ts:

```typescript
export { emitState, type StateEmitResult } from './state-emitter.js';
```

2. Update src/cli/build.ts to handle State files.

First, add imports:
```typescript
import { emitState } from '../emitter/state-emitter.js';
import type { StateDocumentNode } from '../ir/nodes.js';
```

Then update the buildFile function. Find where it handles different document types and add State handling.

After the MCPConfig handling block, add:

```typescript
// Handle State files (*.state.tsx)
if (doc.kind === 'stateDocument') {
  const stateDoc = doc as StateDocumentNode;
  const result = emitState(stateDoc);

  // Write all skill files
  const outputDir = path.join(path.dirname(srcPath), '../../.claude/skills');
  const results: BuildResult[] = [];

  for (const skill of result.skills) {
    const skillPath = path.join(outputDir, skill.filename);
    await fs.mkdir(path.dirname(skillPath), { recursive: true });
    await fs.writeFile(skillPath, skill.content);
    results.push({ path: skillPath, content: skill.content });
    console.log(`  Generated: ${skill.filename}`);
  }

  return results;
}
```

Also update the file detection logic. Find where it checks file extensions and add:

```typescript
// Check for state files
const isStateFile = srcPath.endsWith('.state.tsx');
```

And update any conditionals that route file types appropriately. State files should be routed to the transformer and produce StateDocumentNode.

The output directory calculation may need adjustment - state skills go to `.claude/skills/` relative to project root. Find a reliable way to locate project root (look for package.json or .claude directory going up).

3. Update src/index.ts to export State and Operation:

Find the exports section and add:
```typescript
export { State, Operation } from './jsx.js';
export type { StateProps, OperationProps, SQLiteConfig } from './jsx.js';
```

Also export provider types if useful:
```typescript
export { getProvider, type ProviderTemplate, type GeneratedSkill } from './providers/index.js';
```
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors. Test by creating a simple .state.tsx file and running build.</verify>
  <done>Build command routes *.state.tsx files to state emitter, outputs multiple skills to .claude/skills/, public API exports State and Operation components.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors
2. `grep -n "emitState" src/emitter/state-emitter.ts src/emitter/index.ts src/cli/build.ts` shows the function across files
3. `grep -n "\.state\.tsx" src/cli/build.ts` shows file type detection
4. `grep -n "State\|Operation" src/index.ts` shows public exports
5. Create test file and verify multi-file output:
   - `echo 'test' > src/app/state/test.state.tsx`
   - Run build
   - Check .claude/skills/ for generated files
</verification>

<success_criteria>
- emitState function generates StateEmitResult with skills array
- Build command detects *.state.tsx files
- StateDocumentNode routed to emitState
- CRUD skills (init, read, write, delete) generated
- Custom operations generate additional skills
- Skills output to .claude/skills/{state}.{op}.md
- Public API exports State, Operation, StateProps, OperationProps
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/19-scoped-state-skills/19-04-SUMMARY.md`
</output>
