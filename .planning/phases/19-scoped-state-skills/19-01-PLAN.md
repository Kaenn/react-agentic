---
phase: 19-scoped-state-skills
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ir/nodes.ts
  - src/jsx.ts
autonomous: true

must_haves:
  truths:
    - "StateDocumentNode type exists in IR with kind discriminator"
    - "StateNode represents parsed State component with provider binding"
    - "OperationNode represents custom semantic operations"
    - "StateSchema captures flattened TypeScript interface fields"
    - "State and Operation JSX components exist with proper props"
    - "TypeScript compiles without errors"
  artifacts:
    - path: "src/ir/nodes.ts"
      provides: "StateDocumentNode, StateNode, OperationNode, StateSchema types"
      contains: "kind: 'stateDocument'"
    - path: "src/jsx.ts"
      provides: "StateProps, OperationProps, State, Operation components"
      exports: ["State", "Operation", "StateProps", "OperationProps"]
  key_links:
    - from: "src/jsx.ts"
      to: "src/ir/nodes.ts"
      via: "Type alignment for State transformation"
      pattern: "StateDocumentNode"
---

<objective>
Add IR node types and JSX component stubs for State/Operation components.

Purpose: Foundation layer for scoped state skills - defines the data structures that represent State definitions in the intermediate representation and the TypeScript types users interact with.

Output: StateDocumentNode, StateNode, OperationNode IR types, StateSchema type for parsed interfaces, State/Operation component stubs with generics
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-scoped-state-skills/19-CONTEXT.md
@.planning/phases/19-scoped-state-skills/19-RESEARCH.md
@src/ir/nodes.ts
@src/jsx.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add State IR types to nodes.ts</name>
  <files>src/ir/nodes.ts</files>
  <action>
Add new types in a new section `// State Document Nodes` before the Union Types section:

```typescript
// ============================================================================
// State Document Nodes
// ============================================================================

/**
 * Flattened state schema field
 * Represents a single column in the generated SQLite table
 */
export interface StateSchemaField {
  /** Column name (flattened path, e.g., "config_debug") */
  name: string;
  /** TypeScript type (string, number, boolean, Date) */
  tsType: string;
  /** SQL type (TEXT, INTEGER) */
  sqlType: 'TEXT' | 'INTEGER';
  /** Default value for init SQL */
  defaultValue: string;
  /** Optional: enum values for CHECK constraint */
  enumValues?: string[];
}

/**
 * Parsed state schema from TypeScript interface
 * Fields are flattened (nested objects become underscore-separated)
 */
export interface StateSchema {
  /** Interface name (e.g., "ReleasesState") */
  interfaceName: string;
  /** Flattened fields for SQL columns */
  fields: StateSchemaField[];
}

/**
 * Custom operation node
 * Represents an Operation child of State component
 */
export interface OperationNode {
  kind: 'operation';
  /** Operation name (e.g., "record") - becomes skill suffix */
  name: string;
  /** SQL template body with $variable placeholders */
  sqlTemplate: string;
  /** Inferred argument names from $variable references */
  args: string[];
}

/**
 * State node representing parsed State component
 */
export interface StateNode {
  kind: 'state';
  /** State name (e.g., "releases") - becomes skill prefix */
  name: string;
  /** Provider type (only "sqlite" for now) */
  provider: 'sqlite';
  /** Provider-specific configuration */
  config: {
    /** Database file path */
    database: string;
  };
  /** Parsed schema from generic type parameter */
  schema: StateSchema;
  /** Custom operations defined as children */
  operations: OperationNode[];
}

/**
 * State document root node
 * Produces multiple skill files in .claude/skills/
 */
export interface StateDocumentNode {
  kind: 'stateDocument';
  /** The State definition */
  state: StateNode;
}
```

Add StateDocumentNode to IRNode union:

```typescript
export type IRNode =
  | BlockNode
  | InlineNode
  | FrontmatterNode
  | AgentFrontmatterNode
  | SkillFrontmatterNode
  | SkillFileNode
  | SkillStaticNode
  | ListItemNode
  | DocumentNode
  | AgentDocumentNode
  | SkillDocumentNode
  | MCPConfigDocumentNode
  | StateDocumentNode   // Add this
  | TypeReference;
```

Note: StateNode and OperationNode are NOT added to BlockNode union - they are internal to StateDocumentNode.
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors. Grep for 'stateDocument' in nodes.ts should show the new types.</verify>
  <done>StateDocumentNode, StateNode, OperationNode, StateSchema, StateSchemaField types exist in IR with all required properties for SQLite state generation.</done>
</task>

<task type="auto">
  <name>Task 2: Add State and Operation JSX components</name>
  <files>src/jsx.ts</files>
  <action>
Add new section after State Management section (the existing useStateRef/ReadState/WriteState section). This is the new scoped state system that will eventually replace the old one:

```typescript
// ============================================================================
// Scoped State Skills (State/Operation components)
// ============================================================================

/**
 * SQLite provider configuration
 */
export interface SQLiteConfig {
  /** Database file path (e.g., ".state/state.db") */
  database: string;
}

/**
 * Props for the State component
 * @typeParam TSchema - TypeScript interface defining state shape
 */
export interface StateProps<TSchema = unknown> {
  /** State name - becomes skill prefix (e.g., "releases" -> releases.read) */
  name: string;
  /** Storage provider (only "sqlite" supported currently) */
  provider: 'sqlite';
  /** Provider-specific configuration */
  config: SQLiteConfig;
  /** Operation children */
  children?: ReactNode;
  /** Phantom type marker (compile-time only) */
  _schema?: TSchema;
}

/**
 * Props for the Operation component
 */
export interface OperationProps {
  /** Operation name - becomes skill suffix (e.g., "record" -> releases.record) */
  name: string;
  /** SQL template with $variable placeholders */
  children?: ReactNode;
}

/**
 * State component - defines a scoped state with auto-generated CRUD skills
 *
 * This is a compile-time component transformed by react-agentic.
 * It generates multiple skill files: {name}.init, {name}.read, {name}.write, {name}.delete
 *
 * @typeParam TSchema - TypeScript interface defining state shape (used for SQL schema generation)
 * @example
 * interface ReleasesState {
 *   lastVersion: string;
 *   bumpType: 'major' | 'minor' | 'patch';
 *   updatedAt: string;
 * }
 *
 * export default function ReleasesState() {
 *   return (
 *     <State<ReleasesState>
 *       name="releases"
 *       provider="sqlite"
 *       config={{ database: ".state/state.db" }}
 *     >
 *       <Operation name="record">
 *         {`UPDATE releases SET lastVersion = '$version', bumpType = '$bump_type' WHERE rowid = 1`}
 *       </Operation>
 *     </State>
 *   );
 * }
 */
export function State<TSchema = unknown>(_props: StateProps<TSchema>): null {
  return null;
}

/**
 * Operation component - defines a custom semantic operation on state
 *
 * This is a compile-time component. Must be a child of State.
 * Generates a custom skill at .claude/skills/{state-name}.{operation-name}.md
 *
 * The SQL template in children can use $variable placeholders that become CLI arguments.
 * Arguments are inferred from $variable patterns in the SQL.
 *
 * @example
 * <Operation name="record">
 *   {`UPDATE releases SET lastVersion = '$version', bumpType = '$bump_type' WHERE rowid = 1`}
 * </Operation>
 * // Generates skill with --version and --bump-type arguments
 */
export function Operation(_props: OperationProps): null {
  return null;
}
```

Place this new section AFTER the existing State Management section (useStateRef/ReadState/WriteState) and BEFORE MCP Server Configuration section.
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors. Grep for 'State<' in jsx.ts should show the new generic component.</verify>
  <done>StateProps, OperationProps interfaces and State, Operation component stubs exist with full JSDoc documentation and generic type parameter support.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors
2. `grep -n "stateDocument\|StateDocument" src/ir/nodes.ts` shows StateDocumentNode type
3. `grep -n "StateProps\|OperationProps" src/jsx.ts` shows both interfaces
4. `grep -n "export function State\|export function Operation" src/jsx.ts` shows both components
5. Both files have appropriate JSDoc documentation
</verification>

<success_criteria>
- StateDocumentNode IR type with kind: 'stateDocument' discriminator
- StateNode with name, provider, config, schema, operations
- OperationNode with name, sqlTemplate, args
- StateSchema with interfaceName and flattened fields
- StateSchemaField with name, tsType, sqlType, defaultValue, enumValues
- State<TSchema> and Operation JSX components
- TypeScript compiles without errors
- Full JSDoc documentation with examples
</success_criteria>

<output>
After completion, create `.planning/phases/19-scoped-state-skills/19-01-SUMMARY.md`
</output>
