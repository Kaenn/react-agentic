---
phase: 19-scoped-state-skills
plan: 03
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - src/parser/transformer.ts
  - src/parser/parser.ts
autonomous: true

must_haves:
  truths:
    - "transformState() parses State component props and generic type"
    - "transformOperation() parses Operation children and extracts SQL template"
    - "Schema extraction flattens nested TypeScript interface to underscore columns"
    - "Type mapping converts string->TEXT, number->INTEGER, boolean->INTEGER"
    - "Argument inference extracts $variable patterns from SQL template"
    - "TypeScript compiles without errors"
  artifacts:
    - path: "src/parser/transformer.ts"
      provides: "transformState, transformOperation methods"
      contains: "transformState"
    - path: "src/parser/parser.ts"
      provides: "Schema extraction helpers"
      contains: "extractStateSchema"
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/ir/nodes.ts"
      via: "Creates StateDocumentNode from State JSX"
      pattern: "StateDocumentNode"
---

<objective>
Implement State component parsing and schema extraction in transformer.

Purpose: Parse `<State>` JSX components, extract schema from generic type parameter, flatten nested interfaces, and transform to StateDocumentNode IR.

Output: transformState method, schema extraction with type mapping, Operation parsing with argument inference
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-scoped-state-skills/19-CONTEXT.md
@.planning/phases/19-scoped-state-skills/19-RESEARCH.md
@.planning/phases/19-scoped-state-skills/19-01-SUMMARY.md
@src/parser/transformer.ts
@src/parser/parser.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add schema extraction helpers to parser.ts</name>
  <files>src/parser/parser.ts</files>
  <action>
Add new functions for State schema extraction at the end of parser.ts:

```typescript
// ============================================================================
// State Schema Extraction
// ============================================================================

import type { StateSchema, StateSchemaField } from '../ir/nodes.js';

/**
 * Map TypeScript type to SQL type
 */
function mapTsTypeToSql(tsType: string): 'TEXT' | 'INTEGER' {
  switch (tsType) {
    case 'number':
      return 'INTEGER';
    case 'boolean':
      return 'INTEGER';  // 0/1
    default:
      return 'TEXT';  // string, Date, enums, etc.
  }
}

/**
 * Get default value for a type
 */
function getDefaultValue(tsType: string, sqlType: 'TEXT' | 'INTEGER'): string {
  if (sqlType === 'INTEGER') {
    return '0';
  }
  return '';  // Empty string for TEXT
}

/**
 * Extract enum values from union type
 * 'major' | 'minor' | 'patch' -> ['major', 'minor', 'patch']
 */
function extractEnumValues(typeText: string): string[] | undefined {
  // Match pattern like "'value1' | 'value2' | 'value3'"
  const matches = typeText.match(/'([^']+)'/g);
  if (matches && matches.length > 1) {
    return matches.map(m => m.replace(/'/g, ''));
  }
  return undefined;
}

/**
 * Flatten interface properties into schema fields
 * Handles nested objects with underscore separation
 *
 * @param sourceFile - Source file containing the interface
 * @param interfaceName - Name of the interface to extract
 * @param prefix - Path prefix for nested properties (e.g., "config_")
 */
export function extractStateSchema(
  sourceFile: SourceFile,
  interfaceName: string
): StateSchema | undefined {
  const fields: StateSchemaField[] = [];

  // Find the interface declaration
  const interfaceDecl = sourceFile.getInterface(interfaceName);
  if (!interfaceDecl) {
    return undefined;
  }

  // Recursive helper to flatten nested properties
  function processProperties(
    properties: ReturnType<typeof interfaceDecl.getProperties>,
    prefix: string = ''
  ): void {
    for (const prop of properties) {
      const propName = prop.getName();
      const typeNode = prop.getTypeNode();
      const fullName = prefix ? `${prefix}_${propName}` : propName;

      if (!typeNode) continue;

      const typeText = typeNode.getText();

      // Check if this is a nested object type (TypeLiteral or interface reference)
      if (Node.isTypeLiteral(typeNode)) {
        // Inline object type: { debug: boolean; timeout: number; }
        const nestedProps = typeNode.getProperties();
        // Process nested properties with updated prefix
        for (const nestedProp of nestedProps) {
          const nestedName = nestedProp.getName();
          const nestedType = nestedProp.getTypeNode();
          if (!nestedType) continue;

          const nestedTypeText = nestedType.getText();
          const nestedFullName = `${fullName}_${nestedName}`;

          // For now, only go one level deep (can extend later)
          const tsType = nestedTypeText.includes('|') ? 'string' : nestedTypeText;
          const sqlType = mapTsTypeToSql(tsType);
          const enumValues = extractEnumValues(nestedTypeText);

          fields.push({
            name: nestedFullName,
            tsType,
            sqlType,
            defaultValue: getDefaultValue(tsType, sqlType),
            enumValues
          });
        }
      } else {
        // Simple type
        const tsType = typeText.includes('|') ? 'string' : typeText;
        const sqlType = mapTsTypeToSql(tsType);
        const enumValues = extractEnumValues(typeText);

        fields.push({
          name: fullName,
          tsType,
          sqlType,
          defaultValue: getDefaultValue(tsType, sqlType),
          enumValues
        });
      }
    }
  }

  processProperties(interfaceDecl.getProperties());

  return {
    interfaceName,
    fields
  };
}

/**
 * Extract $variable arguments from SQL template
 * Returns unique argument names without the $ prefix
 */
export function extractSqlArguments(sqlTemplate: string): string[] {
  const regex = /\$([a-z_][a-z0-9_]*)/gi;
  const args = new Set<string>();
  let match;
  while ((match = regex.exec(sqlTemplate)) !== null) {
    args.add(match[1].toLowerCase());
  }
  return Array.from(args);
}
```

Add `Node` to the imports from ts-morph if not already present.
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors. Grep for 'extractStateSchema' in parser.ts.</verify>
  <done>extractStateSchema and extractSqlArguments functions exist with type mapping, nested object flattening, and enum extraction.</done>
</task>

<task type="auto">
  <name>Task 2: Add State transformation to transformer.ts</name>
  <files>src/parser/transformer.ts</files>
  <action>
1. Add imports at top of transformer.ts:

```typescript
import type {
  // ... existing imports ...
  StateDocumentNode,
  StateNode,
  OperationNode,
  StateSchema,
} from '../ir/index.js';

import { extractStateSchema, extractSqlArguments } from './parser.js';
```

2. Add 'State' and 'Operation' to SPECIAL_COMPONENTS Set.

3. Add transformState method to Transformer class:

```typescript
/**
 * Transform a State component into StateDocumentNode
 */
private transformState(node: JsxElement | JsxSelfClosingElement): StateDocumentNode {
  const opening = Node.isJsxElement(node) ? node.getOpeningElement() : node;

  // Extract required props
  const name = getAttributeValue(opening, 'name');
  if (!name) {
    throw this.createError('State component requires name prop', node);
  }

  const provider = getAttributeValue(opening, 'provider');
  if (provider !== 'sqlite') {
    throw this.createError('State component only supports provider="sqlite"', node);
  }

  // Extract config prop (object literal)
  const configAttr = opening.getAttribute('config');
  let database = '.state/state.db';  // default
  if (configAttr && Node.isJsxAttribute(configAttr)) {
    const init = configAttr.getInitializer();
    if (init && Node.isJsxExpression(init)) {
      const expr = init.getExpression();
      if (expr && Node.isObjectLiteralExpression(expr)) {
        for (const prop of expr.getProperties()) {
          if (Node.isPropertyAssignment(prop)) {
            const propName = prop.getName();
            if (propName === 'database') {
              const propInit = prop.getInitializer();
              if (propInit && Node.isStringLiteral(propInit)) {
                database = propInit.getLiteralValue();
              }
            }
          }
        }
      }
    }
  }

  // Extract schema from generic type parameter
  let schema: StateSchema = { interfaceName: 'unknown', fields: [] };
  if (this.sourceFile) {
    const typeArgs = extractTypeArguments(opening);
    if (typeArgs.length > 0) {
      const schemaTypeName = typeArgs[0];
      const extracted = extractStateSchema(this.sourceFile, schemaTypeName);
      if (extracted) {
        schema = extracted;
      } else {
        console.warn(`Warning: Could not find interface ${schemaTypeName} in source file`);
      }
    }
  }

  // Extract Operation children
  const operations: OperationNode[] = [];
  if (Node.isJsxElement(node)) {
    for (const child of node.getJsxChildren()) {
      if (Node.isJsxElement(child) || Node.isJsxSelfClosingElement(child)) {
        const childName = getElementName(child);
        if (childName === 'Operation') {
          operations.push(this.transformOperation(child));
        }
      }
    }
  }

  const stateNode: StateNode = {
    kind: 'state',
    name,
    provider: 'sqlite',
    config: { database },
    schema,
    operations
  };

  return {
    kind: 'stateDocument',
    state: stateNode
  };
}

/**
 * Transform an Operation component into OperationNode
 */
private transformOperation(node: JsxElement | JsxSelfClosingElement): OperationNode {
  const opening = Node.isJsxElement(node) ? node.getOpeningElement() : node;

  // Extract required name prop
  const name = getAttributeValue(opening, 'name');
  if (!name) {
    throw this.createError('Operation component requires name prop', node);
  }

  // Extract SQL template from children
  let sqlTemplate = '';
  if (Node.isJsxElement(node)) {
    sqlTemplate = extractText(node).trim();
  }

  // Infer arguments from $variable patterns in SQL
  const args = extractSqlArguments(sqlTemplate);

  return {
    kind: 'operation',
    name,
    sqlTemplate,
    args
  };
}
```

4. Update the transform() method to handle State at root level (similar to Command/Agent/Skill/MCPConfig):

In the transform() method, after the MCPConfig check:

```typescript
if (name === 'State') {
  return this.transformState(node);
}
```

But wait - StateDocumentNode is not in the return type union of transform(). Update the return type:

```typescript
transform(node: JsxElement | JsxSelfClosingElement | JsxFragment, sourceFile?: SourceFile): DocumentNode | AgentDocumentNode | SkillDocumentNode | MCPConfigDocumentNode | StateDocumentNode {
```
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors. Test with a simple State TSX file to verify parsing.</verify>
  <done>transformState and transformOperation methods exist, schema extraction from generic type works, Operation children are parsed with argument inference from SQL templates.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors
2. `grep -n "transformState\|transformOperation" src/parser/transformer.ts` shows both methods
3. `grep -n "extractStateSchema\|extractSqlArguments" src/parser/parser.ts` shows both helpers
4. 'State' and 'Operation' are in SPECIAL_COMPONENTS set
5. transform() method return type includes StateDocumentNode
</verification>

<success_criteria>
- transformState method parses State component props (name, provider, config)
- Schema extraction from generic type parameter
- Type mapping: string->TEXT, number->INTEGER, boolean->INTEGER
- Nested object flattening with underscore separation (one level deep)
- Enum value extraction from union types
- transformOperation method parses Operation children
- SQL argument inference from $variable patterns
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/19-scoped-state-skills/19-03-SUMMARY.md`
</output>
