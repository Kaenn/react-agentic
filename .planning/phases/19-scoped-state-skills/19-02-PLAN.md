---
phase: 19-scoped-state-skills
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/providers/index.ts
  - src/providers/sqlite.ts
autonomous: true

must_haves:
  truths:
    - "Provider generates 4 CRUD skills (init, read, write, delete) from StateDocumentNode"
    - "Generated skills produce valid bash that executes without syntax errors"
    - "Custom operations generate working skill files with correct argument parsing"
    - "Running generated init skill creates SQLite table successfully"
    - "TypeScript compiles without errors"
  artifacts:
    - path: "src/providers/index.ts"
      provides: "ProviderTemplate interface, provider registry"
      exports: ["ProviderTemplate", "getProvider"]
    - path: "src/providers/sqlite.ts"
      provides: "SQLiteProvider implementation"
      exports: ["SQLiteProvider"]
  key_links:
    - from: "src/providers/sqlite.ts"
      to: "src/providers/index.ts"
      via: "Implements ProviderTemplate interface"
      pattern: "implements ProviderTemplate"
---

<objective>
Create provider template system with SQLite implementation.

Purpose: Abstract code generation through provider-specific templates. Each provider knows how to generate init, read, write, delete, and custom operation skills.

Output: ProviderTemplate interface, SQLiteProvider class with bash/sqlite3 code generation, SQL escaping helpers
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/19-scoped-state-skills/19-CONTEXT.md
@.planning/phases/19-scoped-state-skills/19-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create provider base types and registry</name>
  <files>src/providers/index.ts</files>
  <action>
Create new directory `src/providers/` and add index.ts:

```typescript
/**
 * Provider Template System
 *
 * Abstracts code generation for different storage backends.
 * Each provider generates bash/SQL skills for state operations.
 */

import type { StateSchema, OperationNode } from '../ir/nodes.js';

/**
 * Generated skill content
 */
export interface GeneratedSkill {
  /** Skill filename (e.g., "releases.read.md") */
  filename: string;
  /** Full markdown content for the skill file */
  content: string;
}

/**
 * Provider configuration passed to generators
 */
export interface ProviderContext {
  /** State name (e.g., "releases") */
  stateName: string;
  /** Database path from config */
  database: string;
  /** Parsed schema with flattened fields */
  schema: StateSchema;
}

/**
 * Provider template interface
 *
 * Each provider implements these methods to generate
 * storage-specific skill code.
 */
export interface ProviderTemplate {
  /** Provider identifier */
  readonly name: string;

  /**
   * Generate init skill - creates schema/table
   */
  generateInit(ctx: ProviderContext): GeneratedSkill;

  /**
   * Generate read skill - SELECT with optional field filter
   */
  generateRead(ctx: ProviderContext): GeneratedSkill;

  /**
   * Generate write skill - UPDATE field with value
   */
  generateWrite(ctx: ProviderContext): GeneratedSkill;

  /**
   * Generate delete skill - DELETE/reset state
   */
  generateDelete(ctx: ProviderContext): GeneratedSkill;

  /**
   * Generate custom operation skill
   */
  generateOperation(ctx: ProviderContext, operation: OperationNode): GeneratedSkill;
}

// Provider registry
const providers = new Map<string, ProviderTemplate>();

/**
 * Register a provider template
 */
export function registerProvider(provider: ProviderTemplate): void {
  providers.set(provider.name, provider);
}

/**
 * Get a provider by name
 * @throws Error if provider not registered
 */
export function getProvider(name: string): ProviderTemplate {
  const provider = providers.get(name);
  if (!provider) {
    throw new Error(`Unknown provider: ${name}. Available: ${Array.from(providers.keys()).join(', ')}`);
  }
  return provider;
}

// Re-export SQLite provider (registers itself on import)
export { SQLiteProvider } from './sqlite.js';
```

This establishes the pattern for provider-agnostic skill generation.
  </action>
  <verify>File exists at src/providers/index.ts. TypeScript compiles (may have import error for sqlite.js until task 2).</verify>
  <done>ProviderTemplate interface exists with all required methods, provider registry with registerProvider and getProvider functions.</done>
</task>

<task type="auto">
  <name>Task 2: Implement SQLite provider</name>
  <files>src/providers/sqlite.ts</files>
  <action>
Create src/providers/sqlite.ts with full SQLite skill generation:

```typescript
/**
 * SQLite Provider
 *
 * Generates bash/sqlite3 CLI skills for state operations.
 * All skills output JSON and use proper SQL escaping.
 */

import type { StateSchema, StateSchemaField, OperationNode } from '../ir/nodes.js';
import { registerProvider, type ProviderTemplate, type ProviderContext, type GeneratedSkill } from './index.js';

/**
 * Escape a value for SQL single-quoted string
 * Doubles single quotes: O'Brien -> O''Brien
 */
function escapeSql(value: string): string {
  return value.replace(/'/g, "''");
}

/**
 * Convert arg name to CLI flag format
 * bump_type -> --bump-type
 */
function toCliFlag(arg: string): string {
  return '--' + arg.replace(/_/g, '-');
}

/**
 * Convert CLI flag back to shell variable
 * --bump-type -> BUMP_TYPE
 */
function toShellVar(arg: string): string {
  return arg.toUpperCase();
}

/**
 * Generate skill frontmatter
 */
function frontmatter(name: string, description: string, tools: string[]): string {
  const toolsYaml = tools.map(t => `  - ${t}`).join('\n');
  return `---
name: ${name}
description: ${description}
allowed-tools:
${toolsYaml}
---`;
}

/**
 * Generate argument parsing bash code
 */
function argParser(args: string[]): string {
  if (args.length === 0) return '';

  const varInits = args.map(arg => `${toShellVar(arg)}=""`).join('\n');
  const cases = args.map(arg =>
    `    ${toCliFlag(arg)}) ${toShellVar(arg)}="$2"; shift 2 ;;`
  ).join('\n');

  return `# Parse arguments
${varInits}
while [[ $# -gt 0 ]]; do
  case $1 in
${cases}
    *) shift ;;
  esac
done`;
}

/**
 * Generate table existence check
 */
function tableCheck(stateName: string, db: string): string {
  return `# Check table exists
if ! sqlite3 "$DB" "SELECT 1 FROM ${stateName} LIMIT 1" 2>/dev/null; then
  echo '{"error": "State not initialized. Run /${stateName}:init first"}'
  exit 1
fi`;
}

/**
 * SQLite provider implementation
 */
export class SQLiteProvider implements ProviderTemplate {
  readonly name = 'sqlite';

  generateInit(ctx: ProviderContext): GeneratedSkill {
    const { stateName, database, schema } = ctx;

    // Generate CREATE TABLE columns
    const columns = schema.fields.map(f => {
      let def = `  ${f.name} ${f.sqlType}`;
      if (f.defaultValue) {
        def += ` DEFAULT ${f.sqlType === 'TEXT' ? `'${escapeSql(f.defaultValue)}'` : f.defaultValue}`;
      }
      if (f.enumValues && f.enumValues.length > 0) {
        const checks = f.enumValues.map(v => `'${escapeSql(v)}'`).join(', ');
        def += ` CHECK(${f.name} IN (${checks}))`;
      }
      return def;
    }).join(',\n');

    const content = `${frontmatter(
      `${stateName}.init`,
      `Initialize ${stateName} state table. Run once before using ${stateName} state.`,
      ['Bash(sqlite3:*)', 'Bash(mkdir:*)']
    )}

# Initialize ${stateName.charAt(0).toUpperCase() + stateName.slice(1)} State

Create the SQLite table for ${stateName} state.

## Process

\`\`\`bash
mkdir -p "$(dirname "${database}")"
sqlite3 "${database}" <<'SQL'
CREATE TABLE IF NOT EXISTS ${stateName} (
${columns}
);
-- Insert default row if not exists
INSERT OR IGNORE INTO ${stateName} (rowid) VALUES (1);
SQL
echo '{"status": "initialized", "table": "${stateName}"}'
\`\`\`
`;

    return {
      filename: `${stateName}.init.md`,
      content
    };
  }

  generateRead(ctx: ProviderContext): GeneratedSkill {
    const { stateName, database } = ctx;

    const content = `${frontmatter(
      `${stateName}.read`,
      `Read ${stateName} state. Returns current state as JSON.`,
      ['Bash(sqlite3:*)']
    )}

# Read ${stateName.charAt(0).toUpperCase() + stateName.slice(1)} State

Read the current ${stateName} state from SQLite.

## Arguments

- \`--field {name}\`: Optional field to read (e.g., \`lastVersion\`)

## Process

\`\`\`bash
DB="${database}"

# Parse arguments
FIELD=""
while [[ $# -gt 0 ]]; do
  case $1 in
    --field) FIELD="$2"; shift 2 ;;
    *) shift ;;
  esac
done

${tableCheck(stateName, database)}

# Read state
if [ -z "$FIELD" ]; then
  sqlite3 -json "$DB" "SELECT * FROM ${stateName} WHERE rowid = 1" | jq '.[0]'
else
  sqlite3 -json "$DB" "SELECT $FIELD FROM ${stateName} WHERE rowid = 1" | jq ".[0].$FIELD"
fi
\`\`\`
`;

    return {
      filename: `${stateName}.read.md`,
      content
    };
  }

  generateWrite(ctx: ProviderContext): GeneratedSkill {
    const { stateName, database } = ctx;

    const content = `${frontmatter(
      `${stateName}.write`,
      `Write to ${stateName} state. Updates fields in state.`,
      ['Bash(sqlite3:*)']
    )}

# Write ${stateName.charAt(0).toUpperCase() + stateName.slice(1)} State

Update ${stateName} state fields in SQLite.

## Arguments

- \`--field {name}\`: Field to update (e.g., \`lastVersion\`)
- \`--value {val}\`: Value to set

## Process

\`\`\`bash
DB="${database}"

# Parse arguments
FIELD=""
VALUE=""
while [[ $# -gt 0 ]]; do
  case $1 in
    --field) FIELD="$2"; shift 2 ;;
    --value) VALUE="$2"; shift 2 ;;
    *) shift ;;
  esac
done

# Validate
if [ -z "$FIELD" ] || [ -z "$VALUE" ]; then
  echo '{"error": "Both --field and --value required"}'
  exit 1
fi

${tableCheck(stateName, database)}

# Escape value for SQL (double single quotes)
SAFE_VALUE=$(printf '%s' "$VALUE" | sed "s/'/''/g")

# Update and return new state
sqlite3 "$DB" "UPDATE ${stateName} SET $FIELD = '$SAFE_VALUE' WHERE rowid = 1"
sqlite3 -json "$DB" "SELECT * FROM ${stateName} WHERE rowid = 1" | jq '.[0]'
\`\`\`
`;

    return {
      filename: `${stateName}.write.md`,
      content
    };
  }

  generateDelete(ctx: ProviderContext): GeneratedSkill {
    const { stateName, database, schema } = ctx;

    // Generate default values for reset
    const resets = schema.fields.map(f => {
      const val = f.sqlType === 'TEXT' ? `'${escapeSql(f.defaultValue || '')}'` : (f.defaultValue || '0');
      return `${f.name} = ${val}`;
    }).join(', ');

    const content = `${frontmatter(
      `${stateName}.delete`,
      `Reset ${stateName} state to defaults.`,
      ['Bash(sqlite3:*)']
    )}

# Reset ${stateName.charAt(0).toUpperCase() + stateName.slice(1)} State

Reset ${stateName} state to default values.

## Process

\`\`\`bash
DB="${database}"

${tableCheck(stateName, database)}

# Reset to defaults
sqlite3 "$DB" "UPDATE ${stateName} SET ${resets} WHERE rowid = 1"
sqlite3 -json "$DB" "SELECT * FROM ${stateName} WHERE rowid = 1" | jq '.[0]'
\`\`\`
`;

    return {
      filename: `${stateName}.delete.md`,
      content
    };
  }

  generateOperation(ctx: ProviderContext, operation: OperationNode): GeneratedSkill {
    const { stateName, database } = ctx;
    const { name, sqlTemplate, args } = operation;

    // Generate argument docs
    const argDocs = args.map(arg =>
      `- \`${toCliFlag(arg)} {value}\`: ${arg.replace(/_/g, ' ')}`
    ).join('\n');

    // Generate argument parser
    const parser = argParser(args);

    // Generate SQL with shell variable substitution
    // Replace $arg with shell variable interpolation
    let sqlWithVars = sqlTemplate;
    for (const arg of args) {
      // Replace $arg with escaped shell variable
      const regex = new RegExp(`\\$${arg}`, 'g');
      sqlWithVars = sqlWithVars.replace(regex, `'$SAFE_${toShellVar(arg)}'`);
    }

    // Generate escaping for each arg
    const escapes = args.map(arg =>
      `SAFE_${toShellVar(arg)}=$(printf '%s' "$${toShellVar(arg)}" | sed "s/'/''/g")`
    ).join('\n');

    const content = `${frontmatter(
      `${stateName}.${name}`,
      `${name.charAt(0).toUpperCase() + name.slice(1)} operation on ${stateName} state.`,
      ['Bash(sqlite3:*)']
    )}

# ${name.charAt(0).toUpperCase() + name.slice(1)} ${stateName.charAt(0).toUpperCase() + stateName.slice(1)}

Custom operation on ${stateName} state.

## Arguments

${argDocs || '(no arguments)'}

## Process

\`\`\`bash
DB="${database}"

${parser}

${tableCheck(stateName, database)}

# Escape values for SQL
${escapes || '# (no escaping needed)'}

# Execute operation
sqlite3 "$DB" "${sqlWithVars.trim()}"
sqlite3 -json "$DB" "SELECT * FROM ${stateName} WHERE rowid = 1" | jq '.[0]'
\`\`\`
`;

    return {
      filename: `${stateName}.${name}.md`,
      content
    };
  }
}

// Register SQLite provider
registerProvider(new SQLiteProvider());
```

This implements the full SQLite provider with:
- SQL escaping to prevent injection
- Argument parsing with CLI flags
- Table existence checks
- JSON output via sqlite3 -json and jq
- Custom operation support with variable extraction
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors. Files exist in src/providers/.</verify>
  <done>SQLiteProvider implements all ProviderTemplate methods, generates bash/sqlite3 skills with proper escaping, JSON output, and argument handling.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors
2. `ls src/providers/` shows index.ts and sqlite.ts
3. `grep -n "ProviderTemplate" src/providers/index.ts` shows interface definition
4. `grep -n "generateInit\|generateRead\|generateWrite" src/providers/sqlite.ts` shows all methods
5. Code has proper escaping logic (search for `escapeSql` or `sed "s/'/''/g"`)
</verification>

<success_criteria>
- ProviderTemplate interface with 5 generate methods
- Provider registry with registerProvider and getProvider
- SQLiteProvider implementing all methods
- Generated skills use sqlite3 CLI with JSON output
- SQL escaping prevents injection
- Argument parsing for custom operations
- Table existence checks with helpful error messages
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/19-scoped-state-skills/19-02-SUMMARY.md`
</output>
