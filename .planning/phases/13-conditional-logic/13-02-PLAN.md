---
phase: 13-conditional-logic
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/parser/transformer.ts
autonomous: true

must_haves:
  truths:
    - "If element transforms to IfNode with test prop extracted"
    - "If children become IfNode.children array"
    - "Else sibling to If transforms to ElseNode"
    - "Standalone Else throws error"
    - "Whitespace between If/Else does not break sibling detection"
  artifacts:
    - path: "src/parser/transformer.ts"
      provides: "transformIf, transformElse methods and sibling detection"
      contains: "transformIf"
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/ir/nodes.ts"
      via: "Returns IfNode and ElseNode"
      pattern: "kind: 'if'"
---

<objective>
Implement transformer logic for If/Else components with sibling detection.

Purpose: Parse `<If test="condition">...</If>` and `<Else>...</Else>` JSX elements, transforming them to IfNode and ElseNode IR nodes. Handle the sibling relationship where Else follows If, with proper whitespace handling between elements.

Output: Working transformIf and transformElse methods, sibling detection logic, proper error handling for standalone Else.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-conditional-logic/13-RESEARCH.md
@.planning/phases/13-conditional-logic/13-01-SUMMARY.md

@src/parser/transformer.ts
@src/ir/nodes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add If/Else to SPECIAL_COMPONENTS and transformElement</name>
  <files>src/parser/transformer.ts</files>
  <action>
1. Add import for IfNode and ElseNode to the existing type imports:

```typescript
import type {
  // ... existing imports ...
  IfNode,
  ElseNode,
} from '../ir/index.js';
```

2. Update SPECIAL_COMPONENTS set to include If and Else:

```typescript
const SPECIAL_COMPONENTS = new Set(['Command', 'Markdown', 'XmlBlock', 'Agent', 'SpawnAgent', 'Assign', 'If', 'Else']);
```

3. Add handling in transformElement method (after the Assign case, before the custom component check):

```typescript
// If component
if (name === 'If') {
  return this.transformIf(node);
}

// Else component - standalone is an error
if (name === 'Else') {
  throw this.createError('<Else> must follow <If> as sibling', node);
}
```

Note: Else sibling detection happens at the parent level, not in transformElement. The check here catches standalone Else that wasn't paired.
  </action>
  <verify>
Run `npx tsc --noEmit` - should fail because transformIf doesn't exist yet.
Verify SPECIAL_COMPONENTS: `grep "SPECIAL_COMPONENTS" src/parser/transformer.ts`
  </verify>
  <done>SPECIAL_COMPONENTS includes 'If' and 'Else'. transformElement has cases for both. Else throws descriptive error when encountered standalone.</done>
</task>

<task type="auto">
  <name>Task 2: Implement transformIf method</name>
  <files>src/parser/transformer.ts</files>
  <action>
Add the transformIf method to the Transformer class (after transformAssign):

```typescript
/**
 * Transform an If element to IfNode
 * If is a block-level element that emits prose-based conditionals
 */
private transformIf(node: JsxElement | JsxSelfClosingElement): IfNode {
  const openingElement = Node.isJsxElement(node)
    ? node.getOpeningElement()
    : node;

  // Extract test prop (required)
  const test = getAttributeValue(openingElement, 'test');
  if (!test) {
    throw this.createError('If requires test prop', openingElement);
  }

  // Transform children as "then" block
  const children: BlockNode[] = [];
  if (Node.isJsxElement(node)) {
    for (const child of node.getJsxChildren()) {
      const block = this.transformToBlock(child);
      if (block) children.push(block);
    }
  }

  return {
    kind: 'if',
    test,
    children,
  };
}
```

The method:
1. Extracts the required `test` prop (string shell expression)
2. Throws clear error if test is missing
3. Transforms children using existing transformToBlock
4. Returns IfNode with kind discriminator

Note: Nested If within children is handled automatically via transformToBlock -> transformElement -> transformIf recursion.
  </action>
  <verify>
Run `npx tsc --noEmit` - should still fail (transformElse missing).
Check method exists: `grep "transformIf" src/parser/transformer.ts`
  </verify>
  <done>transformIf method extracts test prop, transforms children, returns IfNode with correct structure.</done>
</task>

<task type="auto">
  <name>Task 3: Implement transformElse and sibling detection</name>
  <files>src/parser/transformer.ts</files>
  <action>
1. Add transformElse method to the Transformer class:

```typescript
/**
 * Transform an Else element to ElseNode
 * Else is a block-level element that provides "otherwise" content
 */
private transformElse(node: JsxElement | JsxSelfClosingElement): ElseNode {
  // Transform children as "else" block
  const children: BlockNode[] = [];
  if (Node.isJsxElement(node)) {
    for (const child of node.getJsxChildren()) {
      const block = this.transformToBlock(child);
      if (block) children.push(block);
    }
  }

  return {
    kind: 'else',
    children,
  };
}
```

2. Modify transformCommand and transformAgent children processing to detect If/Else siblings. Find the loop that processes children:

```typescript
// Transform children as body blocks
const children: BlockNode[] = [];
if (Node.isJsxElement(node)) {
  const jsxChildren = node.getJsxChildren();
  let i = 0;
  while (i < jsxChildren.length) {
    const child = jsxChildren[i];

    // Skip whitespace-only text
    if (Node.isJsxText(child)) {
      const text = extractText(child);
      if (!text) {
        i++;
        continue;
      }
    }

    if (Node.isJsxElement(child) || Node.isJsxSelfClosingElement(child)) {
      const childName = getElementName(child);

      if (childName === 'If') {
        // Transform If
        const ifNode = this.transformIf(child);
        children.push(ifNode);

        // Check for Else sibling
        let nextIndex = i + 1;
        while (nextIndex < jsxChildren.length) {
          const sibling = jsxChildren[nextIndex];
          // Skip whitespace-only text
          if (Node.isJsxText(sibling)) {
            const text = extractText(sibling);
            if (!text) {
              nextIndex++;
              continue;
            }
          }
          // Check if next non-whitespace is Else
          if ((Node.isJsxElement(sibling) || Node.isJsxSelfClosingElement(sibling))
              && getElementName(sibling) === 'Else') {
            const elseNode = this.transformElse(sibling);
            children.push(elseNode);
            i = nextIndex; // Skip past Else
          }
          break;
        }
      } else {
        const block = this.transformToBlock(child);
        if (block) children.push(block);
      }
    } else {
      const block = this.transformToBlock(child);
      if (block) children.push(block);
    }

    i++;
  }
}
```

IMPORTANT: This sibling detection pattern needs to be applied in:
- transformCommand (children loop)
- transformAgent (children loop)
- transformXmlBlock (children loop)
- transformBlockquote (children loop)
- Any other method that processes block children

The simplest approach is to create a helper method `transformBlockChildren` that encapsulates this logic and use it everywhere. Update the existing simple for-loops to use this helper.

3. Create the helper method:

```typescript
/**
 * Transform JSX children to BlockNodes, handling If/Else sibling pairs
 */
private transformBlockChildren(jsxChildren: Node[]): BlockNode[] {
  const blocks: BlockNode[] = [];
  let i = 0;

  while (i < jsxChildren.length) {
    const child = jsxChildren[i];

    // Skip whitespace-only text
    if (Node.isJsxText(child)) {
      const text = extractText(child);
      if (!text) {
        i++;
        continue;
      }
    }

    if (Node.isJsxElement(child) || Node.isJsxSelfClosingElement(child)) {
      const childName = getElementName(child);

      if (childName === 'If') {
        // Transform If
        const ifNode = this.transformIf(child);
        blocks.push(ifNode);

        // Check for Else sibling
        let nextIndex = i + 1;
        while (nextIndex < jsxChildren.length) {
          const sibling = jsxChildren[nextIndex];
          // Skip whitespace-only text
          if (Node.isJsxText(sibling)) {
            const text = extractText(sibling);
            if (!text) {
              nextIndex++;
              continue;
            }
          }
          // Check if next non-whitespace is Else
          if ((Node.isJsxElement(sibling) || Node.isJsxSelfClosingElement(sibling))
              && getElementName(sibling) === 'Else') {
            const elseNode = this.transformElse(sibling);
            blocks.push(elseNode);
            i = nextIndex; // Skip past Else in outer loop
          }
          break;
        }
      } else {
        const block = this.transformToBlock(child);
        if (block) blocks.push(block);
      }
    } else {
      const block = this.transformToBlock(child);
      if (block) blocks.push(block);
    }

    i++;
  }

  return blocks;
}
```

4. Update usages: Replace the simple for-loops that call transformToBlock on children with:

```typescript
// Before:
for (const child of node.getJsxChildren()) {
  const block = this.transformToBlock(child);
  if (block) children.push(block);
}

// After:
const children = this.transformBlockChildren(node.getJsxChildren());
```

Apply this change to:
- transformCommand
- transformAgent
- transformXmlBlock
- transformBlockquote
- transformDiv

Do NOT change transformListItem - it has special handling for nested lists and inline content.
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile successfully.
Check methods exist: `grep -E "transformElse|transformBlockChildren" src/parser/transformer.ts`
  </verify>
  <done>transformElse returns ElseNode. transformBlockChildren handles If/Else sibling detection with whitespace handling. All block-processing methods updated to use helper.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Methods exist: `grep -E "transformIf|transformElse|transformBlockChildren" src/parser/transformer.ts`
3. SPECIAL_COMPONENTS updated: `grep "If.*Else" src/parser/transformer.ts`
4. Run existing tests: `npm test` (should pass - no behavior change to existing features)
</verification>

<success_criteria>
- If element with test prop transforms to IfNode
- If children become IfNode.children
- Else following If transforms to ElseNode (sibling detection works)
- Standalone Else throws descriptive error
- Whitespace between If and Else does not break detection
- Existing tests pass (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/13-conditional-logic/13-02-SUMMARY.md`
</output>
