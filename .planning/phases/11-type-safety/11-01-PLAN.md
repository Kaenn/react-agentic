---
phase: 11-type-safety
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/jsx.ts
  - src/parser/parser.ts
  - src/ir/nodes.ts
  - src/parser/transformer.ts
  - tests/parser/generic-extraction.test.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Agent component accepts generic type parameter <Agent<TInput>>"
    - "SpawnAgent component accepts generic type parameter <SpawnAgent<TInput>>"
    - "Parser extracts type argument names from JSX elements"
    - "IR nodes store inputType reference for validation phase"
  artifacts:
    - path: "src/jsx.ts"
      provides: "Generic type parameters for Agent and SpawnAgent"
      contains: "function Agent<TInput"
    - path: "src/parser/parser.ts"
      provides: "extractTypeArguments utility function"
      contains: "extractTypeArguments"
    - path: "src/ir/nodes.ts"
      provides: "inputType field on SpawnAgentNode and AgentFrontmatterNode"
      contains: "inputType?: TypeReference"
    - path: "tests/parser/generic-extraction.test.ts"
      provides: "Tests for generic type extraction"
      min_lines: 50
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/parser/parser.ts"
      via: "extractTypeArguments import"
      pattern: "extractTypeArguments"
    - from: "src/parser/transformer.ts"
      to: "src/ir/nodes.ts"
      via: "TypeReference creation"
      pattern: "kind: 'typeReference'"
---

<objective>
Add generic type parameter support to Agent and SpawnAgent components

Purpose: Enable compile-time type safety by allowing Agent to declare its input contract and SpawnAgent to reference it. This is the foundation for cross-file validation in Plan 02.

Output: Updated jsx.ts with generic components, parser utilities for type extraction, and IR nodes storing type references
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-type-safety/11-RESEARCH.md
@src/jsx.ts
@src/parser/parser.ts
@src/parser/transformer.ts
@src/ir/nodes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add generic type parameters to jsx.ts components</name>
  <files>src/jsx.ts</files>
  <action>
Update Agent and SpawnAgent components to accept generic type parameters.

For AgentProps:
```typescript
export interface AgentProps<TInput = unknown> {
  name: string;
  description: string;
  tools?: string;
  color?: string;
  folder?: string;
  children?: ReactNode;
  // TInput is compile-time only - not used at runtime
}
```

For SpawnAgentProps:
```typescript
export interface SpawnAgentProps<TInput = unknown> {
  agent: string;
  model: string;
  description: string;
  prompt: string;
  // TInput enables compile-time validation against Agent's interface
}
```

Update component functions:
```typescript
export function Agent<TInput = unknown>(_props: AgentProps<TInput>): null {
  return null;
}

export function SpawnAgent<TInput = unknown>(_props: SpawnAgentProps<TInput>): null {
  return null;
}
```

Add JSDoc examples showing usage:
```typescript
/**
 * Agent component with generic type parameter
 * @example
 * export interface ResearcherInput { phase: string; description: string; }
 * <Agent<ResearcherInput> name="researcher" description="Research topics" tools="Read Grep Glob">
 */
```

This enables: `<Agent<MyInput>>` and `<SpawnAgent<MyInput>>` syntax in TSX files.
  </action>
  <verify>
`npm run typecheck` passes - verify generic components compile correctly.
  </verify>
  <done>
Agent and SpawnAgent components accept generic type parameters with default `unknown`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add extractTypeArguments utility and update IR nodes</name>
  <files>src/parser/parser.ts, src/ir/nodes.ts</files>
  <action>
**In src/ir/nodes.ts:**

Add optional inputType field to AgentFrontmatterNode:
```typescript
export interface AgentFrontmatterNode {
  kind: 'agentFrontmatter';
  name: string;
  description: string;
  tools?: string;
  color?: string;
  inputType?: TypeReference;  // NEW: Generic type parameter if provided
}
```

Add optional inputType field to SpawnAgentNode:
```typescript
export interface SpawnAgentNode {
  kind: 'spawnAgent';
  agent: string;
  model: string;
  description: string;
  prompt: string;
  inputType?: TypeReference;  // NEW: Generic type parameter if provided
}
```

TypeReference already exists from Phase 8 - no changes needed there.

**In src/parser/parser.ts:**

Add extractTypeArguments function using the TypeReferenceNode pattern from research:

```typescript
import { SyntaxKind } from 'ts-morph';

/**
 * Extract generic type arguments from a JSX element
 * For <SpawnAgent<ResearcherInput>> returns ['ResearcherInput']
 * For <Agent<MyInput>> returns ['MyInput']
 * Returns undefined if no type arguments present
 */
export function extractTypeArguments(
  element: JsxElement | JsxSelfClosingElement
): string[] | undefined {
  // Get the tag name node (where generics are attached in JSX)
  const openingElement = Node.isJsxElement(element)
    ? element.getOpeningElement()
    : element;

  // Get all children of the opening tag
  // Type arguments appear as TypeReference children
  const typeRefNodes = openingElement.getDescendantsOfKind(SyntaxKind.TypeReference);

  if (typeRefNodes.length === 0) {
    return undefined;
  }

  // Extract the type name text from each TypeReference
  return typeRefNodes.map(node => node.getText());
}
```

Note: This approach uses getDescendantsOfKind which is reliable in ts-morph. The research mentioned potential complexity with JSX type arguments - if this approach doesn't work, fall back to using the underlying TypeScript AST via `node.compilerNode`.
  </action>
  <verify>
`npm run typecheck` passes - verify updated nodes and parser utility compile correctly.
  </verify>
  <done>
IR nodes have inputType fields, and parser has extractTypeArguments utility.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update transformer to extract and store type arguments</name>
  <files>src/parser/transformer.ts, tests/parser/generic-extraction.test.ts</files>
  <action>
**In src/parser/transformer.ts:**

Import extractTypeArguments:
```typescript
import { ..., extractTypeArguments } from './parser.js';
```

Import TypeReference:
```typescript
import type { ..., TypeReference } from '../ir/index.js';
```

Update transformAgent to extract and store generic type:
```typescript
private transformAgent(node: JsxElement | JsxSelfClosingElement): AgentDocumentNode {
  // ... existing prop extraction ...

  // Extract generic type argument if present
  const typeArgs = extractTypeArguments(node);
  let inputType: TypeReference | undefined;
  if (typeArgs && typeArgs.length > 0) {
    inputType = {
      kind: 'typeReference',
      name: typeArgs[0],
      resolved: false,  // Will be resolved in validation phase
    };
  }

  const frontmatter: AgentFrontmatterNode = {
    kind: 'agentFrontmatter',
    name,
    description,
    ...(tools && { tools }),
    ...(color && { color }),
    ...(inputType && { inputType }),  // NEW
  };

  // ... rest unchanged ...
}
```

Update transformSpawnAgent to extract and store generic type:
```typescript
private transformSpawnAgent(node: JsxElement | JsxSelfClosingElement): SpawnAgentNode {
  // ... existing prop extraction ...

  // Extract generic type argument if present
  const typeArgs = extractTypeArguments(node);
  let inputType: TypeReference | undefined;
  if (typeArgs && typeArgs.length > 0) {
    inputType = {
      kind: 'typeReference',
      name: typeArgs[0],
      resolved: false,  // Will be resolved in validation phase
    };
  }

  return {
    kind: 'spawnAgent',
    agent,
    model,
    description,
    prompt,
    ...(inputType && { inputType }),  // NEW
  };
}
```

**Create tests/parser/generic-extraction.test.ts:**

```typescript
import { describe, it, expect } from 'vitest';
import { createProject, parseSource, findRootJsxElement, extractTypeArguments } from '../../src/parser/parser.js';
import { transform } from '../../src/parser/transformer.js';
import { Node } from 'ts-morph';

describe('extractTypeArguments', () => {
  const project = createProject({ inMemory: true });

  it('extracts type argument from Agent<TInput>', () => {
    const source = `
      export default function Test() {
        return <Agent<ResearcherInput> name="test" description="desc" />;
      }
    `;
    const sourceFile = parseSource(project, source, 'test.tsx');
    const root = findRootJsxElement(sourceFile);
    expect(root).not.toBeNull();

    if (Node.isJsxSelfClosingElement(root!)) {
      const typeArgs = extractTypeArguments(root!);
      expect(typeArgs).toEqual(['ResearcherInput']);
    }
  });

  it('extracts type argument from SpawnAgent<TInput>', () => {
    const source = `
      export default function Test() {
        return (
          <Command name="test" description="desc">
            <SpawnAgent<MyInput>
              agent="test-agent"
              model="opus"
              description="task"
              prompt="do something"
            />
          </Command>
        );
      }
    `;
    const sourceFile = parseSource(project, source, 'test.tsx');
    const root = findRootJsxElement(sourceFile);
    expect(root).not.toBeNull();

    const doc = transform(root!, sourceFile);
    expect(doc.kind).toBe('document');

    const spawnAgent = doc.children.find(c => c.kind === 'spawnAgent');
    expect(spawnAgent).toBeDefined();
    expect(spawnAgent?.inputType).toEqual({
      kind: 'typeReference',
      name: 'MyInput',
      resolved: false,
    });
  });

  it('returns undefined when no type argument present', () => {
    const source = `
      export default function Test() {
        return <Agent name="test" description="desc" />;
      }
    `;
    const sourceFile = parseSource(project, source, 'test.tsx');
    const root = findRootJsxElement(sourceFile);
    expect(root).not.toBeNull();

    if (Node.isJsxSelfClosingElement(root!)) {
      const typeArgs = extractTypeArguments(root!);
      expect(typeArgs).toBeUndefined();
    }
  });

  it('stores inputType in AgentFrontmatterNode', () => {
    const source = `
      export default function Test() {
        return <Agent<TaskInput> name="worker" description="worker agent" />;
      }
    `;
    const sourceFile = parseSource(project, source, 'test.tsx');
    const root = findRootJsxElement(sourceFile);
    const doc = transform(root!, sourceFile);

    expect(doc.kind).toBe('agentDocument');
    if (doc.kind === 'agentDocument') {
      expect(doc.frontmatter.inputType).toEqual({
        kind: 'typeReference',
        name: 'TaskInput',
        resolved: false,
      });
    }
  });

  it('handles qualified type names', () => {
    const source = `
      export default function Test() {
        return <Agent<Types.ResearcherInput> name="test" description="desc" />;
      }
    `;
    const sourceFile = parseSource(project, source, 'test.tsx');
    const root = findRootJsxElement(sourceFile);

    if (Node.isJsxSelfClosingElement(root!)) {
      const typeArgs = extractTypeArguments(root!);
      expect(typeArgs).toEqual(['Types.ResearcherInput']);
    }
  });
});
```

If the extractTypeArguments approach using getDescendantsOfKind doesn't work (ts-morph may not expose JSX type args directly), adjust implementation to use:
1. `openingElement.compilerNode` to access underlying TypeScript AST
2. Check for `typeArguments` property on the compiler node
3. Extract text from each type argument node

Research indicated this may require accessing the underlying TS compiler API.
  </action>
  <verify>
`npm test` - all tests pass including new generic extraction tests.
`npm run typecheck` - no type errors.
  </verify>
  <done>
Transformer extracts generic type arguments from Agent and SpawnAgent, stores them as TypeReference in IR nodes.
  </done>
</task>

</tasks>

<verification>
Run the full test suite and type check:
```bash
npm run typecheck
npm test
```

Verify specific functionality:
1. `<Agent<MyInput>>` syntax compiles in TSX files
2. `<SpawnAgent<MyInput>>` syntax compiles in TSX files
3. extractTypeArguments returns type names from JSX elements
4. IR nodes store inputType when generic provided
5. IR nodes omit inputType when no generic (backward compatibility)
</verification>

<success_criteria>
- AgentProps and SpawnAgentProps interfaces accept generic type parameter
- Agent and SpawnAgent functions are generic with default `unknown`
- extractTypeArguments utility extracts type names from JSX elements
- AgentFrontmatterNode and SpawnAgentNode have optional inputType field
- Transformer populates inputType when generic type argument present
- All existing tests continue to pass (backward compatibility)
- New tests cover generic extraction scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/11-type-safety/11-01-SUMMARY.md`
</output>
