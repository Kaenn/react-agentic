---
phase: 11-type-safety
plan: 02
type: execute
wave: 2
depends_on: [11-01]
files_modified:
  - src/cli/errors.ts
  - src/parser/parser.ts
  - src/cli/commands/build.ts
  - tests/validation/cross-file-validation.test.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Transpiler errors if referenced Agent file does not exist"
    - "Transpiler errors if SpawnAgent input type doesn't match Agent's exported interface"
    - "Error messages include source locations for both Command and Agent files"
    - "Build fails with exit code 1 when validation errors occur"
  artifacts:
    - path: "src/cli/errors.ts"
      provides: "CrossFileError class for dual-location errors"
      contains: "class CrossFileError"
    - path: "src/parser/parser.ts"
      provides: "resolveTypeImport and extractInterfaceProperties utilities"
      contains: "resolveTypeImport"
    - path: "src/cli/commands/build.ts"
      provides: "Validation pass before emission"
      contains: "validateSpawnAgents"
    - path: "tests/validation/cross-file-validation.test.ts"
      provides: "Tests for cross-file validation"
      min_lines: 100
  key_links:
    - from: "src/cli/commands/build.ts"
      to: "src/parser/parser.ts"
      via: "resolveTypeImport import"
      pattern: "resolveTypeImport"
    - from: "src/cli/commands/build.ts"
      to: "src/cli/errors.ts"
      via: "CrossFileError import"
      pattern: "CrossFileError"
---

<objective>
Implement cross-file validation for SpawnAgent type safety

Purpose: Ensure SpawnAgent usages match their Agent's exported interface. This catches contract mismatches at build time rather than runtime (when GSD would fail).

Output: CrossFileError class, validation utilities, and build integration that validates SpawnAgent against Agent interfaces
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-type-safety/11-RESEARCH.md
@.planning/phases/11-type-safety/11-01-SUMMARY.md
@src/cli/errors.ts
@src/parser/parser.ts
@src/cli/commands/build.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CrossFileError class and formatting</name>
  <files>src/cli/errors.ts</files>
  <action>
Add CrossFileError class that extends TranspileError with an additional agent location:

```typescript
/**
 * Error class for cross-file validation errors
 * Includes source locations for both the usage site (Command) and definition site (Agent)
 */
export class CrossFileError extends TranspileError {
  readonly agentLocation: SourceLocation | undefined;

  constructor(
    message: string,
    commandLocation: SourceLocation,
    agentLocation?: SourceLocation,
    sourceCode?: string
  ) {
    super(message, commandLocation, sourceCode);
    this.name = 'CrossFileError';
    this.agentLocation = agentLocation;
  }
}
```

Add formatCrossFileError function:

```typescript
/**
 * Format a CrossFileError for display
 * Shows both the command (primary) and agent (secondary) locations
 *
 * Example output:
 * ```
 * commands/plan.tsx:15:5 - error: SpawnAgent prompt missing required property: 'phase'
 *
 *   15 | <SpawnAgent<ResearcherInput>
 *      |  ^
 *
 * Agent interface defined at: agents/researcher.tsx:3:1
 * ```
 */
export function formatCrossFileError(error: CrossFileError): string {
  const parts: string[] = [];

  // Primary location (command/usage site)
  parts.push(formatTranspileError(error));

  // Secondary location (agent/definition site)
  if (error.agentLocation) {
    const { file, line, column } = error.agentLocation;
    parts.push('');
    parts.push(
      `${pc.dim('Agent interface defined at:')} ${pc.cyan(file)}:${pc.dim(String(line))}:${pc.dim(String(column))}`
    );
  }

  return parts.join('\n');
}
```

Export both from the module:
```typescript
export { CrossFileError, formatCrossFileError };
```
  </action>
  <verify>
`npm run typecheck` - verify CrossFileError compiles correctly.
  </verify>
  <done>
CrossFileError class exists with dual-location support, formatCrossFileError produces readable output.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add type resolution and interface extraction utilities</name>
  <files>src/parser/parser.ts</files>
  <action>
Add utilities for cross-file type resolution:

```typescript
import { InterfaceDeclaration, PropertySignature } from 'ts-morph';

/**
 * Result of resolving a type import
 */
export interface ResolvedType {
  sourceFile: SourceFile;
  interfaceName: string;
  interface: InterfaceDeclaration;
}

/**
 * Resolve a type name to its interface declaration
 * Follows import declarations to find the source file and interface
 *
 * @param typeName - Name of the type to resolve (e.g., 'ResearcherInput')
 * @param sourceFile - Source file containing the import
 * @returns ResolvedType with source file and interface, or undefined if not found
 */
export function resolveTypeImport(
  typeName: string,
  sourceFile: SourceFile
): ResolvedType | undefined {
  // Check if type is defined locally first
  const localInterface = sourceFile.getInterface(typeName);
  if (localInterface) {
    return {
      sourceFile,
      interfaceName: typeName,
      interface: localInterface,
    };
  }

  // Find import declaration for this type
  for (const importDecl of sourceFile.getImportDeclarations()) {
    // Check named imports: import { TypeName } from '...'
    for (const namedImport of importDecl.getNamedImports()) {
      if (namedImport.getName() === typeName) {
        const resolved = importDecl.getModuleSpecifierSourceFile();
        if (!resolved) {
          return undefined;
        }

        // Handle aliased imports: import { X as Y } from '...'
        const originalName = namedImport.getAliasNode()?.getText() ?? typeName;

        // Get the interface from the resolved file
        const iface = resolved.getInterface(originalName);
        if (!iface) {
          // Try exported declarations (for re-exports)
          const exported = resolved.getExportedDeclarations().get(originalName);
          const exportedIface = exported?.find(d => Node.isInterfaceDeclaration(d));
          if (exportedIface && Node.isInterfaceDeclaration(exportedIface)) {
            return {
              sourceFile: resolved,
              interfaceName: originalName,
              interface: exportedIface,
            };
          }
          return undefined;
        }

        return {
          sourceFile: resolved,
          interfaceName: originalName,
          interface: iface,
        };
      }
    }

    // Check type-only imports: import type { TypeName } from '...'
    if (importDecl.isTypeOnly()) {
      for (const namedImport of importDecl.getNamedImports()) {
        if (namedImport.getName() === typeName) {
          const resolved = importDecl.getModuleSpecifierSourceFile();
          if (!resolved) {
            return undefined;
          }

          const originalName = namedImport.getAliasNode()?.getText() ?? typeName;
          const iface = resolved.getInterface(originalName);
          if (iface) {
            return {
              sourceFile: resolved,
              interfaceName: originalName,
              interface: iface,
            };
          }
        }
      }
    }
  }

  return undefined;
}

/**
 * Property information extracted from an interface
 */
export interface InterfaceProperty {
  name: string;
  required: boolean;
  type: string;
}

/**
 * Extract property information from an interface
 *
 * @param iface - Interface declaration to extract from
 * @returns Array of property information
 */
export function extractInterfaceProperties(
  iface: InterfaceDeclaration
): InterfaceProperty[] {
  const properties: InterfaceProperty[] = [];

  for (const prop of iface.getProperties()) {
    properties.push({
      name: prop.getName(),
      required: !prop.hasQuestionToken(),
      type: prop.getType().getText(),
    });
  }

  return properties;
}

/**
 * Extract {placeholder} patterns from a prompt string
 *
 * @param prompt - Prompt string with {variable} placeholders
 * @returns Set of placeholder names (without braces)
 */
export function extractPromptPlaceholders(prompt: string): Set<string> {
  const matches = prompt.matchAll(/\{(\w+)\}/g);
  return new Set([...matches].map(m => m[1]));
}
```

Export these from the module.
  </action>
  <verify>
`npm run typecheck` - verify utilities compile correctly.
  </verify>
  <done>
resolveTypeImport, extractInterfaceProperties, and extractPromptPlaceholders utilities exist and are exported.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add validation pass to build command</name>
  <files>src/cli/commands/build.ts, tests/validation/cross-file-validation.test.ts</files>
  <action>
**In src/cli/commands/build.ts:**

Import new utilities:
```typescript
import {
  resolveTypeImport,
  extractInterfaceProperties,
  extractPromptPlaceholders,
} from '../../parser/parser.js';
import { CrossFileError, formatCrossFileError } from '../errors.js';
```

Add validation function:

```typescript
/**
 * Validate SpawnAgent nodes against their Agent interfaces
 *
 * Checks:
 * 1. If SpawnAgent has inputType, verify the type can be resolved
 * 2. Verify prompt placeholders cover all required interface properties
 *
 * @param doc - Document node containing potential SpawnAgent children
 * @param sourceFile - Source file for import resolution
 * @returns Array of validation errors
 */
function validateSpawnAgents(
  doc: DocumentNode | AgentDocumentNode,
  sourceFile: SourceFile
): CrossFileError[] {
  const errors: CrossFileError[] = [];

  for (const child of doc.children) {
    if (child.kind !== 'spawnAgent' || !child.inputType) {
      continue;
    }

    const typeName = child.inputType.name;

    // Try to resolve the type import
    const resolved = resolveTypeImport(typeName, sourceFile);
    if (!resolved) {
      // Type not found - create error at SpawnAgent location
      // Note: We can't get node location after transformation, so this requires
      // storing location during transformation or re-parsing
      // For now, create error without precise location
      errors.push(
        new CrossFileError(
          `Cannot resolve type '${typeName}' for SpawnAgent validation`,
          { file: sourceFile.getFilePath(), line: 1, column: 1 },
          undefined,
          sourceFile.getFullText()
        )
      );
      continue;
    }

    // Extract interface properties and prompt placeholders
    const properties = extractInterfaceProperties(resolved.interface);
    const placeholders = extractPromptPlaceholders(child.prompt);

    // Check for missing required properties
    const requiredProps = properties.filter(p => p.required);
    const missing = requiredProps.filter(p => !placeholders.has(p.name));

    if (missing.length > 0) {
      const missingNames = missing.map(p => `'${p.name}'`).join(', ');
      const agentLocation = {
        file: resolved.sourceFile.getFilePath(),
        line: resolved.interface.getStartLineNumber(),
        column: 1,
      };

      errors.push(
        new CrossFileError(
          `SpawnAgent prompt missing required properties: ${missingNames}`,
          { file: sourceFile.getFilePath(), line: 1, column: 1 },
          agentLocation,
          sourceFile.getFullText()
        )
      );
    }
  }

  return errors;
}
```

Update runBuild to include validation pass:

```typescript
async function runBuild(
  tsxFiles: string[],
  options: BuildOptions,
  project: Project,
  clearScreen: boolean
): Promise<{ successCount: number; errorCount: number }> {
  // ... existing code up to transform ...

  for (const inputFile of tsxFiles) {
    try {
      const sourceFile = project.addSourceFileAtPath(inputFile);
      const root = findRootJsxElement(sourceFile);
      if (!root) {
        throw new Error('No JSX element found in file');
      }

      const doc = transform(root, sourceFile);

      // NEW: Run validation pass for documents with SpawnAgent
      if (doc.kind === 'document') {
        const validationErrors = validateSpawnAgents(doc, sourceFile);
        for (const valError of validationErrors) {
          errorCount++;
          console.error(formatCrossFileError(valError));
        }
        // Continue to emit even with validation errors (warning mode)
        // To make validation blocking, uncomment:
        // if (validationErrors.length > 0) {
        //   continue;
        // }
      }

      // ... rest of existing code ...
    } catch (error) {
      // ... existing error handling ...
    }
  }

  // ... rest unchanged ...
}
```

**Create tests/validation/cross-file-validation.test.ts:**

```typescript
import { describe, it, expect, beforeAll } from 'vitest';
import { Project } from 'ts-morph';
import { createProject, parseSource, findRootJsxElement, resolveTypeImport, extractInterfaceProperties, extractPromptPlaceholders } from '../../src/parser/parser.js';
import { transform } from '../../src/parser/transformer.js';

describe('Cross-file validation', () => {
  let project: Project;

  beforeAll(() => {
    project = createProject({ inMemory: true });
  });

  describe('resolveTypeImport', () => {
    it('resolves locally defined interface', () => {
      const source = `
        export interface LocalInput {
          name: string;
          value: number;
        }

        export default function Test() {
          return <Agent<LocalInput> name="test" description="test" />;
        }
      `;
      const sourceFile = parseSource(project, source, 'local.tsx');
      const resolved = resolveTypeImport('LocalInput', sourceFile);

      expect(resolved).toBeDefined();
      expect(resolved?.interfaceName).toBe('LocalInput');
    });

    it('resolves imported interface', () => {
      // Create agent file with interface
      const agentSource = `
        export interface ResearcherInput {
          phase: string;
          description: string;
          requirements?: string;
        }

        export default function Researcher() {
          return <Agent<ResearcherInput> name="researcher" description="Research topics" />;
        }
      `;
      parseSource(project, agentSource, 'agents/researcher.tsx');

      // Create command file that imports interface
      const commandSource = `
        import { ResearcherInput } from './agents/researcher';

        export default function PlanPhase() {
          return (
            <Command name="plan" description="Plan phase">
              <SpawnAgent<ResearcherInput>
                agent="researcher"
                model="opus"
                description="Research"
                prompt="Phase: {phase} - {description}"
              />
            </Command>
          );
        }
      `;
      const commandFile = parseSource(project, commandSource, 'commands/plan.tsx');
      const resolved = resolveTypeImport('ResearcherInput', commandFile);

      expect(resolved).toBeDefined();
      expect(resolved?.interfaceName).toBe('ResearcherInput');
    });

    it('returns undefined for non-existent type', () => {
      const source = `
        export default function Test() {
          return <Agent name="test" description="test" />;
        }
      `;
      const sourceFile = parseSource(project, source, 'notype.tsx');
      const resolved = resolveTypeImport('NonExistent', sourceFile);

      expect(resolved).toBeUndefined();
    });
  });

  describe('extractInterfaceProperties', () => {
    it('extracts required and optional properties', () => {
      const source = `
        export interface TestInput {
          required: string;
          alsoRequired: number;
          optional?: boolean;
        }
      `;
      const sourceFile = parseSource(project, source, 'props.tsx');
      const iface = sourceFile.getInterface('TestInput')!;
      const props = extractInterfaceProperties(iface);

      expect(props).toHaveLength(3);
      expect(props.find(p => p.name === 'required')?.required).toBe(true);
      expect(props.find(p => p.name === 'alsoRequired')?.required).toBe(true);
      expect(props.find(p => p.name === 'optional')?.required).toBe(false);
    });
  });

  describe('extractPromptPlaceholders', () => {
    it('extracts placeholder names from prompt', () => {
      const prompt = 'Phase: {phase}, Description: {description}';
      const placeholders = extractPromptPlaceholders(prompt);

      expect(placeholders.has('phase')).toBe(true);
      expect(placeholders.has('description')).toBe(true);
      expect(placeholders.size).toBe(2);
    });

    it('handles multi-line prompts', () => {
      const prompt = `<context>
Phase: {phase}
Goal: {goal}
</context>

Research: {topic}`;
      const placeholders = extractPromptPlaceholders(prompt);

      expect(placeholders.has('phase')).toBe(true);
      expect(placeholders.has('goal')).toBe(true);
      expect(placeholders.has('topic')).toBe(true);
      expect(placeholders.size).toBe(3);
    });

    it('returns empty set for prompt without placeholders', () => {
      const prompt = 'Just a plain prompt with no variables';
      const placeholders = extractPromptPlaceholders(prompt);

      expect(placeholders.size).toBe(0);
    });
  });

  describe('SpawnAgent validation integration', () => {
    it('validates prompt contains required interface properties', () => {
      const agentSource = `
        export interface TaskInput {
          goal: string;
          context: string;
          priority?: number;
        }

        export default function Worker() {
          return <Agent<TaskInput> name="worker" description="Worker agent" />;
        }
      `;
      parseSource(project, agentSource, 'agents/worker.tsx');

      // Missing 'context' - should fail validation
      const commandSource = `
        import { TaskInput } from './agents/worker';

        export default function RunTask() {
          return (
            <Command name="run" description="Run task">
              <SpawnAgent<TaskInput>
                agent="worker"
                model="opus"
                description="Execute task"
                prompt="Goal: {goal}"
              />
            </Command>
          );
        }
      `;
      const commandFile = parseSource(project, commandSource, 'commands/run.tsx');
      const root = findRootJsxElement(commandFile);
      const doc = transform(root!, commandFile);

      // Get the SpawnAgent node
      const spawnAgent = doc.children.find(c => c.kind === 'spawnAgent');
      expect(spawnAgent).toBeDefined();
      expect(spawnAgent?.inputType?.name).toBe('TaskInput');

      // Resolve type and check properties
      const resolved = resolveTypeImport('TaskInput', commandFile);
      expect(resolved).toBeDefined();

      const props = extractInterfaceProperties(resolved!.interface);
      const placeholders = extractPromptPlaceholders(spawnAgent!.prompt);

      // Check for missing required
      const required = props.filter(p => p.required);
      const missing = required.filter(p => !placeholders.has(p.name));

      expect(missing.length).toBe(1);
      expect(missing[0].name).toBe('context');
    });

    it('passes validation when all required properties present', () => {
      const agentSource = `
        export interface CompleteInput {
          a: string;
          b: string;
          c?: string;
        }

        export default function Complete() {
          return <Agent<CompleteInput> name="complete" description="Complete" />;
        }
      `;
      parseSource(project, agentSource, 'agents/complete.tsx');

      const commandSource = `
        import { CompleteInput } from './agents/complete';

        export default function Test() {
          return (
            <Command name="test" description="Test">
              <SpawnAgent<CompleteInput>
                agent="complete"
                model="opus"
                description="test"
                prompt="{a} and {b}"
              />
            </Command>
          );
        }
      `;
      const commandFile = parseSource(project, commandSource, 'commands/test.tsx');
      const root = findRootJsxElement(commandFile);
      const doc = transform(root!, commandFile);

      const spawnAgent = doc.children.find(c => c.kind === 'spawnAgent');
      const resolved = resolveTypeImport('CompleteInput', commandFile);
      const props = extractInterfaceProperties(resolved!.interface);
      const placeholders = extractPromptPlaceholders(spawnAgent!.prompt);

      const required = props.filter(p => p.required);
      const missing = required.filter(p => !placeholders.has(p.name));

      expect(missing.length).toBe(0);
    });
  });
});
```

Note: The validation is implemented as a warning mode (errors are logged but build continues). This can be changed to blocking mode by uncommenting the continue statement in runBuild.
  </action>
  <verify>
`npm test` - all tests pass including new validation tests.
`npm run typecheck` - no type errors.

Test validation manually:
1. Create a test agent with interface
2. Create a command with SpawnAgent missing required properties
3. Run `npm run build` and verify error is logged with both locations
  </verify>
  <done>
Cross-file validation works: resolves type imports, extracts interface properties, validates prompt placeholders, logs dual-location errors.
  </done>
</task>

</tasks>

<verification>
Run the full test suite and type check:
```bash
npm run typecheck
npm test
```

E2E verification:
1. Create agents/test-agent.tsx with exported interface
2. Create commands/test-command.tsx with SpawnAgent<TestInput> missing required props
3. Run `npm run build src/app/**/*.tsx` - verify validation error is logged with both file locations
</verification>

<success_criteria>
- CrossFileError class extends TranspileError with agentLocation
- formatCrossFileError shows both command and agent file locations
- resolveTypeImport follows imports to find interface declarations
- extractInterfaceProperties returns required/optional property info
- extractPromptPlaceholders extracts {var} patterns from prompt strings
- Build command runs validation pass for SpawnAgent nodes
- Validation errors include both usage site and definition site locations
- Build exits with code 1 when validation errors occur (when blocking mode enabled)
- All tests pass (existing + new validation tests)
</success_criteria>

<output>
After completion, create `.planning/phases/11-type-safety/11-02-SUMMARY.md`
</output>
