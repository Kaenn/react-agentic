---
phase: 23-context-access-patterns
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/workflow/Command.ts
  - src/workflow/agents/Agent.ts
  - src/parser/transformer.ts
  - src/parser/parser.ts
autonomous: true

must_haves:
  truths:
    - "<Command>{(ctx) => ...}</Command> render props pattern detects arrow function children"
    - "<Agent>{(ctx) => ...}</Agent> render props pattern detects arrow function children"
    - "ctx.name, ctx.description available in render function context"
    - "ctx.sourcePath, ctx.outputPath resolved at build time"
    - "Agent ctx includes tools and model when defined"
    - "Regular children still work (backwards compatible)"
  artifacts:
    - path: "src/workflow/Command.ts"
      provides: "CommandProps with render props children type, CommandContext interface"
      exports: ["Command", "CommandProps", "CommandContext"]
    - path: "src/workflow/agents/Agent.ts"
      provides: "AgentProps with render props children type, AgentContext interface"
      exports: ["Agent", "AgentProps", "AgentContext"]
    - path: "src/parser/parser.ts"
      provides: "analyzeRenderPropsChildren function"
      exports: ["analyzeRenderPropsChildren", "RenderPropsInfo"]
    - path: "src/parser/transformer.ts"
      provides: "transformCommand and transformAgent updated with render props detection"
      contains: "analyzeRenderPropsChildren"
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/parser/parser.ts"
      via: "import"
      pattern: "import.*analyzeRenderPropsChildren"
    - from: "src/workflow/agents/Agent.ts"
      to: "src/workflow/Command.ts"
      via: "type extension"
      pattern: "extends CommandContext"
---

<objective>
Add render props support to Command and Agent components, enabling typed context access via function-as-children pattern.

Purpose: Allow `<Command>{(ctx) => <h1>{ctx.name}</h1>}</Command>` pattern where ctx contains command/agent metadata resolved at build time. Both regular children and render props work (backwards compatible).

Output: Updated CommandProps/AgentProps types, parser utility for render props detection, and transformer logic to handle arrow function children.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/23-context-access-patterns/23-CONTEXT.md
@.planning/phases/23-context-access-patterns/23-RESEARCH.md

@src/workflow/Command.ts
@src/workflow/agents/Agent.ts
@src/parser/parser.ts
@src/parser/transformer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define context interfaces and update component props types</name>
  <files>src/workflow/Command.ts, src/workflow/agents/Agent.ts</files>
  <action>
Update Command.ts with CommandContext interface and render props support:

```typescript
import type { ReactNode } from 'react';

/**
 * Context available in Command render props pattern
 * All values resolved at compile time, static in output
 */
export interface CommandContext {
  /** Command name from props */
  name: string;
  /** Command description from props */
  description: string;
  /** Skill name if invoked via skill (undefined otherwise) */
  skill?: string;
  /** Resolved output path (e.g., .claude/commands/my-cmd.md) */
  outputPath: string;
  /** Source TSX file path */
  sourcePath: string;
}

/**
 * Props for the Command component
 */
export interface CommandProps {
  /** Command name (used in frontmatter) */
  name: string;
  /** Command description (used in frontmatter) */
  description: string;
  /** Optional argument hint (maps to argument-hint in frontmatter) */
  argumentHint?: string;
  /** Optional agent name (maps to agent in frontmatter) */
  agent?: string;
  /** Optional list of allowed tools (maps to allowed-tools in frontmatter) */
  allowedTools?: string[];
  /**
   * Command body content - either regular JSX or render props function
   * Render props: (ctx: CommandContext) => ReactNode
   */
  children?: ReactNode | ((ctx: CommandContext) => ReactNode);
}
```

Update Agent.ts with AgentContext interface extending CommandContext:

```typescript
import type { ReactNode } from 'react';
import type { CommandContext } from '../Command.js';
// ... existing imports ...

/**
 * Context available in Agent render props pattern
 * Extends CommandContext with agent-specific fields
 */
export interface AgentContext extends CommandContext {
  /** Space-separated tool names if defined */
  tools?: string;
  /** Model name if specified in agent */
  model?: string;
}

/**
 * Props for the Agent component
 * @typeParam TInput - Type interface for agent input contract (compile-time only)
 * @typeParam TOutput - Type interface for agent output contract (compile-time only)
 */
export interface AgentProps<TInput = unknown, TOutput = unknown> {
  /** Agent name (used in frontmatter and Task() spawning) */
  name: string;
  /** Agent description (used in frontmatter) */
  description: string;
  /** Space-separated tool names (optional) */
  tools?: string;
  /** Terminal color for agent output (optional) */
  color?: string;
  /** Subfolder for output path (optional) - determines namespaced agent name */
  folder?: string;
  /** Model name (optional) - for AgentContext access */
  model?: string;
  /**
   * Agent body content - either regular JSX or render props function
   * Render props: (ctx: AgentContext) => ReactNode
   */
  children?: ReactNode | ((ctx: AgentContext) => ReactNode);
  // TInput and TOutput are compile-time only - used for cross-file type validation
}
```

Export the context interfaces from jsx.ts:
```typescript
// In jsx.ts, add exports:
export type { CommandContext } from './workflow/Command.js';
export type { AgentContext } from './workflow/agents/Agent.js';
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/workflow/Command.ts src/workflow/agents/Agent.ts`</verify>
  <done>CommandContext and AgentContext interfaces defined. CommandProps and AgentProps accept render function or regular children.</done>
</task>

<task type="auto">
  <name>Task 2: Add render props detection utility to parser.ts</name>
  <files>src/parser/parser.ts</files>
  <action>
Add a utility function to detect and analyze render props children in JSX elements.

Add to imports at top of file:
```typescript
import { ArrowFunction } from 'ts-morph';
```

Add interface and function:
```typescript
/**
 * Result of analyzing JSX children for render props pattern
 */
export interface RenderPropsInfo {
  /** True if children is a single arrow function */
  isRenderProps: boolean;
  /** Parameter name used in arrow function (e.g., 'ctx') */
  paramName?: string;
  /** The arrow function AST node */
  arrowFunction?: ArrowFunction;
}

/**
 * Analyze JSX element children for render props pattern
 *
 * Detects when children is a single arrow function: {(ctx) => ...}
 * Returns info about the arrow function for transformer use.
 *
 * @param element - JSX element to analyze
 * @returns RenderPropsInfo with detection results
 */
export function analyzeRenderPropsChildren(
  element: JsxElement
): RenderPropsInfo {
  const children = element.getJsxChildren();

  // Filter out whitespace-only text nodes
  const nonWhitespace = children.filter(child => {
    if (Node.isJsxText(child)) {
      return child.getText().trim().length > 0;
    }
    return true;
  });

  // Must have exactly one child that's a JSX expression
  if (nonWhitespace.length !== 1) {
    return { isRenderProps: false };
  }

  const child = nonWhitespace[0];
  if (!Node.isJsxExpression(child)) {
    return { isRenderProps: false };
  }

  const expr = child.getExpression();
  if (!expr || !Node.isArrowFunction(expr)) {
    return { isRenderProps: false };
  }

  // Extract parameter (should be exactly one)
  const params = expr.getParameters();
  if (params.length !== 1) {
    return { isRenderProps: false };
  }

  return {
    isRenderProps: true,
    paramName: params[0].getName(),
    arrowFunction: expr,
  };
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/parser/parser.ts`</verify>
  <done>analyzeRenderPropsChildren utility added to parser.ts for detecting arrow function children.</done>
</task>

<task type="auto">
  <name>Task 3: Update transformer to handle render props in Command/Agent</name>
  <files>src/parser/transformer.ts</files>
  <action>
Update transformer to detect render props children and transform the arrow function body.

1. Add import at top:
```typescript
import { analyzeRenderPropsChildren, type RenderPropsInfo } from './parser.js';
```

2. Add helper to get arrow function body content:
```typescript
/**
 * Transform arrow function body to IR blocks
 * Handles both block body { return ... } and expression body
 */
private transformArrowFunctionBody(arrowFn: import('ts-morph').ArrowFunction): BlockNode[] {
  const body = arrowFn.getBody();

  // Handle block body: { return <div>...</div>; }
  if (Node.isBlock(body)) {
    const returnStmt = body.getStatements()
      .find(stmt => Node.isReturnStatement(stmt));

    if (returnStmt && Node.isReturnStatement(returnStmt)) {
      const returnExpr = returnStmt.getExpression();
      if (returnExpr) {
        // Check if it's JSX
        if (Node.isJsxElement(returnExpr) || Node.isJsxSelfClosingElement(returnExpr)) {
          const block = this.transformToBlock(returnExpr);
          return block ? [block] : [];
        }
        if (Node.isJsxFragment(returnExpr)) {
          return this.transformFragmentChildren(returnExpr);
        }
      }
    }
    return [];
  }

  // Handle expression body: (ctx) => <div>...</div>
  if (Node.isJsxElement(body) || Node.isJsxSelfClosingElement(body)) {
    const block = this.transformToBlock(body);
    return block ? [block] : [];
  }
  if (Node.isJsxFragment(body)) {
    return this.transformFragmentChildren(body);
  }

  return [];
}
```

3. Update transformCommand method to check for render props:
```typescript
private transformCommand(node: JsxElement | JsxSelfClosingElement): DocumentNode {
  const openingElement = Node.isJsxElement(node)
    ? node.getOpeningElement()
    : node;

  // ... existing props extraction code ...

  const frontmatter: FrontmatterNode = { kind: 'frontmatter', data };

  // Transform children - check for render props pattern
  let children: BlockNode[] = [];
  if (Node.isJsxElement(node)) {
    const renderPropsInfo = analyzeRenderPropsChildren(node);

    if (renderPropsInfo.isRenderProps && renderPropsInfo.arrowFunction) {
      // Render props pattern: transform arrow function body
      children = this.transformArrowFunctionBody(renderPropsInfo.arrowFunction);
    } else {
      // Regular children pattern
      children = this.transformBlockChildren(node.getJsxChildren());
    }
  }

  return { kind: 'document', frontmatter, children };
}
```

4. Update transformAgent method similarly:
```typescript
private transformAgent(node: JsxElement | JsxSelfClosingElement): AgentDocumentNode {
  // ... existing code ...

  // Transform children - check for render props pattern
  let children: BlockNode[] = [];
  if (Node.isJsxElement(node)) {
    const renderPropsInfo = analyzeRenderPropsChildren(node);

    if (renderPropsInfo.isRenderProps && renderPropsInfo.arrowFunction) {
      // Render props pattern: transform arrow function body
      children = this.transformArrowFunctionBody(renderPropsInfo.arrowFunction);
    } else {
      // Regular children pattern
      children = this.transformBlockChildren(node.getJsxChildren());
    }
  }

  return { kind: 'agentDocument', frontmatter, children };
}
```

Note: Context values (name, description, outputPath, sourcePath) are accessed via props at build time.
The render function parameter (ctx) is unused in the output - we just need to transform the body.
Context access like `{ctx.name}` in JSX will be handled by existing expression interpolation.
  </action>
  <verify>Run `npm run build` - should compile without errors. Check that both regular and render props patterns transform correctly.</verify>
  <done>Transformer handles render props pattern in Command and Agent, extracting and transforming arrow function body.</done>
</task>

<task type="auto">
  <name>Task 4: Create test command to verify render props pattern</name>
  <files>src/app/test-render-props.tsx</files>
  <action>
Create a test command to verify render props detection and transformation:

```tsx
import { Command, Markdown } from '../jsx.js';

export default function TestRenderProps() {
  return (
    <Command name="test-render-props" description="Test render props pattern">
      {(ctx) => (
        <>
          <h1>Render Props Test</h1>
          <Markdown>
This command uses the render props pattern to access context.

The context parameter `ctx` gives access to command metadata.
          </Markdown>
          <h2>Context Values</h2>
          <p>Command name and description are available in the output.</p>
        </>
      )}
    </Command>
  );
}
```

Build and verify:
```bash
npm run build
node dist/cli/index.js build src/app/test-render-props.tsx
cat .claude/commands/test-render-props.md
```

Verify output contains:
1. Frontmatter with name and description
2. The `# Render Props Test` heading
3. The markdown content
4. The `## Context Values` heading
5. The paragraph content

Also verify regular children still work by building any existing command.
  </action>
  <verify>Build and run test command. Output should show transformed content from arrow function body. Both render props and regular children patterns should work.</verify>
  <done>Render props pattern works for Command component. Regular children remain backwards compatible.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. `npx tsc --noEmit` passes
3. Build test-render-props.tsx: `node dist/cli/index.js build src/app/test-render-props.tsx`
4. Output file contains transformed JSX from arrow function body
5. Existing commands with regular children still build correctly
6. Context interfaces exported from jsx.ts
</verification>

<success_criteria>
- `<Command>{(ctx) => ...}</Command>` pattern detected and arrow function body transformed
- `<Agent>{(ctx) => ...}</Agent>` pattern detected and arrow function body transformed
- CommandContext interface defines: name, description, skill?, outputPath, sourcePath
- AgentContext extends CommandContext with: tools?, model?
- Regular children pattern still works (backwards compatible)
- TypeScript enforces correct children type (ReactNode | render function)
</success_criteria>

<output>
After completion, create `.planning/phases/23-context-access-patterns/23-01-SUMMARY.md`
</output>
