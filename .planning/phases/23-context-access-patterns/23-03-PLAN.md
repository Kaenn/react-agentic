---
phase: 23-context-access-patterns
plan: 03
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - src/primitives/step.ts
  - src/primitives/index.ts
  - src/jsx.ts
  - src/ir/nodes.ts
  - src/parser/transformer.ts
  - src/emitter/emitter.ts
autonomous: true

must_haves:
  truths:
    - "<Step number={1} name='Setup'> emits numbered workflow section"
    - "variant='heading' emits ## Step 1: Setup"
    - "variant='bold' emits **Step 1: Setup**"
    - "variant='xml' emits <step number='1' name='Setup'>...</step>"
    - "Default variant is 'heading' when prop omitted"
    - "Nested sub-steps render correctly (1.1, 1.2)"
  artifacts:
    - path: "src/primitives/step.ts"
      provides: "Step component with StepProps interface"
      exports: ["Step", "StepProps"]
    - path: "src/ir/nodes.ts"
      provides: "StepNode IR node type"
      contains: "StepNode"
    - path: "src/parser/transformer.ts"
      provides: "transformStep method"
      contains: "transformStep"
    - path: "src/emitter/emitter.ts"
      provides: "emitStep method with variant-based output"
      contains: "emitStep"
  key_links:
    - from: "src/jsx.ts"
      to: "src/primitives/step.ts"
      via: "re-export"
      pattern: "export.*Step"
    - from: "src/parser/transformer.ts"
      to: "transformStep"
      via: "element case"
      pattern: "case.*Step"
---

<objective>
Create Step component for numbered workflow sections with variant-based output formats.

Purpose: Enable `<Step number={1} name="Setup">` pattern for documenting numbered steps in workflows. Supports multiple output formats via variant prop (heading, bold, xml) with heading as default.

Output: Complete Step component pipeline from TSX to markdown with three rendering variants.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/23-context-access-patterns/23-CONTEXT.md
@.planning/phases/23-context-access-patterns/23-RESEARCH.md
@.planning/phases/23-context-access-patterns/23-01-SUMMARY.md

@src/primitives/control.ts
@src/primitives/markdown.ts
@src/ir/nodes.ts
@src/parser/transformer.ts
@src/emitter/emitter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Step component definition</name>
  <files>src/primitives/step.ts</files>
  <action>
Create a new file `src/primitives/step.ts` with the Step component.

```typescript
/**
 * JSX component stubs for react-agentic - Step workflow primitive
 *
 * These components are compile-time only - they're transformed by the transpiler
 * and never executed at runtime. They exist to provide TypeScript type checking.
 */

import type { ReactNode } from 'react';

/**
 * Variant for Step output format
 * - 'heading': ## Step 1: Name (default)
 * - 'bold': **Step 1: Name**
 * - 'xml': <step number="1" name="Name">...</step>
 */
export type StepVariant = 'heading' | 'bold' | 'xml';

/**
 * Props for the Step component
 */
export interface StepProps {
  /** Step number - explicit, no auto-increment */
  number: number | string;
  /** Step name/title */
  name: string;
  /**
   * Output format variant
   * - 'heading': ## Step 1: Name (default)
   * - 'bold': **Step 1: Name**
   * - 'xml': <step number="1" name="Name">...</step>
   */
  variant?: StepVariant;
  /** Step body content */
  children?: ReactNode;
}

/**
 * Step component - numbered workflow section
 *
 * This is a compile-time component transformed by react-agentic.
 * It's never executed at runtime. Emits formatted step sections.
 *
 * @example Default (heading) variant
 * <Step number={1} name="Setup">
 *   <p>Set up the development environment.</p>
 * </Step>
 * // Output: ## Step 1: Setup
 * //         Set up the development environment.
 *
 * @example Bold variant
 * <Step number={2} name="Configure" variant="bold">
 *   <p>Configure the settings.</p>
 * </Step>
 * // Output: **Step 2: Configure**
 * //         Configure the settings.
 *
 * @example XML variant
 * <Step number={3} name="Deploy" variant="xml">
 *   <p>Deploy to production.</p>
 * </Step>
 * // Output: <step number="3" name="Deploy">
 * //           Deploy to production.
 * //         </step>
 *
 * @example Sub-steps
 * <Step number="1.1" name="Install dependencies">
 *   <p>Run npm install.</p>
 * </Step>
 */
export function Step(_props: StepProps): null {
  return null;
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/primitives/step.ts`</verify>
  <done>Step component defined with StepProps interface and StepVariant type.</done>
</task>

<task type="auto">
  <name>Task 2: Wire up Step exports</name>
  <files>src/primitives/index.ts, src/jsx.ts</files>
  <action>
Export Step component through the module hierarchy.

1. Check if src/primitives/index.ts exists. If not, create it.

If it exists, add:
```typescript
export { Step, type StepProps, type StepVariant } from './step.js';
```

If it needs to be created:
```typescript
/**
 * Primitives index - re-exports all primitive components
 */
export { Markdown, type MarkdownProps } from './markdown.js';
export { If, Else, Loop, type IfProps, type ElseProps, type LoopProps, fileExists, dirExists, isEmpty, notEmpty, equals, and, or } from './control.js';
export { useVariable, Assign, type VariableRef, type AssignProps } from './variables.js';
export { Table, List, type TableProps, type ListProps } from './structured.js';
export { Step, type StepProps, type StepVariant } from './step.js';
```

2. Update src/jsx.ts to export Step:
```typescript
// Add to the primitives section (after control exports):
export { Step, type StepProps, type StepVariant } from './primitives/step.js';
```

Or if using barrel import from primitives/index.ts:
```typescript
export { Step, type StepProps, type StepVariant } from './primitives/index.js';
```
  </action>
  <verify>Run `npm run build` - Step should be importable from jsx.ts.</verify>
  <done>Step component exported from jsx.ts and primitives index.</done>
</task>

<task type="auto">
  <name>Task 3: Add StepNode to IR</name>
  <files>src/ir/nodes.ts</files>
  <action>
Add StepNode to the IR node types.

```typescript
/**
 * Step output variant
 */
export type StepVariant = 'heading' | 'bold' | 'xml';

/**
 * Numbered workflow step
 * Emits formatted step section based on variant
 */
export interface StepNode {
  kind: 'step';
  /** Step number (string to support "1.1" sub-steps) */
  number: string;
  /** Step name/title */
  name: string;
  /** Output format variant (default: 'heading') */
  variant: StepVariant;
  /** Step body content */
  children: BlockNode[];
}
```

Add StepNode to the BlockNode union type.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/ir/nodes.ts`</verify>
  <done>StepNode added to IR with variant field for output format selection.</done>
</task>

<task type="auto">
  <name>Task 4: Add Step transformation in transformer.ts</name>
  <files>src/parser/transformer.ts</files>
  <action>
Add transformation logic for Step component.

1. Add 'Step' to the SPECIAL_COMPONENTS set.

2. Import StepVariant and StepNode from ir (update existing import).

3. Create transformStep method:
```typescript
/**
 * Transform Step component to StepNode IR
 */
private transformStep(node: JsxElement | JsxSelfClosingElement): StepNode {
  const openingElement = Node.isJsxElement(node)
    ? node.getOpeningElement()
    : node;

  // Extract required props
  const numberAttr = getAttributeValue(openingElement, 'number');
  const name = getAttributeValue(openingElement, 'name');

  if (!numberAttr) {
    throw this.createError('Step requires number prop', openingElement);
  }
  if (!name) {
    throw this.createError('Step requires name prop', openingElement);
  }

  // Extract variant with default
  const variantAttr = getAttributeValue(openingElement, 'variant');
  let variant: 'heading' | 'bold' | 'xml' = 'heading'; // Default
  if (variantAttr === 'heading' || variantAttr === 'bold' || variantAttr === 'xml') {
    variant = variantAttr;
  }

  // Transform children
  const children = Node.isJsxElement(node)
    ? this.transformBlockChildren(node.getJsxChildren())
    : [];

  return {
    kind: 'step',
    number: numberAttr,
    name,
    variant,
    children,
  };
}
```

4. Add case to transformElement:
```typescript
if (name === 'Step') {
  return this.transformStep(node);
}
```
  </action>
  <verify>Run `npm run build` - transformer should compile with Step support.</verify>
  <done>Transformer converts Step JSX to StepNode IR with variant handling.</done>
</task>

<task type="auto">
  <name>Task 5: Add Step emission in emitter.ts</name>
  <files>src/emitter/emitter.ts</files>
  <action>
Add emission logic for StepNode with variant-based output.

1. Import StepNode and StepVariant from ir/index.js (update existing import).

2. Add case to emitBlock switch:
```typescript
case 'step':
  return this.emitStep(node);
```

3. Create emitStep method:
```typescript
/**
 * Emit StepNode as formatted step section
 *
 * Variants:
 * - 'heading': ## Step 1: Name
 * - 'bold': **Step 1: Name**
 * - 'xml': <step number="1" name="Name">...</step>
 */
private emitStep(node: StepNode): string {
  const { number, name, variant, children } = node;
  const parts: string[] = [];

  // Emit children content
  const childContent = children
    .map(child => this.emitBlock(child))
    .filter(s => s.length > 0)
    .join('\n\n');

  switch (variant) {
    case 'heading':
      // ## Step 1: Setup
      parts.push(`## Step ${number}: ${name}`);
      if (childContent) {
        parts.push(childContent);
      }
      break;

    case 'bold':
      // **Step 1: Setup**
      parts.push(`**Step ${number}: ${name}**`);
      if (childContent) {
        parts.push(childContent);
      }
      break;

    case 'xml':
      // <step number="1" name="Setup">...</step>
      parts.push(`<step number="${number}" name="${name}">`);
      if (childContent) {
        parts.push(childContent);
      }
      parts.push('</step>');
      break;

    default:
      // Fallback to heading
      parts.push(`## Step ${number}: ${name}`);
      if (childContent) {
        parts.push(childContent);
      }
  }

  return parts.join('\n\n');
}
```
  </action>
  <verify>Run `npm run build` - emitter should compile with Step emission.</verify>
  <done>StepNode emits as formatted step section with variant-based output.</done>
</task>

<task type="auto">
  <name>Task 6: Create test command to verify Step component</name>
  <files>src/app/test-step.tsx</files>
  <action>
Create a test command to verify Step component with all variants:

```tsx
import { Command, Step, Markdown } from '../jsx.js';

export default function TestStep() {
  return (
    <Command name="test-step" description="Test Step component variants">
      <h1>Step Component Test</h1>

      <Markdown>
## Heading Variant (default)
      </Markdown>

      <Step number={1} name="Setup Environment">
        <p>Install dependencies and configure your development environment.</p>
      </Step>

      <Step number={2} name="Configure Settings">
        <p>Update the configuration file with your settings.</p>
      </Step>

      <Markdown>
## Bold Variant
      </Markdown>

      <Step number={3} name="Build Project" variant="bold">
        <p>Run the build command to compile the project.</p>
      </Step>

      <Step number={4} name="Run Tests" variant="bold">
        <p>Execute the test suite to verify functionality.</p>
      </Step>

      <Markdown>
## XML Variant
      </Markdown>

      <Step number={5} name="Deploy" variant="xml">
        <p>Deploy the application to production.</p>
      </Step>

      <Markdown>
## Sub-steps (using string number)
      </Markdown>

      <Step number="1.1" name="Install Node.js">
        <p>Download and install Node.js from nodejs.org.</p>
      </Step>

      <Step number="1.2" name="Install npm packages">
        <p>Run npm install in the project directory.</p>
      </Step>
    </Command>
  );
}
```

Build and verify:
```bash
npm run build
node dist/cli/index.js build src/app/test-step.tsx
cat .claude/commands/test-step.md
```

Verify output contains:
1. `## Step 1: Setup Environment` (heading variant)
2. `## Step 2: Configure Settings` (heading variant)
3. `**Step 3: Build Project**` (bold variant)
4. `**Step 4: Run Tests**` (bold variant)
5. `<step number="5" name="Deploy">` (xml variant)
6. `## Step 1.1: Install Node.js` (sub-step)
7. `## Step 1.2: Install npm packages` (sub-step)
  </action>
  <verify>Build and run test command. Output should show all three variants and sub-step numbering.</verify>
  <done>Step component works with all variants (heading, bold, xml) and sub-step numbering.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. `npx tsc --noEmit` passes
3. Build test-step.tsx: `node dist/cli/index.js build src/app/test-step.tsx`
4. Output file contains:
   - `## Step N: Name` for heading variant (default)
   - `**Step N: Name**` for bold variant
   - `<step number="N" name="Name">` for xml variant
   - Sub-step numbering works (1.1, 1.2)
5. Step exported from jsx.ts
6. Clean up: `rm src/app/test-step.tsx .claude/commands/test-step.md`
</verification>

<success_criteria>
- `<Step number={1} name="Setup">` emits numbered workflow section
- Default variant is 'heading' (## Step 1: Setup)
- `variant="bold"` emits **Step 1: Setup**
- `variant="xml"` emits <step number="1" name="Setup">...</step>
- Sub-step numbering works (number="1.1")
- TypeScript enforces required props (number, name)
- Step component exported from jsx.ts
</success_criteria>

<output>
After completion, create `.planning/phases/23-context-access-patterns/23-03-SUMMARY.md`
</output>
