---
phase: 23-context-access-patterns
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - src/primitives/control.ts
  - src/workflow/agents/Agent.ts
  - src/ir/nodes.ts
autonomous: true

must_haves:
  truths:
    - "<If<T>> accepts explicit generic type parameter for compile-time type checking"
    - "<Loop<T>> accepts explicit generic type parameter representing item type"
    - "Generics are compile-time only - no runtime overhead or validation"
    - "Existing components without generics continue to work unchanged"
    - "TypeScript infers types from props when possible"
  artifacts:
    - path: "src/primitives/control.ts"
      provides: "Generic IfProps<T> interface and If<T> component"
      exports: ["If", "IfProps"]
    - path: "src/workflow/agents/Agent.ts"
      provides: "Generic SpawnAgentProps<T> already exists - verify/document"
      exports: ["SpawnAgent", "SpawnAgentProps"]
    - path: "src/ir/nodes.ts"
      provides: "IfNode with optional typeParam field"
      contains: "typeParam"
  key_links:
    - from: "src/primitives/control.ts"
      to: "TypeScript compiler"
      via: "generic constraint"
      pattern: "IfProps<T"
---

<objective>
Add explicit generic type parameters to workflow components (If, Loop) for compile-time type safety.

Purpose: Enable `<If<Config>>` and `<Loop<User>>` syntax where the generic provides TypeScript validation during development. Generics are purely compile-time and don't affect markdown output.

Output: Updated component interfaces with generic type parameters, preserving backwards compatibility for non-generic usage.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/23-context-access-patterns/23-CONTEXT.md
@.planning/phases/23-context-access-patterns/23-RESEARCH.md
@.planning/phases/23-context-access-patterns/23-01-SUMMARY.md

@src/primitives/control.ts
@src/workflow/agents/Agent.ts
@src/ir/nodes.ts
@src/parser/transformer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add generic type parameter to If component</name>
  <files>src/primitives/control.ts</files>
  <action>
Update the If component to accept an optional generic type parameter.

The generic provides compile-time type information but doesn't change runtime behavior.
Use `unknown` as default to maintain backwards compatibility.

Update IfProps and If function:
```typescript
/**
 * Props for the If component
 * @typeParam T - Optional type for compile-time context (e.g., config shape)
 */
export interface IfProps<T = unknown> {
  /** Shell test expression (e.g., "[ -f config.json ]") */
  test: string;
  /** "then" block content */
  children?: ReactNode;
  // T is compile-time only - used for type-safe context access
}

/**
 * If component - conditional block for prose-based conditionals
 *
 * This is a compile-time component transformed by react-agentic.
 * It's never executed at runtime. Emits as **If {test}:** pattern.
 *
 * @typeParam T - Optional type parameter for compile-time validation
 * @example
 * // Basic usage (no generic)
 * <If test="[ -f config.json ]">
 *   <p>Config found, loading...</p>
 * </If>
 *
 * @example with explicit generic for type context
 * interface ProjectConfig { debug: boolean; }
 * <If<ProjectConfig> test="[ -f config.json ]">
 *   <p>Config will have debug property when loaded.</p>
 * </If>
 */
export function If<T = unknown>(_props: IfProps<T>): null {
  return null;
}
```

Note: The generic `T` is purely for TypeScript's benefit during development.
It doesn't appear in props or affect transformation - it's erased at compile time.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/primitives/control.ts`</verify>
  <done>If component accepts optional generic type parameter <T> for compile-time type context.</done>
</task>

<task type="auto">
  <name>Task 2: Create Loop component with generic type parameter</name>
  <files>src/primitives/control.ts</files>
  <action>
Add a new Loop component that accepts a generic type representing the item type in an array iteration.

Note: This is a compile-time component for expressing iteration intent. The actual iteration
happens at Claude runtime, not during TSX compilation. The generic helps TypeScript validate
that the items array matches expected type.

Add to control.ts after the If/Else components:
```typescript
/**
 * Props for the Loop component
 * @typeParam T - Type of items in the array (inferred or explicit)
 */
export interface LoopProps<T = unknown> {
  /** Array of items to iterate over - type-safe via generic */
  items?: T[];
  /** Variable name for the current item in iteration */
  as?: string;
  /** Loop body content */
  children?: ReactNode;
}

/**
 * Loop component - iteration block for repeated content
 *
 * This is a compile-time component that emits markdown describing
 * an iteration pattern. Claude interprets and executes the loop.
 *
 * @typeParam T - Type of items being iterated (defaults to unknown)
 * @example
 * // Basic usage with inferred type
 * <Loop items={['a', 'b', 'c']} as="item">
 *   <p>Process item</p>
 * </Loop>
 *
 * @example with explicit generic
 * interface User { name: string; email: string; }
 * <Loop<User> items={users} as="user">
 *   <p>Greet user by name</p>
 * </Loop>
 */
export function Loop<T = unknown>(_props: LoopProps<T>): null {
  return null;
}
```

Export the new component and types from jsx.ts:
```typescript
// Add to jsx.ts exports:
export { Loop, type LoopProps } from './primitives/control.js';
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/primitives/control.ts`. Check that Loop is exported from jsx.ts.</verify>
  <done>Loop component created with generic type parameter <T> representing item type.</done>
</task>

<task type="auto">
  <name>Task 3: Add LoopNode to IR and basic transformer support</name>
  <files>src/ir/nodes.ts, src/parser/transformer.ts</files>
  <action>
Add LoopNode IR type and basic transformer support.

1. Add to src/ir/nodes.ts:
```typescript
/**
 * Loop iteration block
 * Emits as iteration pattern for Claude to execute
 */
export interface LoopNode {
  kind: 'loop';
  /** Variable name for current item */
  as?: string;
  /** Array expression or placeholder */
  items?: string;
  /** Type parameter name if explicitly provided (compile-time info) */
  typeParam?: string;
  /** Loop body content */
  children: BlockNode[];
}
```

Add LoopNode to the BlockNode union.

2. Add transformer support in src/parser/transformer.ts:

Add 'Loop' to SPECIAL_COMPONENTS set.

Add transformation method:
```typescript
/**
 * Transform Loop component to LoopNode IR
 */
private transformLoop(node: JsxElement | JsxSelfClosingElement): LoopNode {
  const openingElement = Node.isJsxElement(node)
    ? node.getOpeningElement()
    : node;

  const as = getAttributeValue(openingElement, 'as');

  // Get items attribute as string representation
  const itemsAttr = openingElement.getAttribute('items');
  let items: string | undefined;
  if (itemsAttr && Node.isJsxAttribute(itemsAttr)) {
    const init = itemsAttr.getInitializer();
    if (init && Node.isJsxExpression(init)) {
      const expr = init.getExpression();
      if (expr) {
        items = expr.getText();
      }
    }
  }

  // Extract type argument if present
  const typeArgs = extractTypeArguments(node);
  const typeParam = typeArgs && typeArgs.length > 0 ? typeArgs[0] : undefined;

  // Transform children
  const children = Node.isJsxElement(node)
    ? this.transformBlockChildren(node.getJsxChildren())
    : [];

  return {
    kind: 'loop',
    as,
    items,
    typeParam,
    children,
  };
}
```

Add case to transformElement switch:
```typescript
if (name === 'Loop') {
  return this.transformLoop(node);
}
```
  </action>
  <verify>Run `npm run build` - should compile. Check LoopNode is in BlockNode union and transformer handles Loop element.</verify>
  <done>LoopNode added to IR and transformer converts Loop JSX to LoopNode.</done>
</task>

<task type="auto">
  <name>Task 4: Add LoopNode emission</name>
  <files>src/emitter/emitter.ts</files>
  <action>
Add emission logic for LoopNode to generate markdown loop description.

1. Import LoopNode (add to existing import from ir/index.js).

2. Add case to emitBlock switch:
```typescript
case 'loop':
  return this.emitLoop(node);
```

3. Create emitLoop method:
```typescript
/**
 * Emit LoopNode as markdown loop description
 *
 * Output format:
 * **For each {as} in {items}:**
 * {children}
 */
private emitLoop(node: LoopNode): string {
  const parts: string[] = [];

  // Build loop header
  const varName = node.as || 'item';
  const itemsExpr = node.items || 'items';

  parts.push(`**For each ${varName} in ${itemsExpr}:**`);

  // Emit children with indentation context
  const childParts: string[] = [];
  for (const child of node.children) {
    childParts.push(this.emitBlock(child));
  }

  if (childParts.length > 0) {
    parts.push(childParts.join('\n\n'));
  }

  return parts.join('\n\n');
}
```
  </action>
  <verify>Run `npm run build` - emitter should compile. Check emitter.ts has emitLoop method and case 'loop' in emitBlock.</verify>
  <done>LoopNode emits as **For each X in Y:** markdown pattern.</done>
</task>

<task type="auto">
  <name>Task 5: Create test command to verify generic type parameters</name>
  <files>src/app/test-generics.tsx</files>
  <action>
Create a test command to verify generic type parameters work correctly:

```tsx
import { Command, If, Loop, Markdown } from '../jsx.js';

// Type definitions for compile-time checking
interface User {
  name: string;
  email: string;
}

interface ProjectConfig {
  debug: boolean;
  version: string;
}

export default function TestGenerics() {
  const users: User[] = [
    { name: 'Alice', email: 'alice@example.com' },
    { name: 'Bob', email: 'bob@example.com' },
  ];

  return (
    <Command name="test-generics" description="Test generic type parameters on components">
      <h1>Generic Type Parameters Test</h1>

      <Markdown>
## If with Generic

The If component can accept a generic type for compile-time context.
      </Markdown>

      <If<ProjectConfig> test="[ -f config.json ]">
        <p>Config file exists - it will have debug and version properties.</p>
      </If>

      <Markdown>
## Loop with Generic

The Loop component accepts a generic representing the item type.
      </Markdown>

      <Loop<User> items={users} as="user">
        <p>Process user with name and email properties.</p>
      </Loop>

      <Markdown>
## Non-generic usage (backwards compatible)

Components work without generics - existing code is unaffected.
      </Markdown>

      <If test="[ -d ./src ]">
        <p>Source directory exists.</p>
      </If>

      <Loop items={['one', 'two', 'three']} as="item">
        <p>Process string item.</p>
      </Loop>
    </Command>
  );
}
```

Build and verify:
```bash
npm run build
node dist/cli/index.js build src/app/test-generics.tsx
cat .claude/commands/test-generics.md
```

Verify:
1. TypeScript compiles without errors (generics are valid)
2. Output contains If conditionals and Loop iterations
3. Non-generic usage still works
4. Type errors would occur if wrong type passed (e.g., `<If<string>` when context expects object)
  </action>
  <verify>TypeScript compiles with generic usage. Build produces valid markdown. Type mismatches would cause compile errors.</verify>
  <done>Generic type parameters work on If and Loop components for compile-time type checking.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. `npx tsc --noEmit` passes with generic usage
3. Build test-generics.tsx: `node dist/cli/index.js build src/app/test-generics.tsx`
4. Output contains:
   - **If [test]:** patterns
   - **For each X in Y:** patterns
5. Non-generic components still work
6. Type errors occur for incorrect generic usage (compile-time)
7. Clean up: `rm src/app/test-generics.tsx .claude/commands/test-generics.md`
</verification>

<success_criteria>
- `<If<T>>` accepts generic type parameter for compile-time type context
- `<Loop<T>>` accepts generic type parameter representing item type in array
- Generics are compile-time only - no runtime overhead
- Non-generic usage works unchanged (backwards compatible)
- TypeScript validates generic constraints during development
- LoopNode added to IR and emits as **For each X in Y:** pattern
</success_criteria>

<output>
After completion, create `.planning/phases/23-context-access-patterns/23-02-SUMMARY.md`
</output>
