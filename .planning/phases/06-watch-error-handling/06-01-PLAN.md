---
phase: 06-watch-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/errors.ts
  - src/cli/output.ts
  - src/parser/transformer.ts
  - src/cli/commands/build.ts
autonomous: true

must_haves:
  truths:
    - "Transpilation errors display file path, line number, and column"
    - "Error messages show code snippet with caret pointing to problem location"
    - "CLI exits with code 1 when any transpilation fails"
    - "All errors are collected and reported together (not stop at first)"
  artifacts:
    - path: "src/cli/errors.ts"
      provides: "TranspileError class and error formatting"
      exports: ["TranspileError", "formatTranspileError"]
    - path: "src/cli/output.ts"
      provides: "Updated error logging with source location"
      contains: "logTranspileError"
    - path: "src/parser/transformer.ts"
      provides: "Error throwing with node position context"
      contains: "getNodeLocation"
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/cli/errors.ts"
      via: "throws TranspileError with node position"
      pattern: "throw new TranspileError"
    - from: "src/cli/commands/build.ts"
      to: "src/cli/output.ts"
      via: "formats and displays errors"
      pattern: "logTranspileError"
---

<objective>
Add source-located error messages to the CLI transpiler.

Purpose: Users need to see exactly where errors occur (file:line:col) with code context to quickly fix issues. This is fundamental for developer experience and required before watch mode can provide useful feedback.

Output: TranspileError class, TypeScript-style error formatting, updated transformer with position tracking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-watch-error-handling/06-RESEARCH.md
@.planning/phases/06-watch-error-handling/06-CONTEXT.md

@src/cli/commands/build.ts
@src/cli/output.ts
@src/parser/transformer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error utilities with source location support</name>
  <files>src/cli/errors.ts</files>
  <action>
Create a new errors module with:

1. `SourceLocation` interface:
   - file: string (absolute path)
   - line: number (1-based)
   - column: number (1-based)

2. `TranspileError` class extending Error:
   - Constructor takes: message, location (optional SourceLocation), sourceCode (optional string)
   - Store all properties for later formatting
   - Set error name to 'TranspileError'

3. `formatTranspileError(error: TranspileError): string` function:
   - TypeScript-style format: `file:line:col - error: message`
   - If sourceCode provided, show the error line with caret:
     ```
     file.tsx:15:10 - error: Command requires name prop

       15 | <Command description="test">
          |          ^
     ```
   - Use picocolors for:
     - File path: cyan
     - Line/column: dim
     - "error:": red
     - Message: default
     - Code line: dim line number, default code
     - Caret: red

4. `getNodeLocation(node: Node): SourceLocation` helper:
   - Import Node from ts-morph
   - Use `node.getSourceFile().getLineAndColumnAtPos(node.getStart())`
   - Return file path and 1-based line/column

Export: TranspileError, formatTranspileError, getNodeLocation, SourceLocation
  </action>
  <verify>File exists, TypeScript compiles with `npm run typecheck`</verify>
  <done>errors.ts exports TranspileError class, formatTranspileError function, and getNodeLocation helper</done>
</task>

<task type="auto">
  <name>Task 2: Update transformer to throw TranspileError with source location</name>
  <files>src/parser/transformer.ts, src/cli/output.ts, src/cli/commands/build.ts</files>
  <action>
Update the transformer to capture node positions when throwing errors:

1. In `src/parser/transformer.ts`:
   - Import `TranspileError` and `getNodeLocation` from '../cli/errors.js'
   - Replace all `throw new Error(...)` with `throw new TranspileError(...)` that include:
     - The error message
     - Source location from the current node being processed
     - Source code from the source file
   - Key error sites to update:
     - "Command requires name prop" (transformCommand)
     - "Command requires description prop" (transformCommand)
     - "Expected <li> inside list" (transformList)
     - "Lists can only contain <li>" (transformList)
     - "<a> element requires href" (transformLink)
     - "Unsupported block element" (transformElement)
     - "Unsupported inline element" (transformInlineElement)
     - "Invalid XML tag name" (transformDiv)
     - "Component props not supported" (transformCustomComponent)
     - "Cannot resolve component" (transformCustomComponent)

2. In `src/cli/output.ts`:
   - Import TranspileError and formatTranspileError from './errors.js'
   - Add `logTranspileError(error: TranspileError): void` function
     - Call formatTranspileError and output to console.error
   - Keep existing logError for non-transpile errors

3. In `src/cli/commands/build.ts`:
   - Import TranspileError from '../errors.js'
   - Import logTranspileError from '../output.js'
   - In catch block, check `if (error instanceof TranspileError)`:
     - Use logTranspileError(error)
   - Otherwise fall back to existing logError with message

Note: The transformer methods receive nodes, so you have access to position info. For methods where you need the node but only have its name, ensure you're passing the node through the call chain.
  </action>
  <verify>
    - `npm run typecheck` passes
    - `npm test` passes
    - Create a test TSX file with missing Command name prop, run build, verify output shows file:line:col format
  </verify>
  <done>Transpilation errors show TypeScript-style format with file path, line, column, and code snippet with caret</done>
</task>

</tasks>

<verification>
1. Create test file `test-error.tsx`:
   ```tsx
   export default <Command description="Missing name">
     <p>Content</p>
   </Command>
   ```

2. Run `npx tsx src/cli/index.ts build test-error.tsx`

3. Verify output includes:
   - File path with line and column
   - Error message
   - Code snippet with caret pointing to error location
   - Red "error:" text
   - Exit code 1

4. Clean up: `rm test-error.tsx`
</verification>

<success_criteria>
- Error output shows: `file.tsx:line:col - error: message`
- Code snippet displayed with line number and caret
- All existing tests still pass
- Exit code is 1 when errors occur
</success_criteria>

<output>
After completion, create `.planning/phases/06-watch-error-handling/06-01-SUMMARY.md`
</output>
