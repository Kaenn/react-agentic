---
phase: 21-structured-props
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - src/parser/transformer.ts
  - src/emitter/emitter.ts
autonomous: true

must_haves:
  truths:
    - "<Table headers={...} rows={...} /> emits valid markdown table"
    - "<List items={...} /> emits bullet list"
    - "<List items={...} ordered /> emits numbered list"
    - "Pipe characters in cell content are escaped"
    - "Newlines in cell content are converted to spaces"
    - "Empty arrays emit empty string (no output)"
  artifacts:
    - path: "src/parser/transformer.ts"
      provides: "transformTable and transformList methods"
      contains: "transformTable"
    - path: "src/emitter/emitter.ts"
      provides: "emitTable method with markdown table generation"
      contains: "emitTable"
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/ir/nodes.ts"
      via: "TableNode creation"
      pattern: "kind: 'table'"
    - from: "src/emitter/emitter.ts"
      to: "emitBlock switch"
      via: "case handling"
      pattern: "case 'table'"
---

<objective>
Implement Table and List transformation and emission to generate valid markdown output.

Purpose: Complete the Table and List components by wiring them through the transformer (JSX -> IR) and emitter (IR -> markdown). This enables `<Table>` and `<List>` to produce actual markdown tables and lists.

Output: Working Table and List components that emit correct markdown when built.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-structured-props/21-CONTEXT.md
@.planning/phases/21-structured-props/21-RESEARCH.md
@.planning/phases/21-structured-props/21-01-SUMMARY.md
@src/ir/nodes.ts
@src/parser/transformer.ts
@src/emitter/emitter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Table and List transformation in transformer.ts</name>
  <files>src/parser/transformer.ts</files>
  <action>
Add transformation logic for Table and List components.

1. Add 'Table' and 'List' to the BLOCK_ELEMENTS set (if categorizing elements).

2. Add import for TableNode to the IR imports at top of file.

3. Create transformTable method:
```typescript
/**
 * Transform Table component to TableNode IR
 */
private transformTable(node: JsxElement | JsxSelfClosingElement): TableNode {
  const opening = Node.isJsxElement(node) ? node.getOpeningElement() : node;

  // Parse array props
  const headers = getArrayAttributeValue(opening, 'headers');
  const rows = this.parseRowsAttribute(opening);
  const alignRaw = getArrayAttributeValue(opening, 'align');
  const emptyCell = getAttributeValue(opening, 'emptyCell');

  // Convert align strings to typed array
  const align = alignRaw?.map(a => {
    if (a === 'left' || a === 'center' || a === 'right') return a;
    return 'left'; // Default invalid values to left
  }) as ('left' | 'center' | 'right')[] | undefined;

  return {
    kind: 'table',
    headers: headers?.length ? headers : undefined,
    rows: rows,
    align: align,
    emptyCell: emptyCell || undefined,
  };
}

/**
 * Parse rows attribute (array of arrays)
 */
private parseRowsAttribute(opening: JsxOpeningElement | JsxSelfClosingElement): string[][] {
  const attr = opening.getAttribute('rows');
  if (!attr || !Node.isJsxAttribute(attr)) return [];

  const init = attr.getInitializer();
  if (!init || !Node.isJsxExpression(init)) return [];

  const expr = init.getExpression();
  if (!expr || !Node.isArrayLiteralExpression(expr)) return [];

  const rows: string[][] = [];
  for (const element of expr.getElements()) {
    if (Node.isArrayLiteralExpression(element)) {
      const row: string[] = [];
      for (const cell of element.getElements()) {
        // Handle string literals, numbers, and expressions
        if (Node.isStringLiteral(cell)) {
          row.push(cell.getLiteralValue());
        } else if (Node.isNumericLiteral(cell)) {
          row.push(cell.getLiteralValue().toString());
        } else {
          row.push(cell.getText());
        }
      }
      rows.push(row);
    }
  }
  return rows;
}
```

4. Create transformPropList method for prop-based List component:
```typescript
/**
 * Transform List component (prop-based) to ListNode IR
 * This is separate from HTML <ul>/<ol> transformation
 */
private transformPropList(node: JsxElement | JsxSelfClosingElement): ListNode {
  const opening = Node.isJsxElement(node) ? node.getOpeningElement() : node;

  // Parse props
  const items = getArrayAttributeValue(opening, 'items') ?? [];
  const ordered = getAttributeValue(opening, 'ordered') === 'true' ||
                  opening.getAttribute('ordered') !== undefined; // Handle boolean attr
  const startAttr = getAttributeValue(opening, 'start');
  const start = startAttr ? parseInt(startAttr, 10) : undefined;

  // Convert items to ListItemNode[]
  const listItems: ListItemNode[] = items.map(item => ({
    kind: 'listItem' as const,
    children: [{
      kind: 'paragraph' as const,
      children: [{ kind: 'text' as const, value: String(item) }]
    }]
  }));

  return {
    kind: 'list',
    ordered,
    items: listItems,
    start,
  };
}
```

5. Add cases to the element transformation switch:
```typescript
case 'Table':
  return this.transformTable(element);
case 'List':
  return this.transformPropList(element);
```

Note: Need to import ArrayLiteralExpression from ts-morph if not already imported.
  </action>
  <verify>Run `npm run build` - transformer should compile. Check transformer.ts has transformTable and transformPropList methods.</verify>
  <done>Table and List JSX elements transform to TableNode and ListNode IR.</done>
</task>

<task type="auto">
  <name>Task 2: Add Table emission in emitter.ts</name>
  <files>src/emitter/emitter.ts</files>
  <action>
Add emission logic for TableNode to generate valid markdown tables.

1. Add TableNode to the imports from ir/index.js.

2. Add case in emitBlock switch:
```typescript
case 'table':
  return this.emitTable(node);
```

3. Create emitTable method:
```typescript
/**
 * Emit TableNode as markdown table
 *
 * Output format:
 * | Header1 | Header2 |
 * | :--- | :---: |
 * | Cell1 | Cell2 |
 */
private emitTable(node: TableNode): string {
  const { headers, rows, align, emptyCell = '' } = node;

  // Empty table: no headers and no rows
  if (!headers?.length && rows.length === 0) return '';

  // Determine column count from headers or first row
  const columnCount = headers?.length ?? rows[0]?.length ?? 0;
  if (columnCount === 0) return '';

  // Build alignments array (default to 'left')
  const alignments = align ?? [];
  const getAlign = (i: number): 'left' | 'center' | 'right' =>
    alignments[i] ?? 'left';

  const lines: string[] = [];

  // Header row (if present)
  if (headers?.length) {
    const headerCells = headers.map(h => this.escapeTableCell(h, emptyCell));
    lines.push('| ' + headerCells.join(' | ') + ' |');
  }

  // Separator row with alignment markers
  const separators: string[] = [];
  for (let i = 0; i < columnCount; i++) {
    const a = getAlign(i);
    switch (a) {
      case 'left':
        separators.push(':---');
        break;
      case 'center':
        separators.push(':---:');
        break;
      case 'right':
        separators.push('---:');
        break;
    }
  }
  lines.push('| ' + separators.join(' | ') + ' |');

  // Data rows
  for (const row of rows) {
    // Pad row to column count if needed
    const cells: string[] = [];
    for (let i = 0; i < columnCount; i++) {
      const value = row[i] ?? '';
      cells.push(this.escapeTableCell(String(value), emptyCell));
    }
    lines.push('| ' + cells.join(' | ') + ' |');
  }

  return lines.join('\n');
}

/**
 * Escape table cell content
 * - Strips newlines (converts to space)
 * - Escapes pipe characters
 * - Replaces empty with emptyCell value
 */
private escapeTableCell(content: string, emptyCell: string): string {
  if (!content) return emptyCell;

  // Strip newlines (convert to single space)
  let escaped = content.replace(/\n/g, ' ');

  // Escape pipe characters
  escaped = escaped.replace(/\|/g, '\\|');

  return escaped || emptyCell;
}
```

4. Update ListNode emission to support `start` property.
Find the existing emitList method and update the list item emission to use start number:
```typescript
// In emitList method, update the listStack push:
this.listStack.push({
  ordered: node.ordered,
  index: node.start ?? 1  // Use start if provided, default to 1
});
```
  </action>
  <verify>Run `npm run build` - emitter should compile. Check emitter.ts has emitTable method and case 'table' in emitBlock.</verify>
  <done>TableNode emits valid markdown table. ListNode respects start property for ordered lists.</done>
</task>

<task type="auto">
  <name>Task 3: Create test command to verify Table and List output</name>
  <files>src/app/test-table-list.tsx</files>
  <action>
Create a test command file to verify Table and List components work correctly:

```tsx
import { Command, Table, List, Markdown } from '../jsx.js';

export default function TestTableList() {
  return (
    <Command name="test-table-list" description="Test Table and List components">
      <h2>Table Test</h2>

      <Markdown>
### Basic Table
      </Markdown>

      <Table
        headers={["Name", "Age", "City"]}
        rows={[
          ["Alice", "30", "New York"],
          ["Bob", "25", "Los Angeles"],
        ]}
      />

      <Markdown>
### Table with Alignment
      </Markdown>

      <Table
        headers={["Left", "Center", "Right"]}
        rows={[
          ["L1", "C1", "R1"],
          ["L2", "C2", "R2"],
        ]}
        align={["left", "center", "right"]}
      />

      <Markdown>
### Table with Pipe Character
      </Markdown>

      <Table
        headers={["Command", "Description"]}
        rows={[
          ["cat file | grep pattern", "Filter with pipe"],
          ["Normal cell", "No special chars"],
        ]}
      />

      <Markdown>
### Headerless Table
      </Markdown>

      <Table
        rows={[
          ["A", "B", "C"],
          ["1", "2", "3"],
        ]}
      />

      <h2>List Test</h2>

      <Markdown>
### Bullet List
      </Markdown>

      <List items={["First item", "Second item", "Third item"]} />

      <Markdown>
### Ordered List
      </Markdown>

      <List items={["Step one", "Step two", "Step three"]} ordered />

      <Markdown>
### Ordered List with Start
      </Markdown>

      <List items={["Continue from five", "Six", "Seven"]} ordered start={5} />
    </Command>
  );
}
```

After creating, build and verify output:
```bash
npm run build
node dist/cli/index.js build src/app/test-table-list.tsx
cat .claude/commands/test-table-list.md
```

Verify output contains:
1. Markdown tables with correct `| ... |` syntax
2. Alignment markers (`:---`, `:---:`, `---:`)
3. Escaped pipe in "cat file | grep pattern" row
4. Bullet list with `- ` markers
5. Ordered list starting at 5
  </action>
  <verify>Build and run test command. Output should show valid markdown tables and lists. Verify pipe escaping works.</verify>
  <done>Test command demonstrates working Table and List components with correct markdown output.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors
2. Build test-table-list.tsx: `node dist/cli/index.js build src/app/test-table-list.tsx`
3. Output file .claude/commands/test-table-list.md contains:
   - Valid markdown tables with `| Header | Header |` format
   - Separator row with alignment syntax (`:---`, `:---:`, `---:`)
   - Escaped pipes: `\|` in cell content
   - Bullet list: `- item` format
   - Ordered list: `1. item` format
   - Ordered list starting at 5: `5. item`
4. Clean up test file after verification: `rm src/app/test-table-list.tsx .claude/commands/test-table-list.md`
</verification>

<success_criteria>
- `<Table headers={["A", "B"]} rows={[["1", "2"], ["3", "4"]]} />` emits markdown table
- `<List items={["item1", "item2"]} />` emits markdown bullet list
- `<List items={...} ordered />` emits numbered list
- `<List items={...} ordered start={5} />` starts numbering at 5
- Pipe characters in cell content are escaped as `\|`
- Newlines in cell content are converted to spaces
- Empty arrays render nothing (empty string output)
- TypeScript enforces prop types at compile time
</success_criteria>

<output>
After completion, create `.planning/phases/21-structured-props/21-02-SUMMARY.md`
</output>
