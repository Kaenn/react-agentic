---
phase: 15-command-output-handling
plan: 03
type: execute
wave: 3
depends_on: ["15-02"]
files_modified:
  - src/emitter/emitter.ts
  - src/app/gsd/gsd-plan-phase.tsx
autonomous: true

must_haves:
  truths:
    - "OnStatus emits as **On STATUS:** prose pattern"
    - "Multiple OnStatus blocks emit as sequential conditional sections"
    - "Field interpolation placeholders preserved in output"
  artifacts:
    - path: "src/emitter/emitter.ts"
      provides: "emitOnStatus method"
      contains: "emitOnStatus"
    - path: "src/app/gsd/gsd-plan-phase.tsx"
      provides: "Test command demonstrating OnStatus usage"
      contains: "OnStatus"
  key_links:
    - from: "emitBlock switch"
      to: "emitOnStatus"
      via: "case 'onStatus'"
      pattern: "case 'onStatus'"
---

<objective>
Add emitter support for OnStatusNode and create a test command demonstrating the complete useOutput/OnStatus workflow.

Purpose: Complete the compiler pipeline so OnStatus components emit as status-based conditional prose blocks, enabling commands to handle agent outputs with type-safe status discrimination.

Output: Updated emitter with emitOnStatus, working test command demonstrating the feature.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-command-output-handling/15-RESEARCH.md
@.planning/phases/15-command-output-handling/15-01-SUMMARY.md
@.planning/phases/15-command-output-handling/15-02-SUMMARY.md

@src/emitter/emitter.ts
@src/app/gsd/gsd-plan-phase.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add emitOnStatus to emitter</name>
  <files>src/emitter/emitter.ts</files>
  <action>
Update imports to include OnStatusNode:
```typescript
import type {
  // ... existing imports ...
  OnStatusNode,  // Add this
} from '../ir/index.js';
```

In emitBlock switch statement, add case for 'onStatus' after 'else' case:
```typescript
case 'onStatus':
  return this.emitOnStatus(node);
```

Add emitOnStatus method after emitElse:
```typescript
/**
 * Emit OnStatus node as prose-based status conditional
 *
 * Output format:
 * **On SUCCESS:**
 *
 * {content}
 */
private emitOnStatus(node: OnStatusNode): string {
  const parts: string[] = [];

  // Emit status header
  parts.push(`**On ${node.status}:**`);

  // Emit block content with blank line after header
  for (const child of node.children) {
    parts.push(this.emitBlock(child));
  }

  return parts.join('\n\n');
}
```

Note: Follow the emitIf/emitElse pattern exactly. The format is **On STATUS:** followed by the conditional content.
  </action>
  <verify>
1. `npm run build` succeeds with no errors
2. Verify emitBlock handles 'onStatus' case
3. Verify emitOnStatus method exists
  </verify>
  <done>emitOnStatus method emits **On STATUS:** header followed by children content, matching the If/Else prose pattern</done>
</task>

<task type="auto">
  <name>Task 2: Create test command with OnStatus</name>
  <files>src/app/gsd/gsd-plan-phase.tsx</files>
  <action>
Update the existing gsd-plan-phase.tsx to demonstrate OnStatus usage. This file already exists with SpawnAgent usage.

Add imports at top:
```typescript
import { useOutput, OnStatus } from '../../jsx.js';
import type { /* existing imports */, BaseOutput } from '../../jsx.js';
```

If there's already a ResearcherOutput type defined (from Phase 14), use it. Otherwise, define a simple output type:
```typescript
// Example output type for demonstration
interface PhaseResearchOutput extends BaseOutput {
  confidence?: 'HIGH' | 'MEDIUM' | 'LOW';
  findings?: string[];
  blockedBy?: string;
}
```

After the SpawnAgent component, add useOutput and OnStatus blocks:
```typescript
// After SpawnAgent for researcher
const researchOutput = useOutput<PhaseResearchOutput>("gsd-phase-researcher");

// In the JSX, after the SpawnAgent:
<h2>Handle Research Result</h2>

<OnStatus output={researchOutput} status="SUCCESS">
  <p>Research complete with {researchOutput.field('confidence')} confidence.</p>
  <p>Proceeding to planning phase with findings.</p>
</OnStatus>

<OnStatus output={researchOutput} status="BLOCKED">
  <p>Research blocked by: {researchOutput.field('blockedBy')}</p>
  <p>Cannot proceed until blocker is resolved.</p>
</OnStatus>

<OnStatus output={researchOutput} status="ERROR">
  <p>Research failed. Check error details above and retry.</p>
</OnStatus>
```

Note: The agent name in useOutput must match the agent prop in SpawnAgent. Check the existing SpawnAgent in the file for the correct agent name.
  </action>
  <verify>
1. `npm run build` succeeds
2. Build the command: `node dist/cli/index.js build src/app/gsd/gsd-plan-phase.tsx`
3. Check output in .claude/commands/gsd/plan-phase.md contains **On SUCCESS:**, **On BLOCKED:**, **On ERROR:** sections
4. Verify {output.confidence} and {output.blockedBy} placeholders are preserved
  </verify>
  <done>
Test command demonstrates:
- useOutput hook binding to spawned agent
- Multiple OnStatus blocks for different statuses (SUCCESS, BLOCKED, ERROR)
- Field interpolation with output.field('confidence') producing {output.confidence}
- Sequential conditional blocks in output
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `npm run build` completes without errors
2. Build test command: `node dist/cli/index.js build src/app/gsd/gsd-plan-phase.tsx`
3. Verify output markdown contains:
   - **On SUCCESS:** section with {output.confidence} placeholder
   - **On BLOCKED:** section with {output.blockedBy} placeholder
   - **On ERROR:** section
4. Multiple OnStatus blocks are sequential (not nested)
</verification>

<success_criteria>
- emitOnStatus produces **On {status}:** followed by content
- Test command builds successfully
- Generated markdown shows status-based conditional blocks
- Field placeholders ({output.fieldName}) preserved in output
- Multiple statuses handled sequentially
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/15-command-output-handling/15-03-SUMMARY.md`
</output>
