---
phase: 15-command-output-handling
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - src/ir/nodes.ts
  - src/parser/transformer.ts
autonomous: true

must_haves:
  truths:
    - "OnStatusNode exists in IR with outputRef, status, and children fields"
    - "Transformer recognizes OnStatus elements and extracts props"
    - "OnStatus outside Command/Agent throws meaningful error"
  artifacts:
    - path: "src/ir/nodes.ts"
      provides: "OnStatusNode interface and OutputReference type"
      contains: "interface OnStatusNode"
    - path: "src/parser/transformer.ts"
      provides: "transformOnStatus method"
      contains: "transformOnStatus"
  key_links:
    - from: "OnStatusNode"
      to: "BlockNode"
      via: "union member"
      pattern: "type BlockNode.*OnStatusNode"
    - from: "transformer.ts"
      to: "OnStatusNode"
      via: "transformOnStatus return type"
      pattern: "transformOnStatus.*OnStatusNode"
---

<objective>
Add OnStatusNode to the IR layer and implement transformer parsing for the OnStatus component.

Purpose: Enable the compiler to recognize and transform OnStatus elements into structured IR nodes that capture the output reference, status value, and conditional content.

Output: Updated IR with OnStatusNode type, transformer with transformOnStatus method.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-command-output-handling/15-RESEARCH.md
@.planning/phases/15-command-output-handling/15-01-SUMMARY.md

@src/ir/nodes.ts
@src/parser/transformer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add OnStatusNode to IR</name>
  <files>src/ir/nodes.ts</files>
  <action>
Add OutputReference and OnStatusNode interfaces after the ElseNode definition in the Block Nodes section.

Add OutputReference:
```typescript
/**
 * Reference to an agent's output in the IR
 * Captures the agent name for output binding
 */
export interface OutputReference {
  kind: 'outputReference';
  /** Agent name this output refers to */
  agent: string;
}
```

Add OnStatusNode:
```typescript
/**
 * OnStatus block - conditional based on agent return status
 * Emits as **On {status}:** prose pattern
 */
export interface OnStatusNode {
  kind: 'onStatus';
  /** Output reference from useOutput */
  outputRef: OutputReference;
  /** Status to match (SUCCESS, BLOCKED, etc.) */
  status: 'SUCCESS' | 'BLOCKED' | 'NOT_FOUND' | 'ERROR' | 'CHECKPOINT';
  /** Block content for this status */
  children: BlockNode[];
}
```

Update the BlockNode union type to include OnStatusNode:
```typescript
export type BlockNode =
  | HeadingNode
  | ParagraphNode
  | ListNode
  | CodeBlockNode
  | BlockquoteNode
  | ThematicBreakNode
  | XmlBlockNode
  | RawMarkdownNode
  | SpawnAgentNode
  | AssignNode
  | IfNode
  | ElseNode
  | OnStatusNode;  // Add this
```

Note: Follow the pattern from IfNode/ElseNode exactly. OnStatusNode has similar structure but with outputRef and status instead of test.
  </action>
  <verify>TypeScript compiles: `npm run build` succeeds, OnStatusNode is in BlockNode union</verify>
  <done>OnStatusNode interface defined with kind 'onStatus', outputRef, status, and children fields. BlockNode union includes OnStatusNode.</done>
</task>

<task type="auto">
  <name>Task 2: Add transformOnStatus to transformer</name>
  <files>src/parser/transformer.ts</files>
  <action>
Update imports at top of file to include OnStatusNode:
```typescript
import type {
  // ... existing imports ...
  OnStatusNode,  // Add this
} from '../ir/index.js';
```

Add 'OnStatus' to SPECIAL_COMPONENTS set:
```typescript
const SPECIAL_COMPONENTS = new Set(['Command', 'Markdown', 'XmlBlock', 'Agent', 'SpawnAgent', 'Assign', 'If', 'Else', 'OnStatus']);
```

In transformElement method, add handling for OnStatus after the Else case:
```typescript
// OnStatus component - status-based conditional block
if (name === 'OnStatus') {
  return this.transformOnStatus(node);
}
```

Add transformOnStatus method after transformElse:
```typescript
/**
 * Transform an OnStatus element to OnStatusNode
 * OnStatus is a block-level element that emits status-based conditionals
 */
private transformOnStatus(node: JsxElement | JsxSelfClosingElement): OnStatusNode {
  const openingElement = Node.isJsxElement(node)
    ? node.getOpeningElement()
    : node;

  // Extract output prop (required) - must be a JSX expression referencing an identifier
  const outputAttr = openingElement.getAttribute('output');
  if (!outputAttr || !Node.isJsxAttribute(outputAttr)) {
    throw this.createError('OnStatus requires output prop', openingElement);
  }

  const outputInit = outputAttr.getInitializer();
  if (!outputInit || !Node.isJsxExpression(outputInit)) {
    throw this.createError('OnStatus output must be a JSX expression: output={outputRef}', openingElement);
  }

  const outputExpr = outputInit.getExpression();
  if (!outputExpr || !Node.isIdentifier(outputExpr)) {
    throw this.createError('OnStatus output must reference a useOutput result', openingElement);
  }

  // Get the identifier text - this is the agent name binding
  // Note: In a full implementation, we'd track useOutput calls like useVariable
  // For now, we extract agent name directly from the output ref identifier usage context
  // The actual agent name is in the useOutput call, but we can't easily resolve it here
  // So we'll need to get it from the output ref at runtime
  const outputIdentifier = outputExpr.getText();

  // Extract status prop (required)
  const status = getAttributeValue(openingElement, 'status');
  if (!status) {
    throw this.createError('OnStatus requires status prop', openingElement);
  }

  // Validate status is one of the allowed values
  const validStatuses = ['SUCCESS', 'BLOCKED', 'NOT_FOUND', 'ERROR', 'CHECKPOINT'];
  if (!validStatuses.includes(status)) {
    throw this.createError(
      `OnStatus status must be one of: ${validStatuses.join(', ')}. Got: ${status}`,
      openingElement
    );
  }

  // Transform children as block content
  const children = Node.isJsxElement(node)
    ? this.transformBlockChildren(node.getJsxChildren())
    : [];

  // We need to resolve the agent name from the useOutput call
  // For now, we'll store the identifier name and resolve at emit time
  // This mirrors how Assign works with useVariable
  return {
    kind: 'onStatus',
    outputRef: {
      kind: 'outputReference',
      agent: outputIdentifier,  // Will be resolved to actual agent name
    },
    status: status as OnStatusNode['status'],
    children,
  };
}
```

Important: The transformer extracts the output identifier text. The actual agent name resolution happens because useOutput returns an object with the agent property. We store the identifier for now.

Actually, we need to track useOutput calls similar to useVariable. Add tracking:

1. Add type for extracted outputs after ExtractedVariable type usage:
```typescript
/** Map of output identifier name -> agent name */
private outputs: Map<string, string> = new Map();
```

2. In transform() method initialization, add extraction of useOutput calls:
```typescript
if (sourceFile) {
  this.visitedPaths.add(sourceFile.getFilePath());
  this.variables = extractVariableDeclarations(sourceFile);
  this.outputs = this.extractOutputDeclarations(sourceFile);
}
```

3. Add extractOutputDeclarations method:
```typescript
/**
 * Extract useOutput declarations from source file
 * Returns map of identifier name -> agent name
 */
private extractOutputDeclarations(sourceFile: SourceFile): Map<string, string> {
  const outputs = new Map<string, string>();

  // Find all variable declarations
  for (const varDecl of sourceFile.getVariableDeclarations()) {
    const init = varDecl.getInitializer();
    if (!init) continue;

    // Check if initializer is useOutput call
    if (Node.isCallExpression(init)) {
      const expr = init.getExpression();
      if (Node.isIdentifier(expr) && expr.getText() === 'useOutput') {
        const args = init.getArguments();
        if (args.length >= 1) {
          const agentArg = args[0];
          // Get the string literal value (agent name)
          if (Node.isStringLiteral(agentArg)) {
            const agentName = agentArg.getLiteralValue();
            const identName = varDecl.getName();
            outputs.set(identName, agentName);
          }
        }
      }
    }
  }

  return outputs;
}
```

4. Update transformOnStatus to look up agent name:
```typescript
// Look up agent name from outputs map
const agentName = this.outputs.get(outputIdentifier);
if (!agentName) {
  throw this.createError(
    `Output '${outputIdentifier}' not found. Did you declare it with useOutput()?`,
    openingElement
  );
}

return {
  kind: 'onStatus',
  outputRef: {
    kind: 'outputReference',
    agent: agentName,
  },
  status: status as OnStatusNode['status'],
  children,
};
```

Note: Add the CallExpression import if not already present.
  </action>
  <verify>
1. `npm run build` succeeds with no errors
2. Check that transformOnStatus method exists and returns OnStatusNode
3. Verify SPECIAL_COMPONENTS includes 'OnStatus'
  </verify>
  <done>
- transformOnStatus method extracts output ref (resolves to agent name via useOutput tracking) and status prop
- Validates status is one of SUCCESS/BLOCKED/NOT_FOUND/ERROR/CHECKPOINT
- Children transformed as block content
- OnStatus added to SPECIAL_COMPONENTS
- useOutput calls tracked via extractOutputDeclarations
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `npm run build` completes without errors
2. OnStatusNode is in BlockNode union (check nodes.ts)
3. transformOnStatus method exists (check transformer.ts)
4. SPECIAL_COMPONENTS includes 'OnStatus'
</verification>

<success_criteria>
- OnStatusNode interface defined with outputRef: OutputReference, status: AgentStatus union, children: BlockNode[]
- BlockNode union includes OnStatusNode
- transformOnStatus extracts output prop (as identifier), status prop (validates against allowed values)
- useOutput declarations tracked similar to useVariable
- Errors thrown for missing props or invalid status values
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/15-command-output-handling/15-02-SUMMARY.md`
</output>
