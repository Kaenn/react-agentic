---
phase: 15-command-output-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/jsx.ts
autonomous: true

must_haves:
  truths:
    - "useOutput hook returns OutputRef with agent name and field accessor"
    - "OutputRef.field() method returns placeholder string {output.fieldName}"
    - "OnStatus component accepts output and status props"
  artifacts:
    - path: "src/jsx.ts"
      provides: "useOutput hook, OutputRef interface, OnStatus component"
      exports: ["useOutput", "OutputRef", "OnStatus", "OnStatusProps"]
  key_links:
    - from: "useOutput"
      to: "OutputRef<T>"
      via: "return type"
      pattern: "function useOutput.*OutputRef"
    - from: "OnStatus"
      to: "OutputRef"
      via: "output prop type"
      pattern: "output: OutputRef"
---

<objective>
Add useOutput hook and OnStatus component to the JSX layer for type-safe agent output handling.

Purpose: Provide compile-time type checking for accessing agent outputs in commands, following the established patterns from useVariable and If/Else components.

Output: Updated src/jsx.ts with new exports for useOutput, OutputRef, OnStatus, and OnStatusProps.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-command-output-handling/15-RESEARCH.md

@src/jsx.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add OutputRef interface and useOutput hook</name>
  <files>src/jsx.ts</files>
  <action>
Add OutputRef interface and useOutput hook after the Agent Output Types section (after BaseOutput interface).

Create a new section header:
```typescript
// ============================================================================
// Agent Output Handling (useOutput hook + OnStatus component)
// ============================================================================
```

Add OutputRef interface:
```typescript
/**
 * Reference to an agent's output from useOutput
 * @typeParam T - The agent's TOutput type (compile-time only)
 */
export interface OutputRef<T = unknown> {
  /** Agent name this output is bound to */
  agent: string;
  /** Field accessor - returns placeholder for interpolation */
  field: <K extends keyof T>(key: K) => string;
  /** Phantom type marker (compile-time only) */
  _type?: T;
}
```

Add useOutput hook:
```typescript
/**
 * Bind to a spawned agent's output for status-based handling
 *
 * This is a compile-time hook. The actual output binding happens at runtime
 * when the agent completes. The hook returns an OutputRef for use in OnStatus
 * and field interpolation.
 *
 * @typeParam T - The agent's TOutput type (must extend BaseOutput)
 * @param agentName - Agent name matching SpawnAgent's agent prop
 * @returns OutputRef for use in OnStatus and field interpolation
 *
 * @example
 * import type { ResearcherOutput } from './researcher.agent.js';
 *
 * const output = useOutput<ResearcherOutput>("researcher");
 *
 * // In JSX:
 * <OnStatus output={output} status="SUCCESS">
 *   <p>Research complete with {output.field('confidence')} confidence.</p>
 * </OnStatus>
 */
export function useOutput<T extends BaseOutput = BaseOutput>(
  agentName: string
): OutputRef<T> {
  return {
    agent: agentName,
    field: (key) => `{output.${String(key)}}`,
  };
}
```

Note: Follow the useVariable pattern exactly. The hook is compile-time only.
  </action>
  <verify>TypeScript compiles: `npm run build` succeeds with no errors in jsx.ts</verify>
  <done>OutputRef interface and useOutput hook exported from jsx.ts, field() returns {output.fieldName} placeholder</done>
</task>

<task type="auto">
  <name>Task 2: Add OnStatus component and props</name>
  <files>src/jsx.ts</files>
  <action>
Add OnStatusProps interface and OnStatus component after the useOutput hook in the same section.

Add OnStatusProps interface:
```typescript
/**
 * Props for the OnStatus component
 */
export interface OnStatusProps {
  /** Output reference from useOutput */
  output: OutputRef;
  /** Status value to match (SUCCESS, BLOCKED, etc.) */
  status: AgentStatus;
  /** Block content for this status */
  children?: ReactNode;
}
```

Add OnStatus component:
```typescript
/**
 * OnStatus component - conditional block for agent status handling
 *
 * This is a compile-time component transformed by react-agentic.
 * It's never executed at runtime. Emits as **On {status}:** pattern.
 *
 * @example
 * const output = useOutput<ResearcherOutput>("researcher");
 *
 * <OnStatus output={output} status="SUCCESS">
 *   <p>Research complete.</p>
 *   <p>Confidence: {output.field('confidence')}</p>
 * </OnStatus>
 * <OnStatus output={output} status="BLOCKED">
 *   <p>Research blocked by: {output.field('blockedBy')}</p>
 * </OnStatus>
 */
export function OnStatus(_props: OnStatusProps): null {
  return null;
}
```

Note: Follow the If/Else component pattern exactly. The component returns null because it's compile-time only.
  </action>
  <verify>TypeScript compiles: `npm run build` succeeds, OnStatus and OnStatusProps are exported</verify>
  <done>OnStatus component accepts output (OutputRef) and status (AgentStatus) props, returns null</done>
</task>

</tasks>

<verification>
After both tasks:
1. `npm run build` completes without errors
2. Check jsx.ts exports: useOutput, OutputRef, OnStatus, OnStatusProps all present
3. TypeScript validates: `const o = useOutput<{status:'SUCCESS'}>('test'); o.field('status')` compiles
</verification>

<success_criteria>
- useOutput<T> hook returns OutputRef<T> with agent name and typed field() method
- OutputRef.field('key') returns '{output.key}' placeholder string
- OnStatus component accepts output: OutputRef and status: AgentStatus props
- All new types exported from jsx.ts
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/15-command-output-handling/15-01-SUMMARY.md`
</output>
