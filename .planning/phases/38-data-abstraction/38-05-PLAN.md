---
phase: 38-data-abstraction
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ir/nodes.ts
  - src/parser/transformers/variables.ts
  - src/emitter/emitter.ts
  - tests/grammar/VariableComponents/assign-from.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "<Assign var={x} from={MyFn} args={{}} /> emits runtime function call"
    - "runtimeFn source type has IR representation"
    - "Transformer detects RuntimeFnComponent in from prop"
    - "Emitter handles runtimeFn assignment type"
  artifacts:
    - path: "src/ir/nodes.ts"
      provides: "runtimeFn type in AssignNode.assignment union"
      contains: "type: 'runtimeFn'"
    - path: "src/parser/transformers/variables.ts"
      provides: "RuntimeFnComponent detection in from prop"
      contains: "isRuntimeFn"
    - path: "src/emitter/emitter.ts"
      provides: "runtimeFn case in emitAssignmentLine"
      contains: "case 'runtimeFn'"
    - path: "tests/grammar/VariableComponents/assign-from.test.ts"
      provides: "Integration tests for runtimeFn source"
      contains: "runtimeFn() source"
  key_links:
    - from: "src/parser/transformers/variables.ts"
      to: "src/ir/nodes.ts"
      via: "creates AssignNode with type: 'runtimeFn'"
      pattern: "type: 'runtimeFn'"
    - from: "src/emitter/emitter.ts"
      to: "src/ir/nodes.ts"
      via: "switch case for runtimeFn"
      pattern: "case 'runtimeFn'"
---

<objective>
Add runtimeFn support to the unified Assign from prop pattern.

**Gap being closed:** Success criterion 7 failed verification: "`<Assign var={x} from={MyFn} args={{}} />` emits runtime function call" is not implemented.

**Purpose:** Complete the "all data sources" goal of Phase 38 by supporting runtime function assignment alongside file/bash/value/env sources.

**Output:**
- Extended IR with runtimeFn type in AssignNode.assignment union
- Transformer logic to detect RuntimeFnComponent in from prop
- Emitter case for runtimeFn with runtime.js invocation
- Integration tests proving the pattern works end-to-end
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-data-abstraction/38-02-SUMMARY.md

# Key files to modify
@src/ir/nodes.ts
@src/parser/transformers/variables.ts
@src/emitter/emitter.ts
@tests/grammar/VariableComponents/assign-from.test.ts

# Reference for RuntimeFn patterns
@src/components/runtime-fn.ts
@src/parser/transformers/runtime-call.ts
@src/emitter/runtime-markdown-emitter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add runtimeFn type to AssignNode IR</name>
  <files>src/ir/nodes.ts</files>
  <action>
Extend the AssignNode.assignment union in src/ir/nodes.ts to include a runtimeFn type.

Current union (line ~234):
```typescript
assignment:
  | { type: 'bash'; content: string; }
  | { type: 'value'; content: string; raw?: boolean; }
  | { type: 'env'; content: string; }
  | { type: 'file'; path: string; optional?: boolean; };
```

Add a new type for runtime function:
```typescript
| { type: 'runtimeFn'; fnName: string; args: Record<string, unknown>; }
```

The fnName is the function name (e.g., "initProject" from `const Init = runtimeFn(initProject)`).
The args are the arguments passed via the args prop.
  </action>
  <verify>npm run build succeeds</verify>
  <done>AssignNode.assignment union includes runtimeFn type</done>
</task>

<task type="auto">
  <name>Task 2: Update transformer to detect RuntimeFnComponent</name>
  <files>src/parser/transformers/variables.ts</files>
  <action>
Update the transformAssignWithFrom function to detect when the from prop value is a RuntimeFnComponent identifier (not a call expression).

Currently the function only handles CallExpression for source helpers (file, bash, value, env).
When from={MyFn} is used (where MyFn is a RuntimeFnComponent wrapper), the expression is an Identifier, not a CallExpression.

Add detection logic BEFORE the call expression check:

1. Import the isRuntimeFn type guard from runtime-fn.ts:
   - This won't work directly (compile-time analysis can't call runtime functions)
   - Instead, check if the identifier is in ctx.runtimeFunctions map (from RuntimeTransformContext)
   - Since transformAssignWithFrom uses basic TransformContext, NOT RuntimeTransformContext,
     we need to detect by checking if the identifier matches a known runtimeFn pattern

2. For V1 transformer (Agent builds), RuntimeFnComponent detection is simpler:
   - Check if expr is an Identifier
   - Check if the identifier name matches a runtimeFn wrapper in the source file
   - This requires looking at variable declarations: `const Init = runtimeFn(...)`

3. For simpler implementation that works in both V1 and V3:
   - Check if from expr is an Identifier (not CallExpression)
   - Check if the identifier name starts with uppercase (PascalCase = component convention)
   - Extract the function name by looking up the runtimeFn(...) declaration in the source file
   - Also extract args prop value

Implementation:
```typescript
// After checking Node.isCallExpression(expr), add:
if (Node.isIdentifier(expr)) {
  const identName = expr.getText();

  // Check if this is a RuntimeFn wrapper by looking for runtimeFn(fnName) pattern
  // in the source file's variable declarations
  const sourceFile = openingElement.getSourceFile();
  const fnName = findRuntimeFnName(sourceFile, identName);

  if (fnName) {
    // Extract args prop (required for runtimeFn)
    const argsAttr = openingElement.getAttribute('args');
    let args: Record<string, unknown> = {};

    if (argsAttr && Node.isJsxAttribute(argsAttr)) {
      const argsInit = argsAttr.getInitializer();
      if (argsInit && Node.isJsxExpression(argsInit)) {
        const argsExpr = argsInit.getExpression();
        if (argsExpr && Node.isObjectLiteralExpression(argsExpr)) {
          args = extractArgsObject(argsExpr);
        }
      }
    }

    return {
      kind: 'assign',
      variableName: variable.envName,
      assignment: { type: 'runtimeFn', fnName, args },
      ...(commentProp && { comment: commentProp }),
    };
  }
}
```

Add helper function to find runtimeFn name:
```typescript
function findRuntimeFnName(sourceFile: SourceFile, wrapperName: string): string | null {
  // Look for: const WrapperName = runtimeFn(fnName)
  for (const statement of sourceFile.getStatements()) {
    if (!Node.isVariableStatement(statement)) continue;

    for (const decl of statement.getDeclarationList().getDeclarations()) {
      if (decl.getName() !== wrapperName) continue;

      const init = decl.getInitializer();
      if (!init || !Node.isCallExpression(init)) continue;

      const callExpr = init.getExpression();
      if (!Node.isIdentifier(callExpr) || callExpr.getText() !== 'runtimeFn') continue;

      const args = init.getArguments();
      if (args.length > 0 && Node.isIdentifier(args[0])) {
        return args[0].getText();
      }
    }
  }
  return null;
}
```

Add helper to extract args object:
```typescript
function extractArgsObject(objExpr: ObjectLiteralExpression): Record<string, unknown> {
  const args: Record<string, unknown> = {};
  for (const prop of objExpr.getProperties()) {
    if (Node.isPropertyAssignment(prop)) {
      const name = prop.getName();
      const init = prop.getInitializer();
      if (init) {
        // Simple extraction for string/number/boolean literals
        if (Node.isStringLiteral(init)) args[name] = init.getLiteralValue();
        else if (Node.isNumericLiteral(init)) args[name] = Number(init.getLiteralValue());
        else if (init.getText() === 'true') args[name] = true;
        else if (init.getText() === 'false') args[name] = false;
        else args[name] = init.getText(); // Fallback to source text
      }
    }
  }
  return args;
}
```

Import SourceFile and ObjectLiteralExpression from ts-morph if not already imported.
  </action>
  <verify>npm run build succeeds</verify>
  <done>Transformer creates AssignNode with type: 'runtimeFn' when from prop is a RuntimeFnComponent</done>
</task>

<task type="auto">
  <name>Task 3: Add runtimeFn case to emitter</name>
  <files>src/emitter/emitter.ts</files>
  <action>
Add a case for 'runtimeFn' in the emitAssignmentLine switch statement.

Current switch (around line 586):
```typescript
switch (assignment.type) {
  case 'bash': ...
  case 'value': ...
  case 'env': ...
  case 'file': ...
}
```

Add runtimeFn case:
```typescript
case 'runtimeFn': {
  // Runtime function: VAR=$(node .claude/runtime/runtime.js fnName '{"key": "value"}')
  const argsJson = JSON.stringify(assignment.args);
  // Escape single quotes in JSON for bash
  const escapedJson = argsJson.replace(/'/g, "'\\''");
  line = `${variableName}=$(node .claude/runtime/runtime.js ${assignment.fnName} '${escapedJson}')`;
  break;
}
```

This matches the emit pattern used in runtime-markdown-emitter.ts for RuntimeCallNode.
  </action>
  <verify>npm run build succeeds</verify>
  <done>Emitter handles runtimeFn assignment type with runtime.js invocation</done>
</task>

<task type="auto">
  <name>Task 4: Add integration tests for runtimeFn source</name>
  <files>tests/grammar/VariableComponents/assign-from.test.ts</files>
  <action>
Add a new describe block for runtimeFn source tests.

```typescript
describe('runtimeFn() source', () => {
  it('emits VAR=$(node runtime.js fnName args) format', () => {
    const tsx = `
      import { useVariable, runtimeFn } from 'react-agentic';

      async function initProject(args: { path: string }): Promise<{ success: boolean }> {
        return { success: true };
      }
      const Init = runtimeFn(initProject);

      const RESULT = useVariable("RESULT");
      export default function Doc() {
        return (
          <Agent name="test" description="Test">
            <Assign var={RESULT} from={Init} args={{ path: "." }} />
          </Agent>
        );
      }
    `;
    const output = transformAgentContent(tsx, true);
    expect(output).toContain('RESULT=$(node .claude/runtime/runtime.js initProject');
    expect(output).toContain('{"path":"."}\')');
  });

  it('handles empty args object', () => {
    const tsx = `
      import { useVariable, runtimeFn } from 'react-agentic';

      async function getContext(args: {}): Promise<{ data: string }> {
        return { data: "test" };
      }
      const GetContext = runtimeFn(getContext);

      const CTX = useVariable("CTX");
      export default function Doc() {
        return (
          <Agent name="test" description="Test">
            <Assign var={CTX} from={GetContext} args={{}} />
          </Agent>
        );
      }
    `;
    const output = transformAgentContent(tsx, true);
    expect(output).toContain('CTX=$(node .claude/runtime/runtime.js getContext');
    expect(output).toContain("'{}'");
  });

  it('handles multiple arg properties', () => {
    const tsx = `
      import { useVariable, runtimeFn } from 'react-agentic';

      async function process(args: { id: number; name: string; active: boolean }): Promise<void> {
        return;
      }
      const Process = runtimeFn(process);

      const OUT = useVariable("OUT");
      export default function Doc() {
        return (
          <Agent name="test" description="Test">
            <Assign var={OUT} from={Process} args={{ id: 42, name: "test", active: true }} />
          </Agent>
        );
      }
    `;
    const output = transformAgentContent(tsx, true);
    expect(output).toContain('OUT=$(node .claude/runtime/runtime.js process');
    expect(output).toContain('"id":42');
    expect(output).toContain('"name":"test"');
    expect(output).toContain('"active":true');
  });
});
```
  </action>
  <verify>npm test tests/grammar/VariableComponents/assign-from.test.ts passes</verify>
  <done>Tests verify runtimeFn source pattern emits correct bash output</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with no TypeScript errors
2. `npm test tests/grammar/VariableComponents/assign-from.test.ts` passes all tests
3. `npm test` (full suite) passes without regressions
4. Verify AssignNode type is exhaustive in switch statements (no TypeScript errors)
</verification>

<success_criteria>
- [ ] AssignNode.assignment union includes `{ type: 'runtimeFn'; fnName: string; args: Record<string, unknown>; }`
- [ ] Transformer detects RuntimeFnComponent identifier in from prop
- [ ] Transformer extracts function name from `const X = runtimeFn(fnName)` pattern
- [ ] Transformer extracts args from args prop
- [ ] Emitter outputs `VAR=$(node .claude/runtime/runtime.js fnName 'args')` format
- [ ] Integration tests pass for runtimeFn source pattern
- [ ] Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/38-data-abstraction/38-05-SUMMARY.md`
</output>
