---
phase: 10-spawnagent-component
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/jsx.ts
  - src/parser/transformer.ts
  - tests/parser/spawnagent-transformer.test.ts
autonomous: true

must_haves:
  truths:
    - "SpawnAgent with all four props transforms to SpawnAgentNode"
    - "SpawnAgent preserves {variable} placeholders in model prop"
    - "SpawnAgent preserves {variable} placeholders in prompt prop"
    - "SpawnAgent throws clear error for missing required props"
  artifacts:
    - path: "src/jsx.ts"
      provides: "SpawnAgentProps interface and SpawnAgent component stub"
      contains: "interface SpawnAgentProps"
    - path: "src/parser/transformer.ts"
      provides: "transformSpawnAgent method and SpawnAgent detection"
      contains: "transformSpawnAgent"
    - path: "tests/parser/spawnagent-transformer.test.ts"
      provides: "SpawnAgent transformation tests"
      min_lines: 80
  key_links:
    - from: "src/parser/transformer.ts"
      to: "SpawnAgentNode"
      via: "transformSpawnAgent returns SpawnAgentNode"
      pattern: "kind: 'spawnAgent'"
---

<objective>
SpawnAgent component parsing and IR transformation

Purpose: Enable Commands to include SpawnAgent elements that transform into SpawnAgentNode IR for Task() emission. This is the parsing half of Phase 10 - extraction of agent, model, description, and prompt props from TSX into the SpawnAgentNode structure established in Phase 8.

Output: SpawnAgentProps interface, SpawnAgent component stub, transformSpawnAgent() method, comprehensive tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-spawnagent-component/10-RESEARCH.md

# Phase 9 established the Agent transformation pattern this plan follows
@.planning/phases/09-agent-transpilation/09-01-SUMMARY.md

# Source files to modify
@src/jsx.ts
@src/parser/transformer.ts
@src/ir/nodes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SpawnAgentProps interface and SpawnAgent component stub</name>
  <files>src/jsx.ts, src/index.ts</files>
  <action>
Add SpawnAgentProps interface and SpawnAgent function stub to jsx.ts following the established Command/Agent pattern.

Interface definition:
```typescript
/**
 * Props for the SpawnAgent component
 */
export interface SpawnAgentProps {
  /** Agent name to spawn (e.g., 'gsd-researcher') */
  agent: string;
  /** Model to use - supports {variable} placeholders */
  model: string;
  /** Human-readable description of the task */
  description: string;
  /** Prompt content - supports multi-line and {variable} placeholders */
  prompt: string;
}
```

Function stub:
```typescript
/**
 * SpawnAgent component - emits GSD Task() syntax inside a Command
 *
 * This is a compile-time component transformed by react-agentic.
 * It emits Task() function-call syntax, not markdown.
 *
 * @example
 * <SpawnAgent
 *   agent="gsd-researcher"
 *   model="{researcher_model}"
 *   description="Research phase requirements"
 *   prompt={`<context>Phase: {phase}</context>`}
 * />
 */
export function SpawnAgent(_props: SpawnAgentProps): null {
  return null;
}
```

Also add SpawnAgent and SpawnAgentProps to src/index.ts exports following the existing Command/Agent export pattern.
  </action>
  <verify>npm run typecheck passes; SpawnAgent and SpawnAgentProps are exported from index.ts</verify>
  <done>SpawnAgentProps interface with all 4 required props; SpawnAgent stub exported; imports resolve correctly</done>
</task>

<task type="auto">
  <name>Task 2: Add transformSpawnAgent method and SpawnAgent detection</name>
  <files>src/parser/transformer.ts</files>
  <action>
Add SpawnAgent to SPECIAL_COMPONENTS set and implement transformSpawnAgent method.

1. Add 'SpawnAgent' to SPECIAL_COMPONENTS:
```typescript
const SPECIAL_COMPONENTS = new Set(['Command', 'Markdown', 'XmlBlock', 'Agent', 'SpawnAgent']);
```

2. Add SpawnAgent case in transformElement() method (after XmlBlock, before Markdown):
```typescript
// SpawnAgent block element (inside Command)
if (name === 'SpawnAgent') {
  return this.transformSpawnAgent(node);
}
```

3. Add import for SpawnAgentNode at top of file in the type imports

4. Implement transformSpawnAgent method:
```typescript
/**
 * Transform a SpawnAgent element to SpawnAgentNode
 * SpawnAgent is a block-level element that emits Task() syntax
 */
private transformSpawnAgent(node: JsxElement | JsxSelfClosingElement): SpawnAgentNode {
  const openingElement = Node.isJsxElement(node)
    ? node.getOpeningElement()
    : node;

  // Extract required props
  const agent = getAttributeValue(openingElement, 'agent');
  const model = getAttributeValue(openingElement, 'model');
  const description = getAttributeValue(openingElement, 'description');
  const prompt = this.extractPromptProp(openingElement);

  // Validate all required props
  if (!agent) {
    throw this.createError('SpawnAgent requires agent prop', openingElement);
  }
  if (!model) {
    throw this.createError('SpawnAgent requires model prop', openingElement);
  }
  if (!description) {
    throw this.createError('SpawnAgent requires description prop', openingElement);
  }
  if (!prompt) {
    throw this.createError('SpawnAgent requires prompt prop', openingElement);
  }

  return { kind: 'spawnAgent', agent, model, description, prompt };
}
```

5. Add extractPromptProp helper method to handle string literals and template literals:
```typescript
/**
 * Extract prompt prop value, preserving multi-line content and {variable} placeholders
 * Supports: prompt="string", prompt={"string"}, prompt={`template`}
 */
private extractPromptProp(element: JsxOpeningElement | JsxSelfClosingElement): string | undefined {
  const attr = element.getAttribute('prompt');
  if (!attr || !Node.isJsxAttribute(attr)) {
    return undefined;
  }

  const init = attr.getInitializer();
  if (!init) {
    return undefined;
  }

  // String literal: prompt="simple string"
  if (Node.isStringLiteral(init)) {
    return init.getLiteralValue();
  }

  // JSX expression: prompt={...}
  if (Node.isJsxExpression(init)) {
    const expr = init.getExpression();
    if (!expr) {
      return undefined;
    }

    // String literal in JSX expression: prompt={"string"}
    if (Node.isStringLiteral(expr)) {
      return expr.getLiteralValue();
    }

    // No-substitution template literal: prompt={`simple template`}
    if (Node.isNoSubstitutionTemplateLiteral(expr)) {
      return expr.getLiteralValue();
    }

    // Template expression with substitutions: prompt={`text ${var}`}
    // Note: ${var} in TSX templates become {var} in output (GSD format)
    if (Node.isTemplateExpression(expr)) {
      return this.extractTemplateText(expr);
    }
  }

  return undefined;
}

/**
 * Extract text from a template expression, converting ${var} to {var}
 * This preserves GSD's {variable} placeholder syntax
 */
private extractTemplateText(expr: TemplateExpression): string {
  const parts: string[] = [];

  // Head: text before first ${...}
  parts.push(expr.getHead().getLiteralText());

  // Spans: each has expression + literal text after
  for (const span of expr.getTemplateSpans()) {
    const spanExpr = span.getExpression();
    // Convert ${variable} to {variable} for GSD format
    parts.push(`{${spanExpr.getText()}}`);
    parts.push(span.getLiteral().getLiteralText());
  }

  return parts.join('');
}
```

Note: Add TemplateExpression to the ts-morph imports at top of file.
  </action>
  <verify>npm run typecheck passes; SpawnAgent in SPECIAL_COMPONENTS</verify>
  <done>transformSpawnAgent method returns SpawnAgentNode; extractPromptProp handles all prompt formats; validation throws for missing props</done>
</task>

<task type="auto">
  <name>Task 3: Add SpawnAgent transformation tests</name>
  <files>tests/parser/spawnagent-transformer.test.ts</files>
  <action>
Create comprehensive tests for SpawnAgent transformation following the agent-transformer.test.ts pattern.

```typescript
import { describe, it, expect } from 'vitest';
import { createProject, findRootJsxElement } from '../../src/parser/parser.js';
import { Transformer } from '../../src/parser/transformer.js';
import type { DocumentNode, SpawnAgentNode } from '../../src/ir/index.js';

/**
 * Helper to transform TSX string containing Command with SpawnAgent
 */
function transformTsx(tsx: string): DocumentNode {
  const project = createProject();
  const source = project.createSourceFile('test.tsx', tsx, { overwrite: true });
  const root = findRootJsxElement(source);
  if (!root) throw new Error('No JSX found');
  const transformer = new Transformer();
  const doc = transformer.transform(root);
  if (doc.kind !== 'document') {
    throw new Error(`Expected document, got ${doc.kind}`);
  }
  return doc;
}

describe('SpawnAgent transformation', () => {
  describe('basic transformation', () => {
    it('transforms SpawnAgent with all props', () => {
      const tsx = `export default function MyCommand() {
        return (
          <Command name="test" description="Test command">
            <SpawnAgent
              agent="gsd-researcher"
              model="{model}"
              description="Research task"
              prompt="Do research"
            />
          </Command>
        );
      }`;
      const doc = transformTsx(tsx);

      expect(doc.children).toHaveLength(1);
      expect(doc.children[0].kind).toBe('spawnAgent');

      const spawn = doc.children[0] as SpawnAgentNode;
      expect(spawn.agent).toBe('gsd-researcher');
      expect(spawn.model).toBe('{model}');
      expect(spawn.description).toBe('Research task');
      expect(spawn.prompt).toBe('Do research');
    });

    it('transforms self-closing SpawnAgent', () => {
      const tsx = `export default function MyCommand() {
        return (
          <Command name="test" description="Test">
            <SpawnAgent agent="test" model="m" description="d" prompt="p" />
          </Command>
        );
      }`;
      const doc = transformTsx(tsx);

      expect(doc.children).toHaveLength(1);
      expect(doc.children[0].kind).toBe('spawnAgent');
    });
  });

  describe('placeholder preservation', () => {
    it('preserves {variable} in model prop', () => {
      const tsx = `export default function MyCommand() {
        return (
          <Command name="test" description="Test">
            <SpawnAgent
              agent="test"
              model="{researcher_model}"
              description="desc"
              prompt="prompt"
            />
          </Command>
        );
      }`;
      const doc = transformTsx(tsx);

      const spawn = doc.children[0] as SpawnAgentNode;
      expect(spawn.model).toBe('{researcher_model}');
    });

    it('preserves {variable} in prompt prop (string literal)', () => {
      const tsx = `export default function MyCommand() {
        return (
          <Command name="test" description="Test">
            <SpawnAgent
              agent="test"
              model="m"
              description="d"
              prompt="Phase: {phase_number}"
            />
          </Command>
        );
      }`;
      const doc = transformTsx(tsx);

      const spawn = doc.children[0] as SpawnAgentNode;
      expect(spawn.prompt).toBe('Phase: {phase_number}');
    });

    it('preserves {variable} in JSX expression string', () => {
      const tsx = `export default function MyCommand() {
        return (
          <Command name="test" description="Test">
            <SpawnAgent
              agent="test"
              model="m"
              description="d"
              prompt={"Content: {variable}"}
            />
          </Command>
        );
      }`;
      const doc = transformTsx(tsx);

      const spawn = doc.children[0] as SpawnAgentNode;
      expect(spawn.prompt).toBe('Content: {variable}');
    });
  });

  describe('template literal handling', () => {
    it('handles no-substitution template literal', () => {
      const tsx = `export default function MyCommand() {
        return (
          <Command name="test" description="Test">
            <SpawnAgent
              agent="test"
              model="m"
              description="d"
              prompt={\`Simple template content\`}
            />
          </Command>
        );
      }`;
      const doc = transformTsx(tsx);

      const spawn = doc.children[0] as SpawnAgentNode;
      expect(spawn.prompt).toBe('Simple template content');
    });

    it('converts ${var} to {var} in template expressions', () => {
      const tsx = `export default function MyCommand() {
        return (
          <Command name="test" description="Test">
            <SpawnAgent
              agent="test"
              model="m"
              description="d"
              prompt={\`Phase: \${phase}\`}
            />
          </Command>
        );
      }`;
      const doc = transformTsx(tsx);

      const spawn = doc.children[0] as SpawnAgentNode;
      expect(spawn.prompt).toBe('Phase: {phase}');
    });

    it('preserves multi-line template content', () => {
      const tsx = `export default function MyCommand() {
        return (
          <Command name="test" description="Test">
            <SpawnAgent
              agent="test"
              model="m"
              description="d"
              prompt={\`Line 1
Line 2
Line 3\`}
            />
          </Command>
        );
      }`;
      const doc = transformTsx(tsx);

      const spawn = doc.children[0] as SpawnAgentNode;
      expect(spawn.prompt).toBe('Line 1\nLine 2\nLine 3');
    });

    it('handles complex template with multiple substitutions', () => {
      const tsx = `export default function MyCommand() {
        return (
          <Command name="test" description="Test">
            <SpawnAgent
              agent="test"
              model="m"
              description="d"
              prompt={\`<context>
Phase: \${phase}
Goal: \${goal}
</context>\`}
            />
          </Command>
        );
      }`;
      const doc = transformTsx(tsx);

      const spawn = doc.children[0] as SpawnAgentNode;
      expect(spawn.prompt).toContain('{phase}');
      expect(spawn.prompt).toContain('{goal}');
      expect(spawn.prompt).toContain('<context>');
    });
  });

  describe('error handling', () => {
    it('throws for missing agent prop', () => {
      const tsx = `export default function MyCommand() {
        return (
          <Command name="test" description="Test">
            <SpawnAgent model="m" description="d" prompt="p" />
          </Command>
        );
      }`;
      expect(() => transformTsx(tsx)).toThrow(/SpawnAgent requires agent prop/);
    });

    it('throws for missing model prop', () => {
      const tsx = `export default function MyCommand() {
        return (
          <Command name="test" description="Test">
            <SpawnAgent agent="a" description="d" prompt="p" />
          </Command>
        );
      }`;
      expect(() => transformTsx(tsx)).toThrow(/SpawnAgent requires model prop/);
    });

    it('throws for missing description prop', () => {
      const tsx = `export default function MyCommand() {
        return (
          <Command name="test" description="Test">
            <SpawnAgent agent="a" model="m" prompt="p" />
          </Command>
        );
      }`;
      expect(() => transformTsx(tsx)).toThrow(/SpawnAgent requires description prop/);
    });

    it('throws for missing prompt prop', () => {
      const tsx = `export default function MyCommand() {
        return (
          <Command name="test" description="Test">
            <SpawnAgent agent="a" model="m" description="d" />
          </Command>
        );
      }`;
      expect(() => transformTsx(tsx)).toThrow(/SpawnAgent requires prompt prop/);
    });
  });

  describe('multiple SpawnAgent elements', () => {
    it('transforms multiple SpawnAgent in single Command', () => {
      const tsx = `export default function MyCommand() {
        return (
          <Command name="test" description="Test">
            <SpawnAgent agent="a1" model="m1" description="d1" prompt="p1" />
            <SpawnAgent agent="a2" model="m2" description="d2" prompt="p2" />
          </Command>
        );
      }`;
      const doc = transformTsx(tsx);

      expect(doc.children).toHaveLength(2);
      expect(doc.children[0].kind).toBe('spawnAgent');
      expect(doc.children[1].kind).toBe('spawnAgent');

      const spawn1 = doc.children[0] as SpawnAgentNode;
      const spawn2 = doc.children[1] as SpawnAgentNode;
      expect(spawn1.agent).toBe('a1');
      expect(spawn2.agent).toBe('a2');
    });
  });

  describe('SpawnAgent with sibling content', () => {
    it('transforms SpawnAgent alongside other block elements', () => {
      const tsx = `export default function MyCommand() {
        return (
          <Command name="test" description="Test">
            <h1>Phase Planning</h1>
            <p>This command spawns an agent.</p>
            <SpawnAgent agent="researcher" model="{model}" description="Research" prompt="Do research" />
          </Command>
        );
      }`;
      const doc = transformTsx(tsx);

      expect(doc.children).toHaveLength(3);
      expect(doc.children[0].kind).toBe('heading');
      expect(doc.children[1].kind).toBe('paragraph');
      expect(doc.children[2].kind).toBe('spawnAgent');
    });
  });
});
```
  </action>
  <verify>npm test passes; tests cover all SPAWN-01 through SPAWN-04 and SPAWN-06 requirements</verify>
  <done>15+ tests covering basic transformation, placeholder preservation, template literals, error handling, multiple SpawnAgents</done>
</task>

</tasks>

<verification>
After all tasks:
1. `npm run typecheck` passes
2. `npm test` passes (all existing + new SpawnAgent tests)
3. SpawnAgent transforms to SpawnAgentNode with correct props
4. `{variable}` placeholders preserved in model and prompt
5. Template literals correctly converted (${var} -> {var})
6. Clear error messages for missing required props
</verification>

<success_criteria>
- SpawnAgentProps interface exported from src/index.ts
- SpawnAgent component stub exported from src/index.ts
- transformSpawnAgent method produces valid SpawnAgentNode
- All 4 required props validated with clear errors
- {variable} placeholders preserved (not interpolated)
- Template literal ${var} converted to {var}
- 15+ tests covering transformation scenarios
- All tests pass (npm test)
</success_criteria>

<output>
After completion, create `.planning/phases/10-spawnagent-component/10-01-SUMMARY.md`
</output>
