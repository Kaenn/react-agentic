---
phase: 17-state-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ir/nodes.ts
  - src/jsx.ts
autonomous: true

must_haves:
  truths:
    - "ReadStateNode can be instantiated in IR"
    - "WriteStateNode captures field and merge write modes"
    - "StateRef type enables compile-time state binding"
    - "useStateRef hook returns typed StateRef"
    - "ReadState/WriteState components provide type-safe props"
  artifacts:
    - path: "src/ir/nodes.ts"
      provides: "ReadStateNode, WriteStateNode types"
      contains: "ReadStateNode"
    - path: "src/jsx.ts"
      provides: "useStateRef, ReadState, WriteState component exports"
      contains: "StateRef"
  key_links:
    - from: "src/jsx.ts"
      to: "src/ir/nodes.ts"
      via: "type alignment"
      pattern: "ReadStateProps.*state.*field"
---

<objective>
Add IR node types and JSX component definitions for ReadState and WriteState.

Purpose: Foundation layer for state component parsing and transformation
Output: Type definitions that enable compile-time validation of state operations
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/17-state-system/17-CONTEXT.md
@.planning/phases/17-state-system/17-RESEARCH.md

# Existing patterns to follow
@src/ir/nodes.ts
@src/jsx.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add State IR node types to nodes.ts</name>
  <files>src/ir/nodes.ts</files>
  <action>
Add two new block node types following the AssignNode pattern:

1. **ReadStateNode** (for reading state):
```typescript
/**
 * Read state value from registry
 * Emits as bash JSON read operation
 */
export interface ReadStateNode {
  kind: 'readState';
  /** State key identifier (e.g., 'projectContext') */
  stateKey: string;
  /** Variable to store result (from useVariable) */
  variableName: string;
  /** Optional: nested field path (e.g., 'user.preferences.theme') */
  field?: string;
}
```

2. **WriteStateNode** (for writing state):
```typescript
/**
 * Write state value to registry
 * Emits as bash JSON write operation
 */
export interface WriteStateNode {
  kind: 'writeState';
  /** State key identifier (e.g., 'projectContext') */
  stateKey: string;
  /** Write mode: 'field' for single field, 'merge' for partial update */
  mode: 'field' | 'merge';
  /** For field mode: nested field path (e.g., 'user.name') */
  field?: string;
  /** Value to write - either variable reference or literal */
  value: {
    type: 'variable' | 'literal';
    content: string;
  };
}
```

Update BlockNode union to include ReadStateNode and WriteStateNode.
Update IRNode union to include both new types.
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors in nodes.ts</verify>
  <done>ReadStateNode and WriteStateNode types defined and included in BlockNode union</done>
</task>

<task type="auto">
  <name>Task 2: Add State component exports to jsx.ts</name>
  <files>src/jsx.ts</files>
  <action>
Add StateRef type, hook, and component props following the useVariable/Assign pattern.

1. **StateRef interface** (like VariableRef):
```typescript
/**
 * Reference to a state key created by useStateRef
 * @typeParam TSchema - Type of the state schema (compile-time only)
 */
export interface StateRef<TSchema = unknown> {
  /** State key identifier */
  key: string;
  /** Phantom type marker (compile-time only) */
  _schema?: TSchema;
}
```

2. **useStateRef hook** (like useVariable):
```typescript
/**
 * Declare a state reference for reading/writing typed state
 *
 * This is a compile-time hook that creates a reference to a state key.
 * The actual state operations happen at runtime via ReadState/WriteState.
 *
 * @typeParam TSchema - TypeScript interface for state shape
 * @param key - State key identifier (e.g., "projectContext")
 * @returns StateRef for use in ReadState/WriteState
 *
 * @example
 * interface ProjectState { name: string; phase: number; }
 * const projectState = useStateRef<ProjectState>("projectContext");
 *
 * // In JSX:
 * <ReadState state={projectState} into={nameVar} field="name" />
 */
export function useStateRef<TSchema = unknown>(key: string): StateRef<TSchema> {
  return { key };
}
```

3. **ReadStateProps interface**:
```typescript
/**
 * Props for the ReadState component
 * @typeParam TSchema - State schema type for field path validation
 */
export interface ReadStateProps<TSchema = unknown> {
  /** State reference from useStateRef */
  state: StateRef<TSchema>;
  /** Variable to store the result */
  into: VariableRef;
  /** Optional: nested field path (e.g., "user.preferences.theme") */
  field?: string;
}
```

4. **WriteStateProps interface**:
```typescript
/**
 * Props for the WriteState component
 * Specify exactly one of: field+value OR merge
 * @typeParam TSchema - State schema type for field path validation
 */
export interface WriteStateProps<TSchema = unknown> {
  /** State reference from useStateRef */
  state: StateRef<TSchema>;
  /** Field path for single-field write (e.g., "user.name") */
  field?: string;
  /** Value to write - string literal or VariableRef */
  value?: string | VariableRef;
  /** Partial object for merge write */
  merge?: Partial<TSchema>;
}
```

5. Add compile-time stub functions:
```typescript
export function ReadState<TSchema = unknown>(_props: ReadStateProps<TSchema>): null {
  return null;
}

export function WriteState<TSchema = unknown>(_props: WriteStateProps<TSchema>): null {
  return null;
}
```

Add JSDoc comments following the existing Assign/OnStatus documentation pattern.
Place these in a new section "// ============================================================================
// State Management (useStateRef hook + ReadState/WriteState components)
// ============================================================================"
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors in jsx.ts</verify>
  <done>StateRef, useStateRef, ReadState, WriteState exported with typed props</done>
</task>

</tasks>

<verification>
```bash
# Type check passes
npx tsc --noEmit

# New IR types are in nodes.ts
grep -n "ReadStateNode\|WriteStateNode" src/ir/nodes.ts

# New components are exported from jsx.ts
grep -n "export function ReadState\|export function WriteState\|export function useStateRef" src/jsx.ts
```
</verification>

<success_criteria>
- [ ] ReadStateNode and WriteStateNode types defined in nodes.ts
- [ ] BlockNode union includes both new state node types
- [ ] StateRef interface and useStateRef hook exported from jsx.ts
- [ ] ReadState and WriteState components exported with typed props
- [ ] All props typed with JSDoc documentation
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/17-state-system/17-01-SUMMARY.md`
</output>
