---
phase: 17-state-system
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/state/types.ts
  - src/state/file-adapter.ts
  - src/state/index.ts
autonomous: true

must_haves:
  truths:
    - "StateAdapter interface defines read/write/exists contract"
    - "FileAdapter reads and writes JSON files with pretty formatting"
    - "FileAdapter creates file with defaults on first read if missing"
    - "State types exported from src/state/index.ts"
  artifacts:
    - path: "src/state/types.ts"
      provides: "StateAdapter interface, StateConfig type"
      contains: "StateAdapter"
    - path: "src/state/file-adapter.ts"
      provides: "FileAdapter class implementing StateAdapter"
      contains: "class FileAdapter"
    - path: "src/state/index.ts"
      provides: "Public exports for state module"
      exports: ["StateAdapter", "FileAdapter", "StateConfig"]
  key_links:
    - from: "src/state/file-adapter.ts"
      to: "src/state/types.ts"
      via: "implements interface"
      pattern: "implements StateAdapter"
---

<objective>
Create the state storage layer with StateAdapter interface and FileAdapter implementation.

Purpose: Persistence layer for state read/write operations
Output: FileAdapter that persists state to JSON files with create-if-missing behavior
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/17-state-system/17-CONTEXT.md
@.planning/phases/17-state-system/17-RESEARCH.md

# File handling patterns
@src/cli/commands/build.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state types module</name>
  <files>src/state/types.ts</files>
  <action>
Create `src/state/` directory and add `types.ts` with core interfaces:

```typescript
/**
 * State System Types
 *
 * Core interfaces for the typed state persistence system.
 * Adapters implement StateAdapter to provide different storage backends.
 */

/**
 * Configuration for a state adapter
 */
export interface StateConfig {
  /** File path for FileAdapter, connection string for database adapters */
  location: string;
  /** Default value if state doesn't exist */
  defaults: unknown;
}

/**
 * Abstract interface for state storage backends
 *
 * Implementations:
 * - FileAdapter: JSON file storage (local development)
 * - Future: RedisAdapter, PostgresAdapter, SupabaseAdapter
 */
export interface StateAdapter<T = unknown> {
  /**
   * Read current state value
   * Creates with defaults if not exists
   * @returns Current state or defaults
   */
  read(): Promise<T>;

  /**
   * Write complete state value (replaces existing)
   * @param value - New state value
   */
  write(value: T): Promise<void>;

  /**
   * Read a nested field from state
   * @param path - Dot-notation path (e.g., "user.preferences.theme")
   * @returns Field value or undefined
   */
  readField(path: string): Promise<unknown>;

  /**
   * Write a single nested field
   * @param path - Dot-notation path
   * @param value - Value to write
   */
  writeField(path: string, value: unknown): Promise<void>;

  /**
   * Merge partial update into state (shallow merge at top level)
   * @param partial - Partial state to merge
   */
  merge(partial: Partial<T>): Promise<void>;

  /**
   * Check if state file/record exists
   * @returns true if exists, false otherwise
   */
  exists(): Promise<boolean>;
}

/**
 * Helper to get nested value from object using dot-notation path
 * @param obj - Source object
 * @param path - Dot-notation path (e.g., "user.preferences.theme")
 * @returns Value at path or undefined
 */
export function getNestedValue(obj: unknown, path: string): unknown {
  const parts = path.split('.');
  let current: unknown = obj;
  for (const part of parts) {
    if (current === null || current === undefined) return undefined;
    if (typeof current !== 'object') return undefined;
    current = (current as Record<string, unknown>)[part];
  }
  return current;
}

/**
 * Helper to set nested value in object using dot-notation path
 * Creates intermediate objects as needed
 * @param obj - Target object (mutated in place)
 * @param path - Dot-notation path
 * @param value - Value to set
 */
export function setNestedValue(obj: Record<string, unknown>, path: string, value: unknown): void {
  const parts = path.split('.');
  let current: Record<string, unknown> = obj;
  for (let i = 0; i < parts.length - 1; i++) {
    const part = parts[i];
    if (!(part in current) || typeof current[part] !== 'object' || current[part] === null) {
      current[part] = {};
    }
    current = current[part] as Record<string, unknown>;
  }
  current[parts[parts.length - 1]] = value;
}
```
  </action>
  <verify>Run `npx tsc --noEmit src/state/types.ts` - no type errors</verify>
  <done>StateAdapter interface and helper functions defined</done>
</task>

<task type="auto">
  <name>Task 2: Create FileAdapter implementation</name>
  <files>src/state/file-adapter.ts</files>
  <action>
Create `file-adapter.ts` implementing StateAdapter for JSON file persistence:

```typescript
/**
 * FileAdapter - JSON file storage for state
 *
 * Features:
 * - Pretty JSON formatting for human readability
 * - Creates file with defaults if missing
 * - Creates parent directories as needed
 * - Last-write-wins concurrency (no locking)
 */

import { promises as fs } from 'fs';
import * as path from 'path';
import { StateAdapter, StateConfig, getNestedValue, setNestedValue } from './types.js';

export class FileAdapter<T = unknown> implements StateAdapter<T> {
  private readonly filePath: string;
  private readonly defaults: T;

  constructor(config: StateConfig) {
    this.filePath = config.location;
    this.defaults = config.defaults as T;
  }

  async read(): Promise<T> {
    if (!(await this.exists())) {
      await this.write(this.defaults);
      return this.defaults;
    }
    const content = await fs.readFile(this.filePath, 'utf-8');
    return JSON.parse(content) as T;
  }

  async write(value: T): Promise<void> {
    const dir = path.dirname(this.filePath);
    await fs.mkdir(dir, { recursive: true });
    const content = JSON.stringify(value, null, 2);
    await fs.writeFile(this.filePath, content, 'utf-8');
  }

  async readField(fieldPath: string): Promise<unknown> {
    const state = await this.read();
    return getNestedValue(state, fieldPath);
  }

  async writeField(fieldPath: string, value: unknown): Promise<void> {
    const state = await this.read() as Record<string, unknown>;
    setNestedValue(state, fieldPath, value);
    await this.write(state as T);
  }

  async merge(partial: Partial<T>): Promise<void> {
    const state = await this.read();
    const merged = { ...state, ...partial };
    await this.write(merged);
  }

  async exists(): Promise<boolean> {
    try {
      await fs.access(this.filePath);
      return true;
    } catch {
      return false;
    }
  }
}
```
  </action>
  <verify>Run `npx tsc --noEmit src/state/file-adapter.ts` - no type errors</verify>
  <done>FileAdapter class implements StateAdapter with JSON file persistence</done>
</task>

<task type="auto">
  <name>Task 3: Create state module index exports</name>
  <files>src/state/index.ts</files>
  <action>
Create `index.ts` with public exports:

```typescript
/**
 * State System Module
 *
 * Typed, persistent state for Commands and Agents.
 *
 * @example
 * import { FileAdapter, StateConfig } from './state/index.js';
 *
 * const config: StateConfig = {
 *   location: '.state/project.json',
 *   defaults: { name: '', phase: 0 }
 * };
 * const adapter = new FileAdapter(config);
 * const state = await adapter.read();
 */

export { StateAdapter, StateConfig, getNestedValue, setNestedValue } from './types.js';
export { FileAdapter } from './file-adapter.js';
```
  </action>
  <verify>Run `npx tsc --noEmit src/state/index.ts` - no type errors</verify>
  <done>State module exports StateAdapter, FileAdapter, and helpers</done>
</task>

</tasks>

<verification>
```bash
# Type check all state files
npx tsc --noEmit

# Directory structure exists
ls -la src/state/

# Exports are present
grep -n "export" src/state/index.ts

# FileAdapter implements interface
grep -n "implements StateAdapter" src/state/file-adapter.ts
```
</verification>

<success_criteria>
- [ ] src/state/ directory created with types.ts, file-adapter.ts, index.ts
- [ ] StateAdapter interface defines read/write/readField/writeField/merge/exists
- [ ] FileAdapter implements StateAdapter with JSON file persistence
- [ ] getNestedValue/setNestedValue helpers work for dot-notation paths
- [ ] FileAdapter creates file with defaults if missing
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/17-state-system/17-02-SUMMARY.md`
</output>
