---
phase: 17-state-system
plan: 05
type: execute
wave: 3
depends_on: ["17-02", "17-03", "17-04"]
files_modified:
  - src/app/state-demo.command.tsx
  - src/index.ts
  - docs/state.md
autonomous: true

must_haves:
  truths:
    - "Demo command compiles and produces valid markdown"
    - "State module exports are available from main index"
    - "Documentation explains useStateRef, ReadState, WriteState usage"
    - "End-to-end flow works: TSX -> IR -> Markdown"
  artifacts:
    - path: "src/app/state-demo.command.tsx"
      provides: "Working demo of state components"
      contains: "useStateRef"
    - path: "src/index.ts"
      provides: "Public exports including state module"
      exports: ["StateAdapter", "FileAdapter"]
    - path: "docs/state.md"
      provides: "User documentation for state system"
      contains: "ReadState"
  key_links:
    - from: "src/app/state-demo.command.tsx"
      to: ".claude/commands/state-demo.md"
      via: "build output"
      pattern: "state-read.*state-write"
---

<objective>
Create integration test command, public exports, and documentation for state system.

Purpose: Validate end-to-end flow and provide user documentation
Output: Working demo, exports, and docs that teach state patterns
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/17-state-system/17-CONTEXT.md

# Previous plan outputs
@src/jsx.ts
@src/state/index.ts

# Documentation patterns
@docs/variables.md
@docs/command.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state demo command</name>
  <files>src/app/state-demo.command.tsx</files>
  <action>
Create a demo command that exercises all state features:

```tsx
/**
 * State Demo Command
 *
 * Demonstrates the state system: useStateRef, ReadState, WriteState
 */
import {
  Command,
  useVariable,
  useStateRef,
  Assign,
  ReadState,
  WriteState,
  If,
  Else,
  Markdown,
} from '../jsx.js';

// Define the state schema (compile-time only)
interface ProjectState {
  name: string;
  phase: number;
  config: {
    debug: boolean;
    outputDir: string;
  };
}

export default function StateDemo() {
  // Declare state reference
  const projectState = useStateRef<ProjectState>('projectContext');

  // Variables to store read results
  const currentPhase = useVariable('CURRENT_PHASE');
  const projectName = useVariable('PROJECT_NAME');
  const fullState = useVariable('FULL_STATE');

  return (
    <Command
      name="state-demo"
      description="Demonstrate state system features"
    >
      <Markdown>
{`# State System Demo

This command demonstrates reading and writing typed state.

## Read Operations
`}
      </Markdown>

      {/* Read a specific field */}
      <ReadState state={projectState} into={currentPhase} field="phase" />

      {/* Read another field */}
      <ReadState state={projectState} into={projectName} field="name" />

      {/* Read full state */}
      <ReadState state={projectState} into={fullState} />

      <Markdown>
{`
## Write Operations
`}
      </Markdown>

      {/* Write a single field */}
      <WriteState
        state={projectState}
        field="phase"
        value="2"
      />

      {/* Write nested field */}
      <WriteState
        state={projectState}
        field="config.debug"
        value="true"
      />

      {/* Merge partial update */}
      <WriteState
        state={projectState}
        merge={{ name: 'Updated Project', phase: 3 }}
      />

      <Markdown>
{`
## Conditional State Usage
`}
      </Markdown>

      <Assign var={currentPhase} bash="echo $CURRENT_PHASE" />

      <If test={`[ "$CURRENT_PHASE" = "0" ]`}>
        <Markdown>
{`
Project not started. Initialize state first.
`}
        </Markdown>
      </If>
      <Else>
        <Markdown>
{`
Project is at phase $CURRENT_PHASE.
`}
        </Markdown>
      </Else>
    </Command>
  );
}
```
  </action>
  <verify>Run `node dist/cli/index.js build src/app/state-demo.command.tsx` - builds without errors</verify>
  <done>Demo command exercises useStateRef, ReadState (full and field), WriteState (field and merge)</done>
</task>

<task type="auto">
  <name>Task 2: Add state exports to main index</name>
  <files>src/index.ts</files>
  <action>
Update `src/index.ts` to export state module types:

Add to existing exports:
```typescript
// State System
export {
  StateAdapter,
  StateConfig,
  FileAdapter,
  getNestedValue,
  setNestedValue,
} from './state/index.js';
```

Also ensure jsx.ts exports are complete (useStateRef, StateRef, ReadState, WriteState should already be exported via wildcard or explicitly).
  </action>
  <verify>Run `npx tsc --noEmit` - no errors; grep for state exports</verify>
  <done>StateAdapter, FileAdapter, StateConfig exported from main index</done>
</task>

<task type="auto">
  <name>Task 3: Create state documentation</name>
  <files>docs/state.md</files>
  <action>
Create user documentation following the variables.md pattern:

```markdown
# State System

Typed, persistent state for Commands and Agents with compile-time validation.

## Overview

The state system provides:
- **Type-safe state access** via TypeScript interfaces
- **Persistent storage** via FileAdapter (JSON files)
- **Nested field access** via dot-notation paths
- **Read/write operations** via ReadState/WriteState components

## Quick Start

```tsx
import { Command, useVariable, useStateRef, ReadState, WriteState } from 'react-agentic';

// 1. Define your state schema
interface ProjectState {
  name: string;
  phase: number;
  config: { debug: boolean };
}

// 2. Create a state reference
const projectState = useStateRef<ProjectState>('projectContext');

// 3. Read state into a variable
const phase = useVariable('PHASE');
<ReadState state={projectState} into={phase} field="phase" />

// 4. Write state
<WriteState state={projectState} field="phase" value="2" />
```

## Components

### useStateRef

Declares a reference to a state key for use in ReadState/WriteState.

```tsx
const state = useStateRef<TSchema>(key: string): StateRef<TSchema>
```

**Parameters:**
- `key`: State identifier (e.g., "projectContext")
- `TSchema`: TypeScript interface for compile-time validation

**Returns:** StateRef for use in state components

### ReadState

Reads state value into a shell variable.

```tsx
<ReadState
  state={stateRef}      // Required: StateRef from useStateRef
  into={variableRef}    // Required: VariableRef to store result
  field="path.to.field" // Optional: nested field path
/>
```

**Examples:**

```tsx
// Read full state
<ReadState state={projectState} into={fullState} />

// Read specific field
<ReadState state={projectState} into={phase} field="phase" />

// Read nested field
<ReadState state={projectState} into={debug} field="config.debug" />
```

**Output:**
```
Use skill `/react-agentic:state-read projectContext --field "phase"` and store result in `PHASE`.
```

### WriteState

Writes to state - either a single field or merge partial update.

```tsx
// Field mode
<WriteState
  state={stateRef}    // Required: StateRef
  field="path"        // Required: field path
  value={val}         // Required: string or VariableRef
/>

// Merge mode
<WriteState
  state={stateRef}    // Required: StateRef
  merge={partial}     // Required: partial object to merge
/>
```

**Examples:**

```tsx
// Write single field with literal
<WriteState state={projectState} field="phase" value="2" />

// Write single field with variable
const newPhase = useVariable('NEW_PHASE');
<WriteState state={projectState} field="phase" value={newPhase} />

// Write nested field
<WriteState state={projectState} field="config.debug" value="true" />

// Merge partial update (shallow merge)
<WriteState state={projectState} merge={{ name: 'New Name', phase: 3 }} />
```

**Output:**
```
Use skill `/react-agentic:state-write projectContext --field "phase" --value "2"`.
Use skill `/react-agentic:state-write projectContext --merge '{ name: "New Name", phase: 3 }'`.
```

## Storage

State is persisted to JSON files via FileAdapter:

- **Location:** Configurable per-state (default: `.state/{key}.json`)
- **Format:** Pretty-printed JSON for readability
- **Behavior:** Creates file with defaults if missing
- **Concurrency:** Last-write-wins (no locking)

### FileAdapter

```typescript
import { FileAdapter, StateConfig } from 'react-agentic';

const config: StateConfig = {
  location: '.state/project.json',
  defaults: { name: '', phase: 0, config: { debug: false } }
};

const adapter = new FileAdapter(config);
const state = await adapter.read();
await adapter.writeField('phase', 1);
await adapter.merge({ name: 'My Project' });
```

## Type Safety

The state system provides compile-time validation:

```tsx
interface ProjectState {
  name: string;
  phase: number;
}

const state = useStateRef<ProjectState>('project');

// These field paths are validated at compile time
<ReadState state={state} field="name" />      // OK
<ReadState state={state} field="phase" />     // OK
<ReadState state={state} field="invalid" />   // Would error (future: path validation)

<WriteState state={state} field="name" value="test" />  // OK
<WriteState state={state} merge={{ name: 'x' }} />      // OK
```

## Best Practices

1. **Define interfaces for all state**: Enables compile-time validation
2. **Use descriptive state keys**: `projectContext` not `state1`
3. **Prefer field writes over merge**: More explicit, easier to track
4. **Store state files in `.state/`**: Keep organized, easy to gitignore
5. **Initialize with sensible defaults**: Avoid undefined values

## CLI Skills

State operations compile to CLI skill invocations:

- `/react-agentic:state-read {key}` - Read full state
- `/react-agentic:state-read {key} --field {path}` - Read field
- `/react-agentic:state-write {key} --field {path} --value {val}` - Write field
- `/react-agentic:state-write {key} --merge '{json}'` - Merge update

These skills are invoked by Claude at runtime when executing the command.
```
  </action>
  <verify>File exists and contains all sections; markdown renders correctly</verify>
  <done>Documentation covers useStateRef, ReadState, WriteState, FileAdapter, and best practices</done>
</task>

</tasks>

<verification>
```bash
# Build demo command
npm run build
node dist/cli/index.js build src/app/state-demo.command.tsx

# Check output exists
cat .claude/commands/state-demo.md

# Verify exports
grep -n "StateAdapter\|FileAdapter" src/index.ts

# Check docs
cat docs/state.md | head -50
```
</verification>

<success_criteria>
- [ ] state-demo.command.tsx compiles without errors
- [ ] Generated .claude/commands/state-demo.md contains skill invocations
- [ ] StateAdapter, FileAdapter, StateConfig exported from src/index.ts
- [ ] docs/state.md explains all state components with examples
- [ ] End-to-end: TSX source -> build -> markdown output works
</success_criteria>

<output>
After completion, create `.planning/phases/17-state-system/17-05-SUMMARY.md`
</output>
