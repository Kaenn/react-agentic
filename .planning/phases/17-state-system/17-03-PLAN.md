---
phase: 17-state-system
plan: 03
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - src/parser/transformer.ts
autonomous: true

must_haves:
  truths:
    - "ReadState JSX transforms to ReadStateNode IR"
    - "WriteState JSX with field prop transforms to field mode WriteStateNode"
    - "WriteState JSX with merge prop transforms to merge mode WriteStateNode"
    - "Transformer extracts state key from StateRef prop"
    - "Transformer extracts variable name from VariableRef into prop"
  artifacts:
    - path: "src/parser/transformer.ts"
      provides: "transformReadState and transformWriteState methods"
      contains: "transformReadState"
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/ir/nodes.ts"
      via: "IR node creation"
      pattern: "kind: 'readState'"
---

<objective>
Add transformer logic to parse ReadState and WriteState JSX into IR nodes.

Purpose: Enable JSX state components to be transformed into IR for emission
Output: Transformer handles ReadState/WriteState following Assign pattern
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/17-state-system/17-CONTEXT.md

# Plan 01 outputs
@src/ir/nodes.ts
@src/jsx.ts

# Existing transformer patterns
@src/parser/transformer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ReadState transformer method</name>
  <files>src/parser/transformer.ts</files>
  <action>
Add `transformReadState` method following the `transformAssign` pattern:

```typescript
/**
 * Transform ReadState JSX element into IR node
 *
 * Extracts:
 * - state: StateRef with key property
 * - into: VariableRef with name property
 * - field: optional nested path string
 */
private transformReadState(node: JsxElement | JsxSelfClosingElement): ReadStateNode {
  const openingElement = Node.isJsxElement(node)
    ? node.getOpeningElement()
    : node;

  // Extract state prop (StateRef object with key property)
  const stateAttr = openingElement.getAttribute('state');
  if (!stateAttr || !Node.isJsxAttribute(stateAttr)) {
    throw new Error('ReadState requires state prop');
  }
  const stateInit = stateAttr.getInitializer();
  if (!stateInit || !Node.isJsxExpression(stateInit)) {
    throw new Error('ReadState state prop must be JSX expression');
  }
  // Extract key from StateRef: { key: "..." }
  const stateExpr = stateInit.getExpression();
  if (!stateExpr) {
    throw new Error('ReadState state prop expression is empty');
  }
  // Get the identifier name, then resolve to find the key
  const stateKey = this.extractStateKey(stateExpr);

  // Extract into prop (VariableRef)
  const intoAttr = openingElement.getAttribute('into');
  if (!intoAttr || !Node.isJsxAttribute(intoAttr)) {
    throw new Error('ReadState requires into prop');
  }
  const intoInit = intoAttr.getInitializer();
  if (!intoInit || !Node.isJsxExpression(intoInit)) {
    throw new Error('ReadState into prop must be JSX expression');
  }
  const intoExpr = intoInit.getExpression();
  if (!intoExpr) {
    throw new Error('ReadState into prop expression is empty');
  }
  const variableName = this.extractVariableName(intoExpr);

  // Extract optional field prop (string)
  const fieldAttr = openingElement.getAttribute('field');
  let field: string | undefined;
  if (fieldAttr && Node.isJsxAttribute(fieldAttr)) {
    const fieldInit = fieldAttr.getInitializer();
    if (fieldInit && Node.isStringLiteral(fieldInit)) {
      field = fieldInit.getLiteralText();
    }
  }

  return {
    kind: 'readState',
    stateKey,
    variableName,
    field,
  };
}

/**
 * Extract state key from StateRef expression
 * Handles: identifier pointing to useStateRef result
 */
private extractStateKey(expr: Expression): string {
  // Handle identifier (e.g., projectState from useStateRef)
  if (Node.isIdentifier(expr)) {
    const name = expr.getText();
    // Look up in tracked state refs (similar to variables tracking)
    const tracked = this.stateRefs.get(name);
    if (tracked) return tracked;
    // Fallback: use identifier name as key
    return name;
  }
  throw new Error(`Cannot extract state key from: ${expr.getText()}`);
}
```

Also add tracking for state refs (similar to `variables` Map):
```typescript
// In class properties
private stateRefs = new Map<string, string>(); // identifier -> state key

// Add extraction during variable declaration scanning
// When seeing: const projectState = useStateRef("projectContext")
// Store: stateRefs.set("projectState", "projectContext")
```

Add method `extractStateRefDeclarations` similar to `extractVariableDeclarations` that:
1. Finds all `useStateRef(...)` calls in the source
2. Maps the variable name to the state key argument
3. Stores in `this.stateRefs` Map
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors in transformer.ts</verify>
  <done>transformReadState method extracts state key, variable name, and optional field</done>
</task>

<task type="auto">
  <name>Task 2: Add WriteState transformer method</name>
  <files>src/parser/transformer.ts</files>
  <action>
Add `transformWriteState` method following similar pattern:

```typescript
/**
 * Transform WriteState JSX element into IR node
 *
 * Two modes:
 * 1. Field mode: field="path" value={val}
 * 2. Merge mode: merge={partial}
 */
private transformWriteState(node: JsxElement | JsxSelfClosingElement): WriteStateNode {
  const openingElement = Node.isJsxElement(node)
    ? node.getOpeningElement()
    : node;

  // Extract state prop (required)
  const stateAttr = openingElement.getAttribute('state');
  if (!stateAttr || !Node.isJsxAttribute(stateAttr)) {
    throw new Error('WriteState requires state prop');
  }
  const stateInit = stateAttr.getInitializer();
  if (!stateInit || !Node.isJsxExpression(stateInit)) {
    throw new Error('WriteState state prop must be JSX expression');
  }
  const stateExpr = stateInit.getExpression();
  if (!stateExpr) {
    throw new Error('WriteState state prop expression is empty');
  }
  const stateKey = this.extractStateKey(stateExpr);

  // Check for field prop (field mode)
  const fieldAttr = openingElement.getAttribute('field');
  const mergeAttr = openingElement.getAttribute('merge');

  if (fieldAttr && Node.isJsxAttribute(fieldAttr)) {
    // Field mode: field + value
    const fieldInit = fieldAttr.getInitializer();
    if (!fieldInit || !Node.isStringLiteral(fieldInit)) {
      throw new Error('WriteState field prop must be string literal');
    }
    const field = fieldInit.getLiteralText();

    // Extract value prop
    const valueAttr = openingElement.getAttribute('value');
    if (!valueAttr || !Node.isJsxAttribute(valueAttr)) {
      throw new Error('WriteState with field requires value prop');
    }
    const valueInit = valueAttr.getInitializer();
    if (!valueInit) {
      throw new Error('WriteState value prop is empty');
    }

    let value: { type: 'variable' | 'literal'; content: string };
    if (Node.isStringLiteral(valueInit)) {
      value = { type: 'literal', content: valueInit.getLiteralText() };
    } else if (Node.isJsxExpression(valueInit)) {
      const valueExpr = valueInit.getExpression();
      if (!valueExpr) {
        throw new Error('WriteState value expression is empty');
      }
      // Check if it's a variable reference
      if (Node.isIdentifier(valueExpr)) {
        const varName = valueExpr.getText();
        const tracked = this.variables.get(varName);
        value = { type: 'variable', content: tracked?.envName ?? varName };
      } else {
        // Treat as literal expression
        value = { type: 'literal', content: valueExpr.getText() };
      }
    } else {
      throw new Error('WriteState value must be string or expression');
    }

    return {
      kind: 'writeState',
      stateKey,
      mode: 'field',
      field,
      value,
    };
  } else if (mergeAttr && Node.isJsxAttribute(mergeAttr)) {
    // Merge mode
    const mergeInit = mergeAttr.getInitializer();
    if (!mergeInit || !Node.isJsxExpression(mergeInit)) {
      throw new Error('WriteState merge prop must be JSX expression');
    }
    const mergeExpr = mergeInit.getExpression();
    if (!mergeExpr) {
      throw new Error('WriteState merge expression is empty');
    }

    // For merge, we serialize the object literal to JSON
    // This supports simple object literals at compile time
    const content = mergeExpr.getText();

    return {
      kind: 'writeState',
      stateKey,
      mode: 'merge',
      value: { type: 'literal', content },
    };
  } else {
    throw new Error('WriteState requires either field+value or merge prop');
  }
}
```

Update `transformBlockChildren` or the component routing switch to handle ReadState and WriteState tags by calling the new methods.
  </action>
  <verify>Run `npx tsc --noEmit` - no type errors in transformer.ts</verify>
  <done>transformWriteState handles field mode and merge mode writes</done>
</task>

</tasks>

<verification>
```bash
# Type check passes
npx tsc --noEmit

# New transform methods exist
grep -n "transformReadState\|transformWriteState" src/parser/transformer.ts

# State ref tracking exists
grep -n "stateRefs" src/parser/transformer.ts

# Methods handle both modes
grep -n "mode: 'field'\|mode: 'merge'" src/parser/transformer.ts
```
</verification>

<success_criteria>
- [ ] transformReadState extracts stateKey, variableName, optional field
- [ ] transformWriteState handles field mode (field + value props)
- [ ] transformWriteState handles merge mode (merge prop)
- [ ] stateRefs Map tracks useStateRef declarations
- [ ] extractStateKey resolves StateRef to state key string
- [ ] Component routing dispatches ReadState/WriteState to new methods
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/17-state-system/17-03-SUMMARY.md`
</output>
