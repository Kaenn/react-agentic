---
phase: 01-foundation-ir
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/ir/index.ts
  - src/ir/nodes.ts
  - src/emitter/index.ts
  - src/emitter/emitter.ts
  - src/emitter/utils.ts
  - src/index.ts
  - tests/emitter/heading.test.ts
  - tests/emitter/paragraph.test.ts
  - tests/emitter/list.test.ts
  - tests/emitter/code.test.ts
  - tests/emitter/document.test.ts
autonomous: true

must_haves:
  truths:
    - "IR types exist for all planned node kinds"
    - "Markdown emitter converts IR to valid Markdown"
    - "Unit tests verify emitter produces correct output"
    - "Emitter handles nested structures (lists, inline formatting)"
  artifacts:
    - path: "src/ir/nodes.ts"
      provides: "All IR node type definitions"
      exports: ["DocumentNode", "BlockNode", "InlineNode", "IRNode"]
      min_lines: 80
    - path: "src/emitter/emitter.ts"
      provides: "MarkdownEmitter class with emit method"
      exports: ["MarkdownEmitter"]
      min_lines: 100
    - path: "tests/emitter/heading.test.ts"
      provides: "Heading emission tests"
      contains: "toMatchInlineSnapshot"
    - path: "tests/emitter/list.test.ts"
      provides: "List emission tests including nested"
      contains: "nested"
  key_links:
    - from: "src/emitter/emitter.ts"
      to: "src/ir/nodes.ts"
      via: "imports IR types"
      pattern: "import.*from.*['\"].*ir"
    - from: "src/emitter/emitter.ts"
      to: "gray-matter"
      via: "frontmatter stringification"
      pattern: "import.*gray-matter|matter\\.stringify"
    - from: "tests/emitter/heading.test.ts"
      to: "src/emitter/index.ts"
      via: "imports emit function"
      pattern: "import.*from.*emitter"
---

<objective>
Define IR types for all node kinds and implement Markdown emitter with comprehensive tests.

Purpose: Create the intermediate representation layer that decouples parsing from generation, enabling testable, maintainable code.
Output: Complete IR type system and working Markdown emitter verified by unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-ir/01-CONTEXT.md
@.planning/phases/01-foundation-ir/01-RESEARCH.md
@.planning/phases/01-foundation-ir/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define IR node types as discriminated unions</name>
  <files>src/ir/nodes.ts, src/ir/index.ts</files>
  <action>
Create src/ir/nodes.ts with all IR node types using discriminated unions with `kind` property.

Block nodes (standalone elements):
- HeadingNode: kind 'heading', level 1-6, children InlineNode[]
- ParagraphNode: kind 'paragraph', children InlineNode[]
- ListNode: kind 'list', ordered boolean, items ListItemNode[]
- ListItemNode: kind 'listItem', children BlockNode[]
- CodeBlockNode: kind 'codeBlock', language optional string, content string
- BlockquoteNode: kind 'blockquote', children BlockNode[]
- ThematicBreakNode: kind 'thematicBreak' (no other properties)
- XmlBlockNode: kind 'xmlBlock', name string, children BlockNode[]
- RawMarkdownNode: kind 'raw', content string

Inline nodes (within paragraphs, headings):
- TextNode: kind 'text', value string
- BoldNode: kind 'bold', children InlineNode[]
- ItalicNode: kind 'italic', children InlineNode[]
- InlineCodeNode: kind 'inlineCode', value string
- LinkNode: kind 'link', url string, children InlineNode[]
- LineBreakNode: kind 'lineBreak' (no other properties)

Special nodes:
- FrontmatterNode: kind 'frontmatter', data Record<string, unknown>
- DocumentNode: kind 'document', frontmatter optional FrontmatterNode, children BlockNode[]

Union types:
- InlineNode = TextNode | BoldNode | ItalicNode | InlineCodeNode | LinkNode | LineBreakNode
- BlockNode = HeadingNode | ParagraphNode | ListNode | CodeBlockNode | BlockquoteNode | ThematicBreakNode | XmlBlockNode | RawMarkdownNode
- IRNode = BlockNode | InlineNode | FrontmatterNode | ListItemNode | DocumentNode

Create src/ir/index.ts to re-export all types from nodes.ts.

Add helper function: assertNever(x: never): never for exhaustiveness checking.
  </action>
  <verify>
- `pnpm run typecheck` passes
- Types can be imported: `import { DocumentNode, BlockNode } from './ir'`
  </verify>
  <done>All IR node types defined with proper discriminated unions and exported</done>
</task>

<task type="auto">
  <name>Task 2: Implement Markdown emitter with switch-based emission</name>
  <files>src/emitter/emitter.ts, src/emitter/utils.ts, src/emitter/index.ts, src/index.ts</files>
  <action>
Create src/emitter/utils.ts with helpers:
- assertNever(x: never): never - for exhaustiveness checking

Create src/emitter/emitter.ts with MarkdownEmitter class:
- Private state: listStack for tracking nested list context
- emit(doc: DocumentNode): string - main entry point
- emitFrontmatter(node: FrontmatterNode): string - uses gray-matter stringify
- emitBlock(node: BlockNode): string - switch on kind with exhaustiveness
- emitInline(node: InlineNode): string - switch on kind with exhaustiveness
- emitInlineChildren(nodes: InlineNode[]): string - join inline nodes
- emitHeading(node: HeadingNode): string - '#' repeated level times + content
- emitParagraph(node: ParagraphNode): string - just inline content
- emitList(node: ListNode): string - uses listStack for nesting
- emitListItem(item: ListItemNode): string - marker + indented content
- emitCodeBlock(node: CodeBlockNode): string - triple backticks with language
- emitBlockquote(node: BlockquoteNode): string - '> ' prefix per line
- emitXmlBlock(node: XmlBlockNode): string - <name>content</name>

Markdown output style (from CONTEXT.md):
- Unordered list markers: dash (-)
- Block element spacing: single blank line between elements
- Code fences: triple backticks
- Emphasis: asterisks (**bold**, *italic*)

Create src/emitter/index.ts:
- Export MarkdownEmitter class
- Export convenience function: emit(doc: DocumentNode): string

Update src/index.ts to export from emitter and ir:
- export * from './ir'
- export * from './emitter'
  </action>
  <verify>
- `pnpm run typecheck` passes
- Can create emitter instance and call emit() with a simple DocumentNode
  </verify>
  <done>MarkdownEmitter implemented with all node type handlers and exhaustiveness checking</done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive emitter unit tests</name>
  <files>tests/emitter/heading.test.ts, tests/emitter/paragraph.test.ts, tests/emitter/list.test.ts, tests/emitter/code.test.ts, tests/emitter/document.test.ts</files>
  <action>
Create tests using Vitest with inline snapshots for simple cases.

tests/emitter/heading.test.ts:
- Test all heading levels (1-6)
- Test heading with inline formatting (bold, italic)
- Use toMatchInlineSnapshot for each

tests/emitter/paragraph.test.ts:
- Test plain text paragraph
- Test paragraph with bold text
- Test paragraph with italic text
- Test paragraph with inline code
- Test paragraph with link
- Test paragraph with mixed formatting

tests/emitter/list.test.ts:
- Test unordered list with simple items
- Test ordered list with simple items
- Test nested unordered list (2 levels)
- Test nested mixed list (unordered containing ordered)
- Verify dash (-) markers for unordered
- Verify correct indentation for nested items

tests/emitter/code.test.ts:
- Test code block without language
- Test code block with language (typescript, javascript)
- Test inline code in paragraph
- Verify triple backticks

tests/emitter/document.test.ts:
- Test document with frontmatter only
- Test document with heading and paragraphs
- Test complete document with frontmatter + multiple block types
- Verify single blank line between block elements
- Use toMatchInlineSnapshot or toMatchFileSnapshot for full documents

All tests should:
- Import emit function from '../src/emitter'
- Use describe/it blocks for organization
- Have descriptive test names
  </action>
  <verify>
- `pnpm run test:run` passes all tests
- Each test file covers its domain (headings, paragraphs, lists, etc.)
- Nested list tests verify correct indentation
  </verify>
  <done>All emitter tests pass, covering every IR node type with inline snapshots</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pnpm run typecheck` - All types compile correctly
2. `pnpm run test:run` - All tests pass
3. Verify key behaviors:
   - `emit(headingDoc)` produces `# Title`
   - `emit(listDoc)` produces properly indented nested lists with dash markers
   - `emit(docWithFrontmatter)` produces YAML frontmatter with --- delimiters
</verification>

<success_criteria>
- IR types exist for all node kinds: Heading, Paragraph, List, ListItem, CodeBlock, Blockquote, ThematicBreak, XmlBlock, Raw, Text, Bold, Italic, InlineCode, Link, LineBreak, Frontmatter, Document
- Markdown emitter handles every IR node type with exhaustiveness checking
- Unit tests verify correct Markdown output for each node type
- Nested structures (lists, inline formatting) emit correctly
- Frontmatter uses gray-matter for YAML stringification
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-ir/01-02-SUMMARY.md`
</output>
