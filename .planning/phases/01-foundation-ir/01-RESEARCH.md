# Phase 1: Foundation & IR - Research

**Researched:** 2026-01-20
**Domain:** TypeScript project setup, IR type design, Markdown emission
**Confidence:** HIGH

## Summary

Phase 1 establishes project infrastructure and defines the intermediate representation (IR) layer that decouples parsing from generation. The research confirms that discriminated unions with a `kind` property are the standard TypeScript pattern for AST/IR nodes, providing excellent type narrowing and exhaustiveness checking. For the emitter, a simple switch-based approach outperforms the visitor pattern for fixed node sets with infrequent changes. Project setup follows modern pnpm + TypeScript + Vitest patterns with ESM-first configuration.

Key findings:
- Use discriminated unions with `kind: string` literal discriminator for all IR nodes
- Emitter should use switch statement with exhaustiveness checking (simpler than visitor for fixed node types)
- pnpm + TypeScript 5.9+ + Vitest 4.x is the current standard stack
- gray-matter handles YAML frontmatter stringification cleanly
- Mix inline snapshots (simple cases) with file snapshots (full Markdown output) for testing

**Primary recommendation:** Build IR types first as discriminated unions, then emitter with switch-based emission, using inline snapshots for unit tests and file snapshots for full Markdown output verification.

## Standard Stack

The established libraries/tools for this phase:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| TypeScript | ^5.9.3 | Type system, compilation | Industry standard, latest stable |
| pnpm | ^9.x | Package manager | Faster, efficient disk space, required by CONTEXT.md |
| Vitest | ^4.0.17 | Testing framework | Oxc-powered, native TS support, fast |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| gray-matter | ^4.0.3 | YAML frontmatter stringification | Command props to YAML output |
| tsup | ^8.5.1 | Build/bundle for distribution | Final build step |
| tsx | ^4.21.0 | TypeScript runner for dev | Running tests and scripts |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Vitest | Jest | Jest slower, more config for TS |
| gray-matter | js-yaml | gray-matter handles delimiters automatically |
| pnpm | npm | pnpm required by user decision |

**Installation:**
```bash
pnpm add gray-matter
pnpm add -D typescript vitest tsup tsx @types/node
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── ir/              # IR type definitions
│   ├── index.ts     # Re-exports all IR types
│   └── nodes.ts     # All IR node type definitions
├── emitter/         # Markdown emitter
│   ├── index.ts     # Main emit() function export
│   ├── emitter.ts   # MarkdownEmitter class
│   └── utils.ts     # Indentation, newline helpers
├── transformer/     # (Phase 2) TSX -> IR transformation
├── cli/             # (Phase 4) CLI interface
└── index.ts         # Main library exports

tests/
├── ir/              # IR type tests (if needed)
├── emitter/         # Emitter tests
│   ├── heading.test.ts
│   ├── paragraph.test.ts
│   ├── list.test.ts
│   └── __snapshots__/    # Generated by Vitest
└── integration/     # Full pipeline tests (later phases)
```

### Pattern 1: Discriminated Union for IR Nodes

**What:** All IR nodes share a `kind` property with a literal string type, forming a discriminated union.

**When to use:** Always for AST/IR node hierarchies where you need type-safe switch handling.

**Example:**
```typescript
// Source: TypeScript Handbook, basarat.gitbook.io/typescript

// Base structure - all nodes have kind
interface BaseNode {
  kind: string;
}

// Block-level nodes (standalone elements)
interface HeadingNode {
  kind: 'heading';
  level: 1 | 2 | 3 | 4 | 5 | 6;
  children: InlineNode[];
}

interface ParagraphNode {
  kind: 'paragraph';
  children: InlineNode[];
}

interface ListNode {
  kind: 'list';
  ordered: boolean;
  items: ListItemNode[];
}

interface ListItemNode {
  kind: 'listItem';
  children: BlockNode[];
}

interface CodeBlockNode {
  kind: 'codeBlock';
  language?: string;
  content: string;
}

interface BlockquoteNode {
  kind: 'blockquote';
  children: BlockNode[];
}

interface ThematicBreakNode {
  kind: 'thematicBreak';
}

interface XmlBlockNode {
  kind: 'xmlBlock';
  name: string;
  children: BlockNode[];
}

interface RawMarkdownNode {
  kind: 'raw';
  content: string;
}

interface FrontmatterNode {
  kind: 'frontmatter';
  data: Record<string, unknown>;
}

// Inline nodes (within paragraphs, headings, etc.)
interface TextNode {
  kind: 'text';
  value: string;
}

interface BoldNode {
  kind: 'bold';
  children: InlineNode[];
}

interface ItalicNode {
  kind: 'italic';
  children: InlineNode[];
}

interface InlineCodeNode {
  kind: 'inlineCode';
  value: string;
}

interface LinkNode {
  kind: 'link';
  url: string;
  children: InlineNode[];
}

interface LineBreakNode {
  kind: 'lineBreak';
}

// Union types
type InlineNode = TextNode | BoldNode | ItalicNode | InlineCodeNode | LinkNode | LineBreakNode;
type BlockNode = HeadingNode | ParagraphNode | ListNode | CodeBlockNode | BlockquoteNode | ThematicBreakNode | XmlBlockNode | RawMarkdownNode;
type IRNode = BlockNode | InlineNode | FrontmatterNode | ListItemNode;

// Document root
interface DocumentNode {
  kind: 'document';
  frontmatter?: FrontmatterNode;
  children: BlockNode[];
}
```

### Pattern 2: Switch-Based Emitter with Exhaustiveness

**What:** Emit function uses switch on `node.kind` with exhaustiveness checking via `never` type.

**When to use:** When node types are fixed and unlikely to change frequently (our case).

**Example:**
```typescript
// Source: TypeScript Handbook, TypeScript Wiki

function assertNever(x: never): never {
  throw new Error(`Unexpected node kind: ${(x as IRNode).kind}`);
}

function emitBlock(node: BlockNode): string {
  switch (node.kind) {
    case 'heading':
      return emitHeading(node);
    case 'paragraph':
      return emitParagraph(node);
    case 'list':
      return emitList(node);
    case 'codeBlock':
      return emitCodeBlock(node);
    case 'blockquote':
      return emitBlockquote(node);
    case 'thematicBreak':
      return '---';
    case 'xmlBlock':
      return emitXmlBlock(node);
    case 'raw':
      return node.content;
    default:
      return assertNever(node);
  }
}

function emitInline(node: InlineNode): string {
  switch (node.kind) {
    case 'text':
      return node.value;
    case 'bold':
      return `**${emitInlineChildren(node.children)}**`;
    case 'italic':
      return `*${emitInlineChildren(node.children)}*`;
    case 'inlineCode':
      return `\`${node.value}\``;
    case 'link':
      return `[${emitInlineChildren(node.children)}](${node.url})`;
    case 'lineBreak':
      return '\n';
    default:
      return assertNever(node);
  }
}
```

### Pattern 3: Emitter Class with Context

**What:** Encapsulate emission state (indentation, list depth) in a class.

**When to use:** When emission requires tracking state across nested structures.

**Example:**
```typescript
class MarkdownEmitter {
  private indentLevel = 0;
  private listStack: Array<{ ordered: boolean; index: number }> = [];

  emit(doc: DocumentNode): string {
    const parts: string[] = [];

    if (doc.frontmatter) {
      parts.push(this.emitFrontmatter(doc.frontmatter));
    }

    for (const child of doc.children) {
      parts.push(this.emitBlock(child));
    }

    return parts.join('\n\n');
  }

  private emitFrontmatter(node: FrontmatterNode): string {
    // Use gray-matter for stringification
    return matter.stringify('', node.data).trim();
  }

  private emitBlock(node: BlockNode): string {
    // ... switch-based emission
  }

  private emitList(node: ListNode): string {
    this.listStack.push({ ordered: node.ordered, index: 1 });
    const items = node.items.map(item => this.emitListItem(item));
    this.listStack.pop();
    return items.join('\n');
  }

  private emitListItem(item: ListItemNode): string {
    const current = this.listStack[this.listStack.length - 1];
    const marker = current.ordered ? `${current.index++}.` : '-';
    const indent = '  '.repeat(this.listStack.length - 1);
    const content = item.children.map(c => this.emitBlock(c)).join('\n');
    return `${indent}${marker} ${content}`;
  }
}
```

### Anti-Patterns to Avoid

- **String concatenation in transformer:** Never build Markdown strings during transformation. Always produce IR nodes, emit separately.
- **Mutable shared state:** Avoid global state in emitter. Use class instance or context parameter.
- **Skipping exhaustiveness check:** Always include `default: return assertNever(node)` to catch missing cases at compile time.
- **Deep inheritance:** Don't use class hierarchies for IR nodes. Plain discriminated unions are simpler and more TypeScript-idiomatic.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| YAML frontmatter | Custom YAML serializer | gray-matter | Handles delimiters, escaping, multiline strings |
| Test snapshots | Custom comparison logic | Vitest snapshots | Built-in diffing, update workflow, inline/file options |
| TypeScript building | Custom tsc wrapper | tsup | Handles ESM/CJS, declarations, sourcemaps |

**Key insight:** YAML serialization has many edge cases (special characters, multiline strings, arrays, nested objects). gray-matter is battle-tested in Gatsby, Astro, VitePress, and Netlify.

## Common Pitfalls

### Pitfall 1: Inline vs Block Content Confusion
**What goes wrong:** Treating inline content (bold, italic) the same as block content (paragraphs, lists) leads to incorrect newline handling.
**Why it happens:** Markdown has different whitespace rules for inline vs block elements.
**How to avoid:** Separate `InlineNode` and `BlockNode` union types. Emit function for blocks adds blank lines between elements; inline emit never adds newlines except for explicit `<br/>`.
**Warning signs:** Tests showing extra blank lines or missing line breaks.

### Pitfall 2: List Nesting State
**What goes wrong:** Nested lists lose indentation or use wrong markers.
**Why it happens:** Not tracking list depth and ordered/unordered state per level.
**How to avoid:** Use a stack in the emitter to track current list context. Pop when exiting a list.
**Warning signs:** Flat lists when nested expected, or wrong bullet/number markers.

### Pitfall 3: Forgetting Exhaustiveness Check
**What goes wrong:** Adding a new node type silently falls through without compiler error.
**Why it happens:** Missing `default: assertNever(node)` case in switch.
**How to avoid:** Always include exhaustiveness check. TypeScript will error if a case is unhandled.
**Warning signs:** New node types produce no output or undefined.

### Pitfall 4: YAML Special Characters
**What goes wrong:** Frontmatter with colons, quotes, or special characters breaks YAML parsing.
**Why it happens:** Hand-rolling YAML without proper escaping.
**How to avoid:** Use gray-matter's stringify function. It handles escaping automatically.
**Warning signs:** YAML parse errors in Claude Code commands with special characters in descriptions.

### Pitfall 5: Snapshot Test Brittleness
**What goes wrong:** Tests break on irrelevant whitespace changes.
**Why it happens:** Snapshotting entire output including all whitespace.
**How to avoid:** Use `toMatchFileSnapshot()` for full Markdown (easier to review diffs). Use explicit assertions for critical structural tests. Normalize trailing whitespace in snapshots if needed.
**Warning signs:** CI failures from whitespace-only changes.

## Code Examples

Verified patterns from official sources:

### gray-matter Stringify
```typescript
// Source: github.com/jonschlinkert/gray-matter
import matter from 'gray-matter';

// Create frontmatter from data
const frontmatter = matter.stringify('', {
  name: 'my-command',
  description: 'Does something useful',
  allowedTools: ['Read', 'Write', 'Bash']
});

// Output:
// ---
// name: my-command
// description: Does something useful
// allowedTools:
//   - Read
//   - Write
//   - Bash
// ---
```

### Vitest Inline Snapshot
```typescript
// Source: vitest.dev/guide/snapshot
import { expect, it } from 'vitest';
import { emit } from '../src/emitter';

it('emits heading level 2', () => {
  const node: HeadingNode = {
    kind: 'heading',
    level: 2,
    children: [{ kind: 'text', value: 'Hello World' }]
  };

  expect(emit(node)).toMatchInlineSnapshot(`"## Hello World"`);
});
```

### Vitest File Snapshot
```typescript
// Source: vitest.dev/guide/snapshot
import { expect, it } from 'vitest';
import { emitDocument } from '../src/emitter';

it('emits complete document', async () => {
  const doc: DocumentNode = {
    kind: 'document',
    frontmatter: { kind: 'frontmatter', data: { name: 'test' } },
    children: [
      { kind: 'heading', level: 1, children: [{ kind: 'text', value: 'Title' }] },
      { kind: 'paragraph', children: [{ kind: 'text', value: 'Content here.' }] }
    ]
  };

  await expect(emitDocument(doc)).toMatchFileSnapshot('./fixtures/complete-doc.md');
});
```

### tsconfig.json for CLI Tool
```json
// Source: TypeScript Handbook, notes.shiv.info
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "jsx": "preserve"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}
```

### vitest.config.ts
```typescript
// Source: vitest.dev/config
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    include: ['tests/**/*.test.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html'],
      include: ['src/**/*.ts'],
      exclude: ['src/**/*.d.ts']
    }
  }
});
```

### package.json Scripts
```json
{
  "scripts": {
    "build": "tsup",
    "dev": "tsx watch src/index.ts",
    "test": "vitest",
    "test:run": "vitest run",
    "typecheck": "tsc --noEmit"
  }
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Jest for TS testing | Vitest | 2023-2024 | 10-20x faster test runs |
| ts-node for running TS | tsx (esbuild-powered) | 2023 | ~20x faster startup |
| CommonJS default | ESM first | 2024-2025 | Modern module resolution |
| `moduleResolution: node` | `moduleResolution: NodeNext` | TS 4.7+ | Proper ESM support |

**Deprecated/outdated:**
- `moduleResolution: "node"` (now called "node10") - use "NodeNext" instead
- Jest for new TS projects - Vitest is faster and simpler
- ts-node - tsx is faster for development

## Testing Approach

Based on CONTEXT.md decisions: Vitest with mix of snapshots and explicit assertions.

### Test Structure for Emitter

```
tests/emitter/
├── heading.test.ts       # Heading levels 1-6
├── paragraph.test.ts     # Plain text, inline formatting
├── list.test.ts          # Ordered, unordered, nested
├── code.test.ts          # Inline code, code blocks
├── link.test.ts          # Links with text
├── blockquote.test.ts    # Single and multi-paragraph quotes
├── special.test.ts       # hr, br, raw markdown
├── xmlBlock.test.ts      # Named div blocks
├── frontmatter.test.ts   # YAML frontmatter generation
└── document.test.ts      # Full document emission
```

### Testing Strategy

1. **Unit tests per node type:** Each IR node type gets focused tests
2. **Inline snapshots for simple cases:** `expect(emit(node)).toMatchInlineSnapshot()`
3. **File snapshots for full documents:** `await expect(result).toMatchFileSnapshot('./fixtures/...')`
4. **Explicit assertions for critical parts:** Verify specific behaviors like nesting, escaping
5. **No coverage threshold:** Per CONTEXT.md, keep it light

## Open Questions

Things that couldn't be fully resolved:

1. **Source location tracking granularity**
   - What we know: CONTEXT.md marks this as Claude's discretion
   - What's unclear: Whether to track per-node or per-document
   - Recommendation: Defer to Phase 2 when transformer is built. Start without source locations in IR, add if needed for error messages.

2. **Inline content nesting limits**
   - What we know: Markdown allows `**_bold italic_**` nesting
   - What's unclear: How deep to allow inline nesting in IR
   - Recommendation: Allow arbitrary nesting via `children: InlineNode[]`. The emitter handles any depth naturally through recursion.

## Sources

### Primary (HIGH confidence)
- [TypeScript Handbook - Unions and Intersections](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html)
- [Vitest Getting Started](https://vitest.dev/guide/)
- [Vitest Snapshot Testing](https://vitest.dev/guide/snapshot)
- [gray-matter GitHub](https://github.com/jonschlinkert/gray-matter)
- [TypeScript tsconfig Reference](https://www.typescriptlang.org/tsconfig/)

### Secondary (MEDIUM confidence)
- [Discriminated Unions - TypeScript Deep Dive](https://basarat.gitbook.io/typescript/type-system/discriminated-unions)
- [TypeScript Compiler Emitter Wiki](https://github.com/microsoft/TypeScript/wiki/Codebase-Compiler-Emitter)
- [tsconfig Best Practices - Shiv's Notes](https://notes.shiv.info/javascript/2025/04/21/tsconfig-best-practices/)

### Tertiary (LOW confidence)
- WebSearch community patterns on visitor vs switch - multiple sources agree switch is simpler for fixed node sets

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - verified versions via npm, well-documented
- IR type design: HIGH - TypeScript discriminated unions are established pattern
- Emitter patterns: HIGH - matches TypeScript compiler approach
- Testing approach: HIGH - Vitest docs are comprehensive

**Research date:** 2026-01-20
**Valid until:** 60 days (stable patterns, unlikely to change)

---

## RESEARCH COMPLETE

**Phase:** 1 - Foundation & IR
**Confidence:** HIGH

### Key Findings

- Discriminated unions with `kind` property are the correct pattern for IR nodes
- Switch-based emitter with exhaustiveness checking is simpler than visitor pattern for fixed node types
- gray-matter handles YAML frontmatter stringification with proper escaping
- Vitest inline snapshots for simple tests, file snapshots for full Markdown output
- pnpm + TypeScript 5.9 + Vitest 4.x + tsup 8.x is the current best stack

### File Created

`/Users/glenninizan/workspace/react-agentic/.planning/phases/01-foundation-ir/01-RESEARCH.md`

### Confidence Assessment

| Area | Level | Reason |
|------|-------|--------|
| Standard Stack | HIGH | Versions verified via npm, well-documented |
| IR Type Design | HIGH | Established TypeScript pattern, used in TypeScript compiler |
| Emitter Patterns | HIGH | Matches TypeScript compiler approach, multiple sources agree |
| Testing | HIGH | Vitest documentation is comprehensive |

### Open Questions

- Source location tracking deferred to Phase 2 (when transformer is built)
- Inline nesting handled naturally via recursive children arrays

### Ready for Planning

Research complete. Planner can now create PLAN.md files.
