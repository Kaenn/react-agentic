---
phase: 30-component-composition
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/parser/transformers/markdown.ts
  - src/parser/transformers/shared.ts
autonomous: true

must_haves:
  truths:
    - "Static transformer supports component props (string, number, boolean)"
    - "Static transformer substitutes children prop in component body"
    - "Static transformer returns multiple blocks from fragment components"
    - "Existing parameterless component behavior unchanged (backwards compatible)"
  artifacts:
    - path: "src/parser/transformers/markdown.ts"
      provides: "transformCustomComponent with full prop and children support"
      exports: ["transformCustomComponent"]
    - path: "src/parser/transformers/shared.ts"
      provides: "extractPropNames utility if extracted"
      min_lines: 10
  key_links:
    - from: "src/parser/transformers/markdown.ts"
      to: "src/parser/transformers/dispatch.ts"
      via: "transformToBlock, transformBlockChildren"
      pattern: "transformBlockChildren|transformToBlock"
---

<objective>
Extend static transformer to support props and children in custom components.

Purpose: Achieve feature parity between static (v1) and runtime (v3) transformer paths for component composition. Currently static path only supports parameterless components.

Output: Updated `transformCustomComponent()` in markdown.ts that handles props and children substitution using patterns established in runtime-component.ts.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key reference files
@src/parser/transformers/markdown.ts
@src/parser/transformers/runtime-component.ts
@src/parser/transformers/dispatch.ts
@src/parser/transformers/shared.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add prop extraction to static transformer</name>
  <files>src/parser/transformers/markdown.ts</files>
  <action>
Modify `transformCustomComponent()` in markdown.ts to extract and use props:

1. Remove the error that currently blocks props:
   - Delete: `if (attributes.length > 0) { throw ctx.createError(...) }`

2. Extract props from usage site (port pattern from runtime-component.ts):
   ```typescript
   function extractPropsFromUsage(
     node: JsxElement | JsxSelfClosingElement
   ): Map<string, unknown> {
     const props = new Map<string, unknown>();
     const opening = Node.isJsxElement(node) ? node.getOpeningElement() : node;

     for (const attr of opening.getAttributes()) {
       if (!Node.isJsxAttribute(attr)) continue;

       const name = attr.getNameNode().getText();
       const init = attr.getInitializer();

       if (!init) {
         props.set(name, true); // Boolean shorthand
       } else if (Node.isStringLiteral(init)) {
         props.set(name, init.getLiteralValue());
       } else if (Node.isJsxExpression(init)) {
         const expr = init.getExpression();
         if (expr) {
           if (Node.isNumericLiteral(expr)) {
             props.set(name, Number(expr.getLiteralValue()));
           } else if (expr.getText() === 'true') {
             props.set(name, true);
           } else if (expr.getText() === 'false') {
             props.set(name, false);
           } else if (Node.isStringLiteral(expr)) {
             props.set(name, expr.getLiteralValue());
           }
         }
       }
     }
     return props;
   }
   ```

3. Extract prop names from component declaration (port from runtime-component.ts):
   ```typescript
   function extractPropNamesFromComponent(
     jsx: JsxElement | JsxSelfClosingElement | JsxFragment,
     sourceFile: SourceFile
   ): string[] {
     // Find the component declaration in source file
     // Extract parameter destructuring pattern
   }
   ```
  </action>
  <verify>Build passes: `npm run build`</verify>
  <done>Props extracted from component usage and declaration</done>
</task>

<task type="auto">
  <name>Task 2: Add prop substitution to static transformer</name>
  <files>src/parser/transformers/markdown.ts</files>
  <action>
Add prop substitution when transforming resolved component JSX:

1. Create a prop substitution helper that walks the resolved JSX:
   - Look for `{propName}` expressions
   - Look for `{props.propName}` property access expressions
   - Replace with actual prop values

2. Modify the JSX transformation to use substitution:
   - Before calling `transformToBlock` or `transformFragmentChildren`
   - Apply prop substitution to the resolved JSX

3. For text interpolation in elements like `<p>Hello {name}!</p>`:
   - Transform inline children with prop context
   - Substitute prop references with actual values

Pattern from runtime-component.ts line 499-519:
```typescript
if (Node.isJsxExpression(child)) {
  const expr = child.getExpression();
  if (expr && Node.isIdentifier(expr)) {
    const propName = expr.getText();
    if (props.has(propName)) {
      // Substitute with prop value
    }
  }
}
```

NOTE: Since the static transformer cannot modify AST (ts-morph nodes are immutable), implement substitution at the IR level during transformation by passing props through context.
  </action>
  <verify>Build passes: `npm run build`</verify>
  <done>Prop values substituted in component output</done>
</task>

<task type="auto">
  <name>Task 3: Add children support to static transformer</name>
  <files>src/parser/transformers/markdown.ts</files>
  <action>
Add children prop support to `transformCustomComponent()`:

1. Extract children from usage site:
   - If JsxElement (not self-closing), get JSX children
   - Transform children to BlockNode[] using transformBlockChildren
   - Store as `childrenBlocks`

2. Substitute `{children}` in component body:
   - When encountering `{children}` or `{props.children}` expression
   - Return the `childrenBlocks` array
   - Handle null/undefined children gracefully (return empty)

3. Handle children placement:
   - Children appear at the {children} location in component body
   - Not at the end, but where the component author placed {children}

Pattern:
```typescript
// Check for {children} or {props.children}
if (text === 'children' || text === 'props.children') {
  return childrenBlocks; // Already transformed BlockNode[]
}
```
  </action>
  <verify>Build passes: `npm run build`</verify>
  <done>Children substituted at correct location in component output</done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build`
2. Existing tests pass: `npm test`
3. Manual verification with simple component:
   ```tsx
   const Card = ({ title, children }) => (
     <div name="card">
       <h2>{title}</h2>
       {children}
     </div>
   );

   // Usage
   <Card title="My Card">
     <p>Card content</p>
   </Card>
   ```
   Should produce:
   ```markdown
   <card>
   ## My Card

   Card content
   </card>
   ```
</verification>

<success_criteria>
- [ ] Static transformer accepts component props without error
- [ ] Props substituted in component body (headings, paragraphs, etc.)
- [ ] Children substituted at {children} location
- [ ] Build passes with no TypeScript errors
- [ ] All existing tests pass (backwards compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/30-component-composition/30-01-SUMMARY.md`
</output>
