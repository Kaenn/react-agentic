---
phase: 30-component-composition
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/parser/transformers/markdown.ts
  - src/parser/transformers/types.ts
autonomous: true

must_haves:
  truths:
    - "Static transformer supports component props (string, number, boolean)"
    - "Static transformer substitutes children prop in component body"
    - "Static transformer returns multiple blocks from fragment components (not just first)"
    - "Existing parameterless component behavior unchanged (backwards compatible)"
  artifacts:
    - path: "src/parser/transformers/markdown.ts"
      provides: "transformCustomComponent with full prop, children, and fragment support"
      exports: ["transformCustomComponent"]
    - path: "src/parser/transformers/types.ts"
      provides: "TransformContext with componentProps field"
      contains: "componentProps"
  key_links:
    - from: "src/parser/transformers/markdown.ts"
      to: "src/parser/transformers/dispatch.ts"
      via: "transformToBlock, transformBlockChildren"
      pattern: "transformBlockChildren|transformToBlock"
    - from: "src/parser/transformers/markdown.ts"
      to: "src/parser/transformers/types.ts"
      via: "componentProps context field"
      pattern: "ctx\\.componentProps"
---

<objective>
Extend static transformer to support props, children, and fragments in custom components.

Purpose: Achieve feature parity between static (v1) and runtime (v3) transformer paths for component composition. Currently static path only supports parameterless components and returns only the first block from fragments.

Output: Updated `transformCustomComponent()` in markdown.ts that handles props, children substitution, and returns all blocks from fragments using patterns established in runtime-component.ts.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key reference files
@src/parser/transformers/markdown.ts
@src/parser/transformers/runtime-component.ts
@src/parser/transformers/dispatch.ts
@src/parser/transformers/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add prop extraction to static transformer</name>
  <files>src/parser/transformers/markdown.ts</files>
  <action>
Modify `transformCustomComponent()` in markdown.ts to extract and use props:

1. Remove the error that currently blocks props:
   - Delete: `if (attributes.length > 0) { throw ctx.createError(...) }`

2. Extract props from usage site (port pattern from runtime-component.ts):
   ```typescript
   function extractPropsFromUsage(
     node: JsxElement | JsxSelfClosingElement
   ): Map<string, unknown> {
     const props = new Map<string, unknown>();
     const opening = Node.isJsxElement(node) ? node.getOpeningElement() : node;

     for (const attr of opening.getAttributes()) {
       if (!Node.isJsxAttribute(attr)) continue;

       const name = attr.getNameNode().getText();
       const init = attr.getInitializer();

       if (!init) {
         props.set(name, true); // Boolean shorthand
       } else if (Node.isStringLiteral(init)) {
         props.set(name, init.getLiteralValue());
       } else if (Node.isJsxExpression(init)) {
         const expr = init.getExpression();
         if (expr) {
           if (Node.isNumericLiteral(expr)) {
             props.set(name, Number(expr.getLiteralValue()));
           } else if (expr.getText() === 'true') {
             props.set(name, true);
           } else if (expr.getText() === 'false') {
             props.set(name, false);
           } else if (Node.isStringLiteral(expr)) {
             props.set(name, expr.getLiteralValue());
           }
         }
       }
     }
     return props;
   }
   ```

3. Extract prop names from component declaration (port from runtime-component.ts):
   ```typescript
   function extractPropNamesFromComponent(
     jsx: JsxElement | JsxSelfClosingElement | JsxFragment,
     sourceFile: SourceFile
   ): string[] {
     // Find the component declaration in source file
     // Extract parameter destructuring pattern
   }
   ```
  </action>
  <verify>Build passes: `npm run build`</verify>
  <done>Props extracted from component usage and declaration</done>
</task>

<task type="auto">
  <name>Task 2: Add prop substitution via context</name>
  <files>src/parser/transformers/markdown.ts, src/parser/transformers/types.ts</files>
  <action>
Add prop substitution using context-based approach (ts-morph AST nodes are immutable):

1. **Add componentProps field to TransformContext** (types.ts):
   ```typescript
   export interface TransformContext {
     // ... existing fields
     componentProps?: Map<string, unknown>;  // Props for current component substitution
   }
   ```

2. **Pass props through context when transforming resolved JSX** (markdown.ts):
   - Before calling `transformToBlock` or `transformFragmentChildren` on resolved JSX
   - Set `ctx.componentProps = extractedProps` (from Task 1)
   - After transform completes, restore `ctx.componentProps = undefined`

3. **Substitute props during inline text transformation** (markdown.ts):
   In functions that process text content (headings, paragraphs, inline text):
   - Check for `{propName}` or `{props.propName}` patterns in JSX expressions
   - Look up value in `ctx.componentProps`
   - Return the prop value as text if found

   Example:
   ```typescript
   // When processing JsxExpression children
   if (Node.isJsxExpression(child)) {
     const expr = child.getExpression();
     if (expr && Node.isIdentifier(expr)) {
       const propName = expr.getText();
       if (ctx.componentProps?.has(propName)) {
         return String(ctx.componentProps.get(propName));
       }
     }
     // Also handle props.propName pattern
     if (expr && Node.isPropertyAccessExpression(expr)) {
       const objName = expr.getExpression().getText();
       const propName = expr.getName();
       if (objName === 'props' && ctx.componentProps?.has(propName)) {
         return String(ctx.componentProps.get(propName));
       }
     }
   }
   ```

4. **Integration in transformCustomComponent**:
   ```typescript
   // Extract props
   const props = extractPropsFromUsage(node);

   // Save and set context
   const previousProps = ctx.componentProps;
   ctx.componentProps = props;

   // Transform resolved JSX (uses ctx.componentProps during transformation)
   const result = transformToBlock(resolved.jsx, ctx);

   // Restore context
   ctx.componentProps = previousProps;
   ```

NOTE: This approach substitutes props at the IR level during transformation by reading props from context, NOT by modifying the AST.
  </action>
  <verify>Build passes: `npm run build`</verify>
  <done>Prop values substituted in component output via context</done>
</task>

<task type="auto">
  <name>Task 3: Add children support to static transformer</name>
  <files>src/parser/transformers/markdown.ts</files>
  <action>
Add children prop support to `transformCustomComponent()`:

1. Extract children from usage site:
   - If JsxElement (not self-closing), get JSX children
   - Transform children to BlockNode[] using transformBlockChildren
   - Store as `childrenBlocks`

2. Substitute `{children}` in component body:
   - When encountering `{children}` or `{props.children}` expression
   - Return the `childrenBlocks` array
   - Handle null/undefined children gracefully (return empty)

3. Handle children placement:
   - Children appear at the {children} location in component body
   - Not at the end, but where the component author placed {children}

Pattern:
```typescript
// Check for {children} or {props.children}
if (text === 'children' || text === 'props.children') {
  return childrenBlocks; // Already transformed BlockNode[]
}
```
  </action>
  <verify>Build passes: `npm run build`</verify>
  <done>Children substituted at correct location in component output</done>
</task>

<task type="auto">
  <name>Task 4: Return all blocks from fragment components</name>
  <files>src/parser/transformers/markdown.ts</files>
  <action>
Fix fragment handling to return all blocks instead of just the first:

1. **Locate the fragment handling code** (around lines 237-241):
   ```typescript
   // CURRENT (wrong):
   if (Node.isJsxFragment(resolved.jsx)) {
     const blocks = transformFragmentChildren(resolved.jsx, ctx);
     result = blocks[0] ?? null;  // Only returns first block!
   }
   ```

2. **Change return type** of `transformCustomComponent`:
   - From: `BlockNode | null`
   - To: `BlockNode | BlockNode[] | null`

3. **Return all blocks from fragments**:
   ```typescript
   // FIXED:
   if (Node.isJsxFragment(resolved.jsx)) {
     const blocks = transformFragmentChildren(resolved.jsx, ctx);
     // Return all blocks, not just first
     if (blocks.length === 0) {
       result = null;
     } else if (blocks.length === 1) {
       result = blocks[0];
     } else {
       result = blocks;  // Return array for multiple blocks
     }
   }
   ```

4. **Update callers** in dispatch.ts:
   - `transformCustomComponent` may now return `BlockNode[]`
   - Callers must handle array case (spread into parent children)

   In dispatch.ts `transformToBlock`:
   ```typescript
   if (isCustomComponent(name)) {
     const result = transformCustomComponent(name, node, ctx);
     // If array, caller must handle (or flatten if single-element array)
     return result;
   }
   ```

5. **Verify emitter handles arrays**:
   - Emitter already joins BlockNode[] with '\n\n' (emitter.ts line 80)
   - No emitter changes needed

This satisfies requirement COMP-04: Fragment composition - multiple elements from composite without wrapper.
  </action>
  <verify>Build passes: `npm run build`</verify>
  <done>Fragment components return all blocks, not just first</done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build`
2. Existing tests pass: `npm test`
3. Manual verification with simple component:
   ```tsx
   const Card = ({ title, children }) => (
     <div name="card">
       <h2>{title}</h2>
       {children}
     </div>
   );

   // Usage
   <Card title="My Card">
     <p>Card content</p>
   </Card>
   ```
   Should produce:
   ```markdown
   <card>
   ## My Card

   Card content
   </card>
   ```
4. Manual verification with fragment component:
   ```tsx
   const Header = () => (
     <>
       <h1>Title</h1>
       <h2>Subtitle</h2>
     </>
   );
   ```
   Should produce:
   ```markdown
   # Title

   ## Subtitle
   ```
   (Both headings, not just first)
</verification>

<success_criteria>
- [ ] Static transformer accepts component props without error
- [ ] Props substituted in component body (headings, paragraphs, etc.)
- [ ] Children substituted at {children} location
- [ ] Fragment components return all blocks (not just first)
- [ ] Build passes with no TypeScript errors
- [ ] All existing tests pass (backwards compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/30-component-composition/30-01-SUMMARY.md`
</output>
