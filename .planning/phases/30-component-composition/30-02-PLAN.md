---
phase: 30-component-composition
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/parser/static-component.test.ts
  - tests/parser/fragment-composition.test.ts
autonomous: true

must_haves:
  truths:
    - "Static transformer tests cover props, children, and fragments"
    - "Tests verify parity between static and runtime paths"
    - "Fragment tests verify multiple blocks returned without wrapper"
    - "Content type usage documented via test examples"
  artifacts:
    - path: "tests/parser/static-component.test.ts"
      provides: "Static transformer component composition tests"
      min_lines: 150
    - path: "tests/parser/fragment-composition.test.ts"
      provides: "Fragment handling tests for both paths"
      min_lines: 100
  key_links:
    - from: "tests/parser/static-component.test.ts"
      to: "src/parser/transformers/markdown.ts"
      via: "transformCustomComponent import"
      pattern: "transformCustomComponent|transformToBlock"
---

<objective>
Add comprehensive test coverage for component composition in both static and runtime paths.

Purpose: Verify feature parity between static (v1) and runtime (v3) transformer paths, document patterns via tests, and ensure fragment composition works correctly.

Output: Two new test files covering static component tests and fragment composition tests.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key reference files
@tests/parser/local-component.test.ts
@src/parser/transformers/markdown.ts
@src/parser/transformers/runtime-component.ts
@src/ir/content-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create static component test file</name>
  <files>tests/parser/static-component.test.ts</files>
  <action>
Create `tests/parser/static-component.test.ts` for static transformer component tests:

```typescript
import { describe, expect, it } from 'vitest';
import { Project, Node } from 'ts-morph';
import { emitDocument } from '../../src/emitter/index.js';
// Import static transformer functions

describe('Static Component Composition', () => {
  // Helper to transform static TSX (non-runtime path)
  function buildStatic(tsx: string): string {
    // Use static transform path (no render props)
  }

  describe('component with props', () => {
    it('substitutes string props in text', () => {
      // <Greeting name="World" /> -> "Hello World!"
    });

    it('substitutes props in heading', () => {
      // <Section title="My Title" /> -> ## My Title
    });

    it('substitutes numeric props', () => {
      // <Counter count={42} /> -> Count: 42
    });

    it('substitutes boolean shorthand props', () => {
      // <Status active /> -> Active: true
    });

    it('handles default prop values', () => {
      // const Comp = ({ delay = 5 }) => ...
      // <Comp /> should use default
    });
  });

  describe('component with children', () => {
    it('substitutes children in XmlBlock wrapper', () => {
      // <Card><p>Content</p></Card> -> <card>Content</card>
    });

    it('handles empty children gracefully', () => {
      // <Wrapper /> with no children
    });

    it('substitutes children at correct location', () => {
      // <Section title="T">{children}<hr/></Section>
      // Children should appear before hr
    });
  });

  describe('component with props and children', () => {
    it('handles both props and children', () => {
      // <Section title="T"><p>Content</p></Section>
    });
  });
});
```

Structure tests to mirror `local-component.test.ts` but use static transform path.
Use existing test utilities from the codebase.
  </action>
  <verify>`npm test -- --testNamePattern="Static Component" --reporter=dot`</verify>
  <done>Static component tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Create fragment composition test file</name>
  <files>tests/parser/fragment-composition.test.ts</files>
  <action>
Create `tests/parser/fragment-composition.test.ts` for fragment handling tests:

```typescript
import { describe, expect, it } from 'vitest';
// ... imports

describe('Fragment Composition', () => {
  describe('static path fragments', () => {
    it('returns multiple blocks from fragment component', () => {
      // const Header = () => <><h1>Title</h1><h2>Subtitle</h2></>;
      // Should produce two separate headings, no wrapper
    });

    it('flattens nested fragments', () => {
      // <><><h1>A</h1></><><h1>B</h1></></>
      // Should produce flat list of two headings
    });

    it('uses block separator for block children', () => {
      // Verify double newline between headings
    });
  });

  describe('runtime path fragments', () => {
    // Mirror tests for runtime path to verify parity
    it('returns multiple blocks from fragment component', () => {
      // Same test as static but with runtime transform
    });

    it('flattens nested fragments', () => {
      // Same test
    });
  });

  describe('fragment separator behavior', () => {
    it('uses double newline between block elements', () => {
      // h1 + h2 -> "# A\n\n## B"
    });

    it('preserves inline flow for inline elements', () => {
      // If fragments contain inline-only content
    });
  });
});
```

Verify emitter joins fragment blocks with '\n\n' as expected.
  </action>
  <verify>`npm test -- --testNamePattern="Fragment Composition" --reporter=dot`</verify>
  <done>Fragment composition tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Add parity tests between paths</name>
  <files>tests/parser/static-component.test.ts</files>
  <action>
Add a parity test section that runs the same TSX through both paths:

```typescript
describe('static/runtime parity', () => {
  // Helper that builds via both paths
  function buildBoth(staticTsx: string, runtimeTsx: string): { static: string, runtime: string } {
    return {
      static: buildStatic(staticTsx),
      runtime: buildRuntime(runtimeTsx)
    };
  }

  it('produces same output for simple component', () => {
    const component = `const Greeting = () => <p>Hello World</p>;`;
    const staticUsage = `export default <><Greeting /></>`;
    const runtimeUsage = `export default <Command name="test">{() => <Greeting />}</Command>`;

    const { static: s, runtime: r } = buildBoth(
      component + staticUsage,
      component + runtimeUsage
    );

    // Both should contain "Hello World"
    expect(s).toContain('Hello World');
    expect(r).toContain('Hello World');
  });

  it('produces same output for component with props', () => {
    // <Greeting name="Alice" /> via both paths
  });

  it('produces same output for component with children', () => {
    // <Card><p>Content</p></Card> via both paths
  });
});
```

Note: Output won't be byte-for-byte identical (Command has frontmatter) but the component content should match.
  </action>
  <verify>`npm test -- --testNamePattern="parity" --reporter=dot`</verify>
  <done>Parity tests verify both paths produce equivalent component output</done>
</task>

</tasks>

<verification>
1. All tests pass: `npm test`
2. New test count increases by ~20 tests
3. Coverage includes:
   - Static props (string, number, boolean, default)
   - Static children (XmlBlock, div, empty)
   - Static props + children combined
   - Fragment multiple blocks
   - Fragment nested flattening
   - Parity between static/runtime
</verification>

<success_criteria>
- [ ] `tests/parser/static-component.test.ts` exists with passing tests
- [ ] `tests/parser/fragment-composition.test.ts` exists with passing tests
- [ ] Parity tests verify static and runtime paths produce equivalent output
- [ ] All tests pass: `npm test`
- [ ] Test count increased by 15+ tests
</success_criteria>

<output>
After completion, create `.planning/phases/30-component-composition/30-02-SUMMARY.md`
</output>
