---
phase: 30-component-composition
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/parser/static-component.test.ts
  - tests/parser/fragment-composition.test.ts
autonomous: true

must_haves:
  truths:
    - "Static transformer tests cover props, children, and fragments"
    - "Tests verify parity between static and runtime paths"
    - "Fragment tests verify multiple blocks returned without wrapper"
  artifacts:
    - path: "tests/parser/static-component.test.ts"
      provides: "Static transformer component composition tests"
      min_lines: 150
    - path: "tests/parser/fragment-composition.test.ts"
      provides: "Fragment handling tests for both paths"
      min_lines: 100
  key_links:
    - from: "tests/parser/static-component.test.ts"
      to: "src/parser/transformers/markdown.ts"
      via: "transformToBlock, transformBlockChildren imports"
      pattern: "transformToBlock|transformBlockChildren"
    - from: "tests/parser/static-component.test.ts"
      to: "src/parser/transformers/types.ts"
      via: "TransformContext import"
      pattern: "TransformContext"
---

<objective>
Add comprehensive test coverage for component composition in both static and runtime paths.

Purpose: Verify feature parity between static (v1) and runtime (v3) transformer paths, and ensure fragment composition works correctly.

Output: Two new test files covering static component tests and fragment composition tests.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key reference files
@tests/parser/local-component.test.ts
@src/parser/transformers/markdown.ts
@src/parser/transformers/dispatch.ts
@src/parser/transformers/types.ts
@src/ir/content-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create static component test file</name>
  <files>tests/parser/static-component.test.ts</files>
  <action>
Create `tests/parser/static-component.test.ts` for static transformer component tests.

**Key implementation - buildStatic() helper:**

Use the same pattern as local-component.test.ts but invoke the static (V1) transformer path instead of runtime (V3):

```typescript
import { describe, expect, it } from 'vitest';
import { Node, SourceFile } from 'ts-morph';
import {
  createProject,
  parseSource,
  transformToBlock,
  transformBlockChildren,
} from '../../src/index.js';
import type { TransformContext } from '../../src/parser/transformers/types.js';
import { emitDocument } from '../../src/emitter/index.js';

describe('Static Component Composition', () => {
  let testCounter = 0;

  /**
   * Create a TransformContext for static path (no runtime context)
   */
  function createStaticContext(sourceFile: SourceFile): TransformContext {
    return {
      sourceFile,
      createError: (msg: string, node?: Node) => new Error(msg),
      // No runtimeVars, no localComponents - pure static path
    };
  }

  /**
   * Transform static TSX (non-runtime path) to markdown.
   * Uses transformToBlock directly like V1 path does.
   */
  function buildStatic(tsx: string): string {
    const project = createProject();
    const source = parseSource(project, tsx, `test-static-${testCounter++}.tsx`);

    // Find the exported JSX element (not wrapped in Command)
    let rootJsx: Node | null = null;
    source.forEachDescendant((node, traversal) => {
      if (Node.isExportAssignment(node)) {
        const expr = node.getExpression();
        if (expr) {
          let unwrapped = expr;
          while (Node.isParenthesizedExpression(unwrapped)) {
            unwrapped = unwrapped.getExpression();
          }
          if (Node.isJsxElement(unwrapped) || Node.isJsxSelfClosingElement(unwrapped) || Node.isJsxFragment(unwrapped)) {
            rootJsx = unwrapped;
            traversal.stop();
          }
        }
      }
    });

    if (!rootJsx) throw new Error('No JSX found in export default');

    const ctx = createStaticContext(source);
    const block = transformToBlock(rootJsx, ctx);
    if (!block) throw new Error('Transform returned null');

    // Handle array result from fragment components
    const doc = {
      type: 'document' as const,
      name: 'test',
      description: 'test',
      children: Array.isArray(block) ? block : [block],
    };
    return emitDocument(doc);
  }

  describe('component with props', () => {
    it('substitutes string props in text', () => {
      const tsx = `
        const Greeting = ({ name }) => <p>Hello {name}!</p>;
        export default <Greeting name="World" />;
      `;
      const result = buildStatic(tsx);
      expect(result).toContain('Hello World!');
    });

    it('substitutes props in heading', () => {
      const tsx = `
        const Section = ({ title }) => <h2>{title}</h2>;
        export default <Section title="My Title" />;
      `;
      const result = buildStatic(tsx);
      expect(result).toContain('## My Title');
    });

    it('substitutes numeric props', () => {
      const tsx = `
        const Counter = ({ count }) => <p>Count: {count}</p>;
        export default <Counter count={42} />;
      `;
      const result = buildStatic(tsx);
      expect(result).toContain('Count: 42');
    });

    it('substitutes boolean shorthand props', () => {
      const tsx = `
        const Status = ({ active }) => <p>Active: {active}</p>;
        export default <Status active />;
      `;
      const result = buildStatic(tsx);
      expect(result).toContain('Active: true');
    });
  });

  describe('component with children', () => {
    it('substitutes children in XmlBlock wrapper', () => {
      const tsx = `
        const Card = ({ children }) => (
          <div name="card">{children}</div>
        );
        export default <Card><p>Content</p></Card>;
      `;
      const result = buildStatic(tsx);
      expect(result).toContain('<card>');
      expect(result).toContain('Content');
      expect(result).toContain('</card>');
    });

    it('handles empty children gracefully', () => {
      const tsx = `
        const Wrapper = ({ children }) => (
          <div name="wrapper">{children}</div>
        );
        export default <Wrapper />;
      `;
      // Should not throw
      const result = buildStatic(tsx);
      expect(result).toContain('<wrapper>');
    });
  });

  describe('component with props and children', () => {
    it('handles both props and children', () => {
      const tsx = `
        const Section = ({ title, children }) => (
          <>
            <h2>{title}</h2>
            {children}
          </>
        );
        export default <Section title="Title"><p>Content</p></Section>;
      `;
      const result = buildStatic(tsx);
      expect(result).toContain('## Title');
      expect(result).toContain('Content');
    });
  });
});
```

NOTE: Import `transformToBlock` and `transformBlockChildren` from `'../../src/index.js'` which re-exports from `'../../src/parser/transformers/index.js'`.
  </action>
  <verify>`npm test -- --testNamePattern="Static Component" --reporter=dot`</verify>
  <done>Static component tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Create fragment composition test file</name>
  <files>tests/parser/fragment-composition.test.ts</files>
  <action>
Create `tests/parser/fragment-composition.test.ts` for fragment handling tests.

**Key implementation - use same buildStatic() pattern:**

```typescript
import { describe, expect, it } from 'vitest';
import { Node, SourceFile } from 'ts-morph';
import {
  createProject,
  parseSource,
  transformToBlock,
  transformBlockChildren,
  transformRuntimeCommand,
  createRuntimeContext,
  extractLocalComponentDeclarations,
} from '../../src/index.js';
import type { TransformContext } from '../../src/parser/transformers/types.js';
import { emitDocument } from '../../src/emitter/index.js';

describe('Fragment Composition', () => {
  let testCounter = 0;

  // Helper: create static context (same as static-component.test.ts)
  function createStaticContext(sourceFile: SourceFile): TransformContext {
    return {
      sourceFile,
      createError: (msg: string, node?: Node) => new Error(msg),
    };
  }

  // Helper: build via static path
  function buildStatic(tsx: string): string {
    const project = createProject();
    const source = parseSource(project, tsx, `test-frag-static-${testCounter++}.tsx`);

    let rootJsx: Node | null = null;
    source.forEachDescendant((node, traversal) => {
      if (Node.isExportAssignment(node)) {
        const expr = node.getExpression();
        if (expr) {
          let unwrapped = expr;
          while (Node.isParenthesizedExpression(unwrapped)) {
            unwrapped = unwrapped.getExpression();
          }
          if (Node.isJsxElement(unwrapped) || Node.isJsxSelfClosingElement(unwrapped) || Node.isJsxFragment(unwrapped)) {
            rootJsx = unwrapped;
            traversal.stop();
          }
        }
      }
    });

    if (!rootJsx) throw new Error('No JSX found');

    const ctx = createStaticContext(source);
    const block = transformToBlock(rootJsx, ctx);
    if (!block) throw new Error('Transform returned null');

    const doc = {
      type: 'document' as const,
      name: 'test',
      description: 'test',
      children: Array.isArray(block) ? block : [block],
    };
    return emitDocument(doc);
  }

  // Helper: build via runtime path (from local-component.test.ts)
  function buildRuntime(tsx: string): string {
    const project = createProject();
    const source = parseSource(project, tsx, `test-frag-runtime-${testCounter++}.tsx`);

    let root: Node | null = null;
    source.forEachDescendant((node, traversal) => {
      if (Node.isExportAssignment(node)) {
        const expr = node.getExpression();
        if (expr) {
          let unwrapped = expr;
          while (Node.isParenthesizedExpression(unwrapped)) {
            unwrapped = unwrapped.getExpression();
          }
          if (Node.isJsxElement(unwrapped) || Node.isJsxSelfClosingElement(unwrapped)) {
            root = unwrapped;
            traversal.stop();
          }
        }
      }
    });

    if (!root) throw new Error('No Command JSX found');
    if (!Node.isJsxElement(root) && !Node.isJsxSelfClosingElement(root)) {
      throw new Error('Root is not a JSX element');
    }

    const ctx = createRuntimeContext(source);
    extractLocalComponentDeclarations(source, ctx);
    const doc = transformRuntimeCommand(root, ctx);
    return emitDocument(doc);
  }

  describe('static path fragments', () => {
    it('returns multiple blocks from fragment component', () => {
      const tsx = `
        const Header = () => (
          <>
            <h1>Title</h1>
            <h2>Subtitle</h2>
          </>
        );
        export default <Header />;
      `;
      const result = buildStatic(tsx);
      expect(result).toContain('# Title');
      expect(result).toContain('## Subtitle');
    });

    it('flattens nested fragments', () => {
      const tsx = `
        const Nested = () => (
          <>
            <><h1>A</h1></>
            <><h1>B</h1></>
          </>
        );
        export default <Nested />;
      `;
      const result = buildStatic(tsx);
      expect(result).toContain('# A');
      expect(result).toContain('# B');
    });
  });

  describe('runtime path fragments', () => {
    it('returns multiple blocks from fragment component', () => {
      const tsx = `
        const Header = () => (
          <>
            <h1>Title</h1>
            <h2>Subtitle</h2>
          </>
        );

        export default (
          <Command name="test" description="Test">
            {() => <Header />}
          </Command>
        );
      `;
      const result = buildRuntime(tsx);
      expect(result).toContain('# Title');
      expect(result).toContain('## Subtitle');
    });
  });

  describe('fragment separator behavior', () => {
    it('uses double newline between block elements', () => {
      const tsx = `
        const TwoHeadings = () => (
          <>
            <h1>First</h1>
            <h2>Second</h2>
          </>
        );
        export default <TwoHeadings />;
      `;
      const result = buildStatic(tsx);
      // Should have blank line between blocks
      expect(result).toMatch(/# First\n\n## Second/);
    });
  });
});
```

NOTE: Both buildStatic and buildRuntime use the same helper pattern. Import all needed functions from `'../../src/index.js'`.
  </action>
  <verify>`npm test -- --testNamePattern="Fragment Composition" --reporter=dot`</verify>
  <done>Fragment composition tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Add parity tests between paths</name>
  <files>tests/parser/static-component.test.ts</files>
  <action>
Add a parity test section that runs the same TSX through both paths:

```typescript
describe('static/runtime parity', () => {
  // Add buildRuntime helper to this file (same as fragment-composition.test.ts)

  it('produces same output for simple component', () => {
    const component = `const Greeting = () => <h2>Hello World</h2>;`;
    const staticUsage = `export default <Greeting />;`;
    const runtimeUsage = `
      export default (
        <Command name="test" description="Test">
          {() => <Greeting />}
        </Command>
      );
    `;

    const staticResult = buildStatic(component + staticUsage);
    const runtimeResult = buildRuntime(component + runtimeUsage);

    // Both should contain "Hello World"
    expect(staticResult).toContain('Hello World');
    expect(runtimeResult).toContain('Hello World');
  });

  it('produces same output for component with props', () => {
    const component = `const Greeting = ({ name }) => <p>Hello {name}!</p>;`;
    const staticUsage = `export default <Greeting name="Alice" />;`;
    const runtimeUsage = `
      export default (
        <Command name="test" description="Test">
          {() => <Greeting name="Alice" />}
        </Command>
      );
    `;

    const staticResult = buildStatic(component + staticUsage);
    const runtimeResult = buildRuntime(component + runtimeUsage);

    expect(staticResult).toContain('Hello Alice!');
    expect(runtimeResult).toContain('Hello Alice!');
  });

  it('produces same output for component with children', () => {
    const component = `
      const Card = ({ children }) => (
        <div name="card">{children}</div>
      );
    `;
    const staticUsage = `export default <Card><p>Content</p></Card>;`;
    const runtimeUsage = `
      export default (
        <Command name="test" description="Test">
          {() => <Card><p>Content</p></Card>}
        </Command>
      );
    `;

    const staticResult = buildStatic(component + staticUsage);
    const runtimeResult = buildRuntime(component + runtimeUsage);

    expect(staticResult).toContain('Content');
    expect(runtimeResult).toContain('Content');
  });
});
```

Note: Output won't be byte-for-byte identical (Command has frontmatter) but the component content should match.
  </action>
  <verify>`npm test -- --testNamePattern="parity" --reporter=dot`</verify>
  <done>Parity tests verify both paths produce equivalent component output</done>
</task>

</tasks>

<verification>
1. All tests pass: `npm test`
2. New test count increases by ~20 tests
3. Coverage includes:
   - Static props (string, number, boolean, default)
   - Static children (XmlBlock, div, empty)
   - Static props + children combined
   - Fragment multiple blocks
   - Fragment nested flattening
   - Parity between static/runtime
</verification>

<success_criteria>
- [ ] `tests/parser/static-component.test.ts` exists with passing tests
- [ ] `tests/parser/fragment-composition.test.ts` exists with passing tests
- [ ] Parity tests verify static and runtime paths produce equivalent output
- [ ] All tests pass: `npm test`
- [ ] Test count increased by 15+ tests
</success_criteria>

<output>
After completion, create `.planning/phases/30-component-composition/30-02-SUMMARY.md`
</output>
