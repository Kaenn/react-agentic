---
phase: 18-mcp-configuration
plan: 03
type: execute
wave: 3
depends_on: [18-02]
files_modified:
  - src/emitter/settings.ts
  - src/emitter/index.ts
  - src/cli/commands/build.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "emitSettings function converts MCPConfigDocumentNode to JSON string"
    - "mergeSettings reads existing settings.json, updates only mcpServers"
    - "Build command routes src/app/mcp/*.tsx to settings.json output"
    - "Existing settings.json content (permissions, etc.) preserved"
  artifacts:
    - path: "src/emitter/settings.ts"
      provides: "emitSettings, mergeSettings functions"
      exports: ["emitSettings", "mergeSettings"]
    - path: "src/cli/commands/build.ts"
      provides: "MCP config file routing"
      contains: "mcpConfigDocument"
  key_links:
    - from: "src/cli/commands/build.ts"
      to: "src/emitter/settings.ts"
      via: "import emitSettings, mergeSettings"
      pattern: "emitSettings|mergeSettings"
    - from: "src/emitter/settings.ts"
      to: ".claude/settings.json"
      via: "file write with merge"
      pattern: "mcpServers"
---

<objective>
Create settings.json emitter with merge logic and integrate into build command.

Purpose: Produce valid Claude Code settings.json from MCP configuration TSX files, preserving existing settings while updating the mcpServers section.

Output: emitSettings function, mergeSettings function, build command routing for MCP files
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-mcp-configuration/18-CONTEXT.md
@.planning/phases/18-mcp-configuration/18-RESEARCH.md
@.planning/phases/18-mcp-configuration/18-01-SUMMARY.md
@.planning/phases/18-mcp-configuration/18-02-SUMMARY.md
@src/emitter/emitter.ts
@src/cli/commands/build.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create settings.ts emitter module</name>
  <files>src/emitter/settings.ts</files>
  <action>
Create new file `src/emitter/settings.ts` with functions for MCP configuration emission.

```typescript
/**
 * Settings.json Emitter - MCP configuration to Claude Code settings
 *
 * Converts MCPConfigDocumentNode to JSON format and handles
 * merging with existing settings.json content.
 */
import { readFile, writeFile, mkdir } from 'fs/promises';
import path from 'path';
import type { MCPServerNode, MCPConfigDocumentNode } from '../ir/nodes.js';

/**
 * MCP server configuration format for settings.json
 */
interface MCPServerConfig {
  type: 'stdio' | 'http' | 'sse';
  command?: string;
  args?: string[];
  url?: string;
  headers?: Record<string, string>;
  env?: Record<string, string>;
}

/**
 * Convert MCPServerNode to settings.json config format
 */
function serverNodeToConfig(node: MCPServerNode): MCPServerConfig {
  const config: MCPServerConfig = {
    type: node.type,
  };

  // Stdio-specific
  if (node.command) config.command = node.command;
  if (node.args && node.args.length > 0) config.args = node.args;

  // HTTP/SSE-specific
  if (node.url) config.url = node.url;
  if (node.headers && Object.keys(node.headers).length > 0) {
    config.headers = node.headers;
  }

  // Common
  if (node.env && Object.keys(node.env).length > 0) {
    config.env = node.env;
  }

  return config;
}

/**
 * Convert MCPConfigDocumentNode to mcpServers object
 *
 * @param doc - MCP config document from transformer
 * @returns mcpServers object keyed by server name
 */
export function emitSettings(
  doc: MCPConfigDocumentNode
): Record<string, MCPServerConfig> {
  const servers: Record<string, MCPServerConfig> = {};

  for (const server of doc.servers) {
    servers[server.name] = serverNodeToConfig(server);
  }

  return servers;
}

/**
 * Merge MCP servers into existing settings.json
 *
 * Read-modify-write pattern:
 * 1. Read existing settings.json (or start fresh)
 * 2. Update only mcpServers section
 * 3. Write back with pretty formatting
 *
 * @param settingsPath - Path to settings.json
 * @param servers - New mcpServers to merge
 */
export async function mergeSettings(
  settingsPath: string,
  servers: Record<string, MCPServerConfig>
): Promise<void> {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let existing: Record<string, any> = {};

  // Read existing settings if present
  try {
    const content = await readFile(settingsPath, 'utf-8');
    existing = JSON.parse(content);
  } catch (error) {
    // File doesn't exist or invalid JSON - start fresh
    // Only mcpServers section will be created
  }

  // Merge mcpServers section (TSX wins on conflicts)
  existing.mcpServers = {
    ...(existing.mcpServers || {}),
    ...servers,
  };

  // Ensure directory exists
  const dir = path.dirname(settingsPath);
  await mkdir(dir, { recursive: true });

  // Write back with pretty formatting (2-space indent)
  await writeFile(settingsPath, JSON.stringify(existing, null, 2) + '\n', 'utf-8');
}
```

Key behaviors:
- `emitSettings`: Pure function converting IR to JSON structure (no I/O)
- `mergeSettings`: Handles file I/O with read-modify-write pattern
- TSX wins on conflicts (spread order: existing first, then new)
- Existing non-mcpServers settings (permissions, model, etc.) preserved
- Creates .claude/ directory if needed
- Pretty-prints JSON with 2-space indent and trailing newline
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Unit test: emitSettings with mock MCPConfigDocumentNode returns correct structure
3. Integration test: mergeSettings preserves existing settings
  </verify>
  <done>
emitSettings converts MCPConfigDocumentNode to mcpServers object. mergeSettings reads existing settings.json, merges mcpServers, and writes back preserving other content.
  </done>
</task>

<task type="auto">
  <name>Task 2: Export settings functions and update build command</name>
  <files>src/emitter/index.ts, src/index.ts, src/cli/commands/build.ts</files>
  <action>
**Step 1: Export from emitter/index.ts**

Add to src/emitter/index.ts:
```typescript
export { emitSettings, mergeSettings } from './settings.js';
```

**Step 2: Export from main index.ts**

Add to src/index.ts exports:
```typescript
export { emitSettings, mergeSettings } from './emitter/index.js';
```

**Step 3: Update build.ts to handle MCP config files**

Import new functions:
```typescript
import {
  // ... existing imports ...
  emitSettings,
  mergeSettings,
} from '../../index.js';
import type {
  DocumentNode,
  AgentDocumentNode,
  SkillDocumentNode,
  MCPConfigDocumentNode
} from '../../index.js';
```

Add MCP config handling to runBuild function. After the existing document type handling:

```typescript
// After existing skill/agent/command handling in the loop:

} else if (doc.kind === 'mcpConfigDocument') {
  // MCP config: collect servers for batch merge at end
  // Store in mcpConfigs array (defined outside loop)
  mcpConfigs.push({
    inputFile,
    doc,
  });
  // Don't add to results - settings.json handled separately
}
```

Before the loop, add:
```typescript
const mcpConfigs: { inputFile: string; doc: MCPConfigDocumentNode }[] = [];
```

After the results loop, handle MCP configs:
```typescript
// Merge all MCP configs into settings.json
if (mcpConfigs.length > 0) {
  const allServers: Record<string, any> = {};

  for (const { doc } of mcpConfigs) {
    const servers = emitSettings(doc);
    Object.assign(allServers, servers);
  }

  if (!options.dryRun) {
    await mergeSettings('.claude/settings.json', allServers);
  }

  // Log success for MCP configs
  for (const { inputFile } of mcpConfigs) {
    logSuccess(inputFile, '.claude/settings.json');
  }

  // Add to results count for summary
  results.push({
    inputFile: mcpConfigs.map(c => c.inputFile).join(', '),
    outputPath: '.claude/settings.json',
    content: JSON.stringify(allServers, null, 2),
    size: Buffer.byteLength(JSON.stringify(allServers), 'utf8'),
  });
}
```

Note: MCP config files can be placed anywhere the glob patterns match. The Context document recommends `src/app/mcp/` but doesn't enforce it. The routing is based on document kind, not file path.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Build a sample MCP config TSX file
3. Verify settings.json is created/updated with correct structure
4. Verify existing settings content is preserved
  </verify>
  <done>
Build command routes MCPConfigDocumentNode files to settings.json with merge semantics. Multiple MCP config files merge into single settings.json. Dry-run mode shows what would be written.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors
2. Create sample MCP config in src/app/mcp/servers.tsx with MCPConfig containing servers
3. Run build - verify .claude/settings.json created with mcpServers section
4. Manually add other content to settings.json, rebuild - verify non-mcpServers preserved
5. Add second MCP config file, rebuild - verify servers merge correctly
</verification>

<success_criteria>
- emitSettings converts MCPConfigDocumentNode to JSON structure
- mergeSettings preserves existing settings.json content
- Build command detects MCPConfigDocumentNode and routes to settings.json
- Multiple MCP files merge into single settings.json
- Dry-run mode works correctly (no file writes)
- Success logging shows input file -> settings.json
</success_criteria>

<output>
After completion, create `.planning/phases/18-mcp-configuration/18-03-SUMMARY.md`
</output>
