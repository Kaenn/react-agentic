---
phase: 18-mcp-configuration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ir/nodes.ts
  - src/jsx.ts
autonomous: true

must_haves:
  truths:
    - "MCPServerNode type exists in IR with kind discriminator"
    - "MCPServerProps interface supports stdio and http/sse types"
    - "MCPStdioServer and MCPHTTPServer convenience components exist"
    - "TypeScript compiles without errors"
  artifacts:
    - path: "src/ir/nodes.ts"
      provides: "MCPServerNode, MCPConfigDocumentNode types"
      contains: "kind: 'mcpServer'"
    - path: "src/jsx.ts"
      provides: "MCPServerProps, MCPServer, MCPStdioServer, MCPHTTPServer"
      exports: ["MCPServer", "MCPStdioServer", "MCPHTTPServer", "MCPServerProps"]
  key_links:
    - from: "src/jsx.ts"
      to: "src/ir/nodes.ts"
      via: "Type alignment for MCPServer transformation"
      pattern: "MCPServerNode"
---

<objective>
Add IR node types and JSX component stubs for MCP server configuration.

Purpose: Foundation layer for MCP configuration - defines the data structures that represent MCP servers in the intermediate representation and the TypeScript types users interact with.

Output: MCPServerNode IR type, MCPServerProps interface, MCPServer/MCPStdioServer/MCPHTTPServer component stubs
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-mcp-configuration/18-CONTEXT.md
@.planning/phases/18-mcp-configuration/18-RESEARCH.md
@src/ir/nodes.ts
@src/jsx.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MCPServerNode and MCPConfigDocumentNode to IR</name>
  <files>src/ir/nodes.ts</files>
  <action>
Add MCPServerNode interface with discriminator `kind: 'mcpServer'`:

```typescript
/**
 * MCP Server configuration node
 * Represents a single MCP server definition
 */
export interface MCPServerNode {
  kind: 'mcpServer';
  name: string;                        // Server name (key in mcpServers object)
  type: 'stdio' | 'http' | 'sse';      // Transport type
  // Stdio-specific
  command?: string;                    // Executable command
  args?: string[];                     // Command arguments
  // HTTP/SSE-specific
  url?: string;                        // Remote URL
  headers?: Record<string, string>;    // Request headers
  // Common
  env?: Record<string, string>;        // Environment variables
}
```

Add MCPConfigDocumentNode interface:

```typescript
/**
 * MCP configuration document root node
 * Contains one or more MCP server definitions
 */
export interface MCPConfigDocumentNode {
  kind: 'mcpConfigDocument';
  servers: MCPServerNode[];
}
```

Add MCPServerNode to BlockNode union (it's a standalone element, not really a "block" but needs to be transformable).

Add both types to IRNode union for exhaustive checking.

Do NOT add to assertNever yet - that happens when emitter handles the types.
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors. Grep for 'mcpServer' in nodes.ts should show the new types.</verify>
  <done>MCPServerNode and MCPConfigDocumentNode types exist in IR with all required properties for stdio and http/sse transport types.</done>
</task>

<task type="auto">
  <name>Task 2: Add MCPServer JSX components and props</name>
  <files>src/jsx.ts</files>
  <action>
Add MCPServerProps interface with conditional props based on type:

```typescript
/**
 * Props for the MCPServer component
 * Generic MCP server definition supporting all transport types
 */
export interface MCPServerProps {
  /** Server name (key in mcpServers object) */
  name: string;
  /** Transport type */
  type: 'stdio' | 'http' | 'sse';
  /** Stdio: executable command (required when type="stdio") */
  command?: string;
  /** Stdio: command arguments */
  args?: string[];
  /** HTTP/SSE: remote URL (required when type="http" or type="sse") */
  url?: string;
  /** HTTP/SSE: request headers */
  headers?: Record<string, string>;
  /** Environment variables passed to server process */
  env?: Record<string, string>;
}
```

Add typed convenience interfaces (better TypeScript inference):

```typescript
/**
 * Props for MCPStdioServer convenience component
 * Type-safe stdio server definition
 */
export interface MCPStdioServerProps {
  /** Server name (key in mcpServers object) */
  name: string;
  /** Executable command */
  command: string;
  /** Command arguments */
  args?: string[];
  /** Environment variables */
  env?: Record<string, string>;
}

/**
 * Props for MCPHTTPServer convenience component
 * Type-safe HTTP/SSE server definition
 */
export interface MCPHTTPServerProps {
  /** Server name (key in mcpServers object) */
  name: string;
  /** Remote URL */
  url: string;
  /** Request headers */
  headers?: Record<string, string>;
}
```

Add component stub functions with JSDoc:

```typescript
/**
 * MCPServer component - defines an MCP server in settings.json
 *
 * This is a compile-time component transformed by react-agentic.
 * It's never executed at runtime. Emits to .claude/settings.json mcpServers section.
 *
 * @example Stdio server
 * <MCPServer
 *   name="sqlite"
 *   type="stdio"
 *   command="npx"
 *   args={["-y", "mcp-server-sqlite", "--db-path", "./data/state.db"]}
 *   env={{ DEBUG: "true" }}
 * />
 *
 * @example HTTP server
 * <MCPServer
 *   name="remote-api"
 *   type="http"
 *   url="https://api.example.com/mcp"
 *   headers={{ "Authorization": "Bearer ${API_KEY}" }}
 * />
 */
export function MCPServer(_props: MCPServerProps): null {
  return null;
}

/**
 * MCPStdioServer component - type-safe stdio MCP server definition
 *
 * Convenience wrapper for MCPServer with type="stdio".
 * Provides better TypeScript inference by requiring command prop.
 *
 * @example
 * <MCPStdioServer
 *   name="sqlite"
 *   command="npx"
 *   args={["-y", "mcp-server-sqlite", "--db-path", "./data/state.db"]}
 * />
 */
export function MCPStdioServer(_props: MCPStdioServerProps): null {
  return null;
}

/**
 * MCPHTTPServer component - type-safe HTTP MCP server definition
 *
 * Convenience wrapper for MCPServer with type="http".
 * Provides better TypeScript inference by requiring url prop.
 *
 * @example
 * <MCPHTTPServer
 *   name="remote-api"
 *   url="https://api.example.com/mcp"
 *   headers={{ "Authorization": "Bearer ${API_KEY}" }}
 * />
 */
export function MCPHTTPServer(_props: MCPHTTPServerProps): null {
  return null;
}
```

Add new section comment `// ============================================================================`
`// MCP Server Configuration`
`// ============================================================================`

Place after State Management section (near end of file).
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors. Grep for 'MCPServer' in jsx.ts should show the new components.</verify>
  <done>MCPServerProps, MCPStdioServerProps, MCPHTTPServerProps interfaces and MCPServer, MCPStdioServer, MCPHTTPServer component stubs exist with full JSDoc documentation.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors
2. `grep -n "mcpServer\|MCPServer" src/ir/nodes.ts` shows MCPServerNode and MCPConfigDocumentNode
3. `grep -n "MCPServer" src/jsx.ts` shows all three components and interfaces
4. Both files have appropriate JSDoc documentation
</verification>

<success_criteria>
- MCPServerNode IR type with kind: 'mcpServer' discriminator
- MCPConfigDocumentNode IR type with servers array
- MCPServerProps supports all transport types
- MCPStdioServer and MCPHTTPServer convenience components
- TypeScript compiles without errors
- Full JSDoc documentation with examples
</success_criteria>

<output>
After completion, create `.planning/phases/18-mcp-configuration/18-01-SUMMARY.md`
</output>
