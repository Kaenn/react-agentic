---
phase: 18-mcp-configuration
plan: 02
type: execute
wave: 2
depends_on: [18-01]
files_modified:
  - src/parser/transformer.ts
autonomous: true

must_haves:
  truths:
    - "Transformer recognizes MCPServer, MCPStdioServer, MCPHTTPServer JSX elements"
    - "Validation fails at compile time for invalid prop combinations"
    - "env and args props correctly extract object/array expressions"
    - "process.env.X references resolve at build time"
  artifacts:
    - path: "src/parser/transformer.ts"
      provides: "transformMCPServer method, MCPConfigDocumentNode output"
      contains: "transformMCPServer"
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/ir/nodes.ts"
      via: "Creates MCPServerNode and MCPConfigDocumentNode"
      pattern: "MCPServerNode|MCPConfigDocumentNode"
---

<objective>
Add transformer logic to parse MCPServer JSX elements into IR nodes.

Purpose: Bridge between TSX source and IR representation - validates prop combinations at compile time and extracts structured data from JSX attributes.

Output: transformMCPServer method that produces MCPServerNode, validation for stdio/http prop requirements
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/18-mcp-configuration/18-CONTEXT.md
@.planning/phases/18-mcp-configuration/18-RESEARCH.md
@.planning/phases/18-mcp-configuration/18-01-SUMMARY.md
@src/parser/transformer.ts
@src/ir/nodes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MCPServer transformer with validation</name>
  <files>src/parser/transformer.ts</files>
  <action>
Add a private method `transformMCPServer` to handle MCPServer, MCPStdioServer, and MCPHTTPServer elements.

The method should:

1. Extract required props:
   - `name` (string, required for all)
   - `type` (string, required for MCPServer, derived for convenience components)

2. Validate prop combinations at compile time:
   - If type="stdio": require `command`, disallow `url`/`headers`
   - If type="http" or type="sse": require `url`, disallow `command`/`args`
   - MCPStdioServer: implicitly type="stdio", require command
   - MCPHTTPServer: implicitly type="http", require url

3. Extract optional props:
   - `command` (string)
   - `args` (string[] - extract from array expression)
   - `url` (string)
   - `headers` (Record<string, string> - extract from object expression)
   - `env` (Record<string, string> - extract from object expression)

4. Resolve `process.env.X` at build time:
   - In env/headers values, if value is `process.env.VAR_NAME`, resolve to actual env value
   - If env var is undefined, throw compile error with helpful message

Implementation pattern (following existing transformer patterns):

```typescript
private transformMCPServer(node: JsxElement | JsxSelfClosingElement): MCPServerNode {
  const openingElement = Node.isJsxElement(node)
    ? node.getOpeningElement()
    : node;

  const tagName = openingElement.getTagNameNode().getText();

  // Get name (required)
  const name = getAttributeValue(openingElement, 'name');
  if (!name) {
    throw this.createError('MCPServer requires name prop', openingElement);
  }

  // Determine type based on tag name or explicit prop
  let type: 'stdio' | 'http' | 'sse';
  if (tagName === 'MCPStdioServer') {
    type = 'stdio';
  } else if (tagName === 'MCPHTTPServer') {
    type = 'http';
  } else {
    const typeProp = getAttributeValue(openingElement, 'type') as 'stdio' | 'http' | 'sse';
    if (!typeProp) {
      throw this.createError('MCPServer requires type prop', openingElement);
    }
    type = typeProp;
  }

  // Type-specific validation
  if (type === 'stdio') {
    const command = getAttributeValue(openingElement, 'command');
    if (!command) {
      throw this.createError(`MCPServer type="stdio" requires command prop`, openingElement);
    }
    if (getAttributeValue(openingElement, 'url')) {
      throw this.createError(`MCPServer type="stdio" cannot have url prop`, openingElement);
    }
  } else {
    const url = getAttributeValue(openingElement, 'url');
    if (!url) {
      throw this.createError(`MCPServer type="${type}" requires url prop`, openingElement);
    }
    if (getAttributeValue(openingElement, 'command')) {
      throw this.createError(`MCPServer type="${type}" cannot have command prop`, openingElement);
    }
  }

  // Extract props
  const result: MCPServerNode = {
    kind: 'mcpServer',
    name,
    type,
  };

  // Stdio-specific
  if (type === 'stdio') {
    result.command = getAttributeValue(openingElement, 'command');
    result.args = this.extractArrayAttribute(openingElement, 'args');
  } else {
    result.url = getAttributeValue(openingElement, 'url');
    result.headers = this.extractObjectAttribute(openingElement, 'headers');
  }

  // Common: env
  result.env = this.extractObjectAttribute(openingElement, 'env');

  return result;
}
```

Add helper methods if they don't exist:

```typescript
/**
 * Extract array attribute value (e.g., args={["a", "b"]})
 */
private extractArrayAttribute(
  openingElement: JsxOpeningElement | JsxSelfClosingElement,
  name: string
): string[] | undefined {
  const attr = openingElement.getAttribute(name);
  if (!attr || !Node.isJsxAttribute(attr)) return undefined;

  const initializer = attr.getInitializer();
  if (!initializer || !Node.isJsxExpression(initializer)) return undefined;

  const expr = initializer.getExpression();
  if (!expr || !Node.isArrayLiteralExpression(expr)) return undefined;

  return expr.getElements().map(el => {
    if (Node.isStringLiteral(el)) {
      return el.getLiteralText();
    }
    // Handle template literals or other expressions
    return el.getText();
  });
}

/**
 * Extract object attribute value (e.g., env={{ KEY: "value" }})
 * Resolves process.env.X references at build time
 */
private extractObjectAttribute(
  openingElement: JsxOpeningElement | JsxSelfClosingElement,
  name: string
): Record<string, string> | undefined {
  const attr = openingElement.getAttribute(name);
  if (!attr || !Node.isJsxAttribute(attr)) return undefined;

  const initializer = attr.getInitializer();
  if (!initializer || !Node.isJsxExpression(initializer)) return undefined;

  const expr = initializer.getExpression();
  if (!expr || !Node.isObjectLiteralExpression(expr)) return undefined;

  const result: Record<string, string> = {};

  for (const prop of expr.getProperties()) {
    if (!Node.isPropertyAssignment(prop)) continue;

    const key = prop.getName();
    const valueExpr = prop.getInitializer();
    if (!valueExpr) continue;

    // Handle process.env.X
    if (Node.isPropertyAccessExpression(valueExpr)) {
      const text = valueExpr.getText();
      if (text.startsWith('process.env.')) {
        const envVar = text.replace('process.env.', '');
        const envValue = process.env[envVar];
        if (envValue === undefined) {
          throw this.createError(
            `Environment variable '${envVar}' is not defined`,
            openingElement
          );
        }
        result[key] = envValue;
        continue;
      }
    }

    if (Node.isStringLiteral(valueExpr)) {
      result[key] = valueExpr.getLiteralText();
    } else {
      // Preserve expressions as-is (e.g., template literals)
      result[key] = valueExpr.getText().replace(/^["']|["']$/g, '');
    }
  }

  return Object.keys(result).length > 0 ? result : undefined;
}
```

Update the main transform method to handle MCP components:

```typescript
// In transform() or the appropriate entry point
if (tagName === 'MCPServer' || tagName === 'MCPStdioServer' || tagName === 'MCPHTTPServer') {
  return this.transformMCPServer(node);
}
```

Import MCPServerNode and MCPConfigDocumentNode types from ir/nodes.ts.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Write a test file with valid MCPServer and run transformation manually
3. Write a test file with invalid props (stdio with url) and verify compile error
  </verify>
  <done>
Transformer recognizes MCPServer/MCPStdioServer/MCPHTTPServer elements, validates prop combinations at compile time, extracts arrays and objects, and resolves process.env references.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add MCPConfigDocumentNode transformation</name>
  <files>src/parser/transformer.ts</files>
  <action>
The MCP configuration files may contain multiple MCPServer elements at the root level. Add logic to collect multiple servers into an MCPConfigDocumentNode.

Pattern options:

Option A: Wrapper component `<MCPConfig>` containing servers
Option B: Multiple root elements collected by build command

Based on the existing patterns (Command, Agent, Skill all have single-root documents), use Option A with a wrapper:

Add to jsx.ts (if not done in Task 1):
```typescript
export interface MCPConfigProps {
  children?: ReactNode;
}

export function MCPConfig(_props: MCPConfigProps): null {
  return null;
}
```

Add transformation for MCPConfig:

```typescript
private transformMCPConfig(node: JsxElement): MCPConfigDocumentNode {
  const servers: MCPServerNode[] = [];

  // Process children - expect MCPServer elements
  if (Node.isJsxElement(node)) {
    for (const child of node.getJsxChildren()) {
      if (Node.isJsxElement(child) || Node.isJsxSelfClosingElement(child)) {
        const tagName = (Node.isJsxElement(child)
          ? child.getOpeningElement()
          : child
        ).getTagNameNode().getText();

        if (tagName === 'MCPServer' || tagName === 'MCPStdioServer' || tagName === 'MCPHTTPServer') {
          servers.push(this.transformMCPServer(child));
        }
      }
    }
  }

  if (servers.length === 0) {
    throw this.createError('MCPConfig must contain at least one MCPServer', node);
  }

  return {
    kind: 'mcpConfigDocument',
    servers,
  };
}
```

Update the main entry point to detect MCPConfig:

```typescript
// In transform() - detect document type based on root element
if (tagName === 'MCPConfig') {
  return this.transformMCPConfig(node);
}
```

Also ensure the transform function return type includes MCPConfigDocumentNode.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Test with a file containing `<MCPConfig><MCPStdioServer ... /></MCPConfig>`
3. Verify the returned document has kind: 'mcpConfigDocument' with servers array
  </verify>
  <done>
MCPConfig wrapper component transforms to MCPConfigDocumentNode containing array of MCPServerNode children.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes without errors
2. Create test file with valid MCPConfig containing multiple servers - transforms correctly
3. Create test file with invalid prop combinations - throws at compile time
4. process.env.X values resolve (test with DEBUG=true in env)
</verification>

<success_criteria>
- MCPServer/MCPStdioServer/MCPHTTPServer elements transform to MCPServerNode
- MCPConfig wraps multiple servers into MCPConfigDocumentNode
- Compile-time validation for prop combinations (stdio vs http)
- Arrays (args) and objects (env, headers) extract correctly
- process.env.X resolves at build time with error on undefined
</success_criteria>

<output>
After completion, create `.planning/phases/18-mcp-configuration/18-02-SUMMARY.md`
</output>
