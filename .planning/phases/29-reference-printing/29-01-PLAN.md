---
phase: 29-reference-printing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/runtime-var.ts
  - src/components/runtime-fn.ts
  - src/components/Ref.ts
  - src/components/index.ts
  - src/parser/transformers/runtime-inline.ts
  - src/parser/transformers/runtime-component.ts
  - src/ir/runtime-nodes.ts
  - src/jsx.ts
  - tests/components/ref.test.ts
  - tests/parser/runtime-inline.test.ts
autonomous: true

must_haves:
  truths:
    - "RuntimeVar interpolation {ctx.data.status} emits $CTX.data.status in markdown"
    - "RuntimeVar interpolation {ctx} emits $CTX in markdown"
    - "RuntimeVar array access {ctx.items[0]} emits $CTX.items[0] in markdown"
    - "RuntimeFn has .name property that returns function identifier"
    - "RuntimeFn has .call property that returns function call syntax with parens"
    - "RuntimeFn has .input property that returns parameter names"
    - "RuntimeFn has .output property that returns output type schema"
    - "<Ref value={ctx} /> renders $CTX in markdown output"
    - "<Ref value={myFn} /> renders function name in markdown output"
    - "<Ref value={myFn} call /> renders function call syntax with parens"
  artifacts:
    - path: "src/components/Ref.ts"
      provides: "Ref component for explicit reference printing"
      exports: ["Ref", "RefProps"]
    - path: "tests/components/ref.test.ts"
      provides: "Tests for Ref component and reference printing"
      min_lines: 80
  key_links:
    - from: "src/components/Ref.ts"
      to: "src/components/runtime-var.ts"
      via: "imports RuntimeVar type"
      pattern: "import.*RuntimeVar.*from"
    - from: "src/jsx.ts"
      to: "src/components/Ref.ts"
      via: "re-exports Ref component"
      pattern: "export.*Ref"
---

<objective>
Enable composites to print variable and function references in markdown output. RuntimeVar interpolation emits shell variable syntax ($CTX.data.status). RuntimeFn provides name, call, input, and output properties. Ref component renders references in JSX context.

Purpose: Users can reference runtime values directly in markdown templates without manual string construction, and Claude can parse the output format to understand runtime values.

Output:
- RuntimeVar interpolation changed from jq expressions to shell variable syntax
- RuntimeFn enhanced with .name, .call, .input, .output properties
- New `<Ref>` component for explicit reference rendering
- Tests validating all reference printing behaviors
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-reference-printing/29-CONTEXT.md
@src/components/runtime-var.ts
@src/components/runtime-fn.ts
@src/components/index.ts
@src/parser/transformers/runtime-inline.ts
@src/parser/transformers/runtime-types.ts
@src/jsx.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update RuntimeVar interpolation to emit shell variable syntax</name>
  <files>src/parser/transformers/runtime-inline.ts</files>
  <action>
Modify the `transformPropertyAccess` and `transformTemplateLiteral` functions to emit direct shell variable syntax instead of jq expressions:

1. **Change output format in `transformPropertyAccess`**:
   - Current: `$(echo "$CTX" | jq -r '.user.name')`
   - New: `$CTX.user.name`
   - For root reference (no path): `$CTX`
   - Array access should use bracket notation: `$CTX.items[0]`

2. **Update the jq expression generation**:
   - Replace the jq subshell with direct variable reference
   - Format: `$` + varName + `.` + path.join('.')
   - For empty path: just `$` + varName

3. **Handle array index access** (future-proofing):
   - If a path segment is numeric, emit bracket notation: `.items[0]` not `.items.0`
   - Pattern check: `/^\d+$/` for numeric segments

Key code changes in `transformPropertyAccess`:
```typescript
if (runtimeVar) {
  const jqPath = path.slice(1);
  // New format: direct shell variable syntax
  const pathStr = jqPath.length === 0
    ? ''
    : '.' + jqPath.map(p => /^\d+$/.test(p) ? `[${p}]` : p).join('.');
  const value = `$${runtimeVar.varName}${pathStr}`;
  return { kind: 'text', value };
}
```

Apply the same change to:
- `transformTemplateLiteral` (for template expressions with RuntimeVars)
- Direct identifier references in `transformRuntimeToInline`
  </action>
  <verify>
Run existing tests to ensure no regressions. The output format will change, so snapshot tests may need updating:
```bash
npm test -- --run tests/parser/
```
  </verify>
  <done>
RuntimeVar interpolation emits `$CTX.data.status` format instead of jq expressions. All path access uses dot notation with bracket notation for array indices.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add reference properties to RuntimeFn</name>
  <files>src/components/runtime-fn.ts</files>
  <action>
Enhance `RuntimeFnComponent` interface and `runtimeFn` wrapper to provide reference properties:

1. **Add new properties to RuntimeFnComponent interface**:
   ```typescript
   export interface RuntimeFnComponent<TArgs extends object, TReturn> {
     /** JSX component for invoking the function */
     Call: RuntimeCallComponent<TArgs, TReturn>;
     /** Original function name for extraction */
     readonly fnName: string;
     /** Original function reference for extraction */
     readonly fn: RuntimeFunction<TArgs, TReturn>;
     /** Marker for type guard */
     readonly __isRuntimeFn: true;

     // New reference properties:
     /** Function identifier name (e.g., "initProject") */
     readonly name: string;
     /** Function call syntax with parens (e.g., "initProject()") */
     readonly call: string;
     /** Comma-separated parameter names from function signature */
     readonly input: string;
     /** Output type as JSON schema string */
     readonly output: string;
   }
   ```

2. **Extract parameter names from function**:
   - Use function.toString() to get source
   - Parse parameter names with regex: `/\(([^)]*)\)/`
   - Extract names, strip types: `args: TArgs` -> `args`
   - Return comma-separated: `"projectPath, options"`
   - For untyped/complex functions: return empty string ""

3. **Generate output type schema**:
   - Since we can't reflect on TypeScript types at runtime, this requires compile-time extraction
   - For now, return `"unknown"` as placeholder
   - Document that full type extraction requires future enhancement

4. **Update runtimeFn function** to populate these properties:
   ```typescript
   const wrapper = {
     Call,
     fnName,
     fn,
     __isRuntimeFn: true as const,
     [RUNTIME_FN_MARKER]: true,
     // New properties:
     name: fnName,
     call: `${fnName}()`,
     input: extractParameterNames(fn),
     output: 'unknown', // Type extraction not yet implemented
   };
   ```

5. **Add helper function** `extractParameterNames`:
   ```typescript
   function extractParameterNames(fn: Function): string {
     const fnStr = fn.toString();
     const match = fnStr.match(/\(([^)]*)\)/);
     if (!match || !match[1].trim()) return '';

     // Extract parameter names, stripping types
     const params = match[1].split(',').map(p => {
       const name = p.trim().split(/[:\s=]/)[0];
       return name.trim();
     }).filter(Boolean);

     return params.join(', ');
   }
   ```
  </action>
  <verify>
```bash
npx tsc --noEmit
npm test -- --run tests/components/
```
  </verify>
  <done>
RuntimeFn wrapper provides `.name`, `.call`, `.input`, and `.output` properties. Parameter extraction works for standard async function signatures.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Ref component</name>
  <files>src/components/Ref.ts</files>
  <action>
Create new component file `src/components/Ref.ts` for explicit reference rendering:

1. **Define RefProps interface**:
   ```typescript
   import type { RuntimeVar, RuntimeVarProxy } from './runtime-var.js';
   import type { RuntimeFnComponent } from './runtime-fn.js';

   /**
    * Props for the Ref component
    *
    * @param value - RuntimeVar or RuntimeFn to render as reference
    * @param call - For RuntimeFn, render with call syntax (parens)
    */
   export interface RefProps {
     /** RuntimeVar or RuntimeFn to render */
     value: RuntimeVar<unknown> | RuntimeVarProxy<unknown> | RuntimeFnComponent<any, any>;
     /** For RuntimeFn, render with call syntax (default: false) */
     call?: boolean;
   }
   ```

2. **Create Ref component stub**:
   ```typescript
   /**
    * Ref component for explicit variable/function reference rendering
    *
    * Renders RuntimeVar as shell variable syntax ($VAR.path)
    * Renders RuntimeFn as function name or call syntax
    *
    * @example
    * // RuntimeVar reference
    * <Ref value={ctx.status} />  // Emits: $CTX.status
    *
    * // RuntimeFn name
    * <Ref value={myFn} />  // Emits: myFn
    *
    * // RuntimeFn call syntax
    * <Ref value={myFn} call />  // Emits: myFn()
    */
   export function Ref(_props: RefProps): null {
     // Compile-time only - transformed during build
     return null;
   }
   ```

3. **Add Ref marker** for transformer detection:
   ```typescript
   export const REF_MARKER = Symbol.for('react-agentic:ref');
   ```
  </action>
  <verify>
```bash
npx tsc --noEmit
```
  </verify>
  <done>
Ref component created with RefProps interface. Component is compile-time only stub with appropriate JSDoc documentation.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add Ref component transformer</name>
  <files>src/parser/transformers/runtime-component.ts</files>
  <action>
Add transformation logic for the Ref component. This may require creating a new transformer or adding to an existing one.

1. **Check if runtime-component.ts exists**:
   - If it exists, add Ref handling there
   - If not, create it or add to runtime-inline.ts

2. **Add Ref transformation logic**:
   ```typescript
   /**
    * Transform Ref component to inline text node
    *
    * Detects value prop type and renders appropriate reference syntax
    */
   export function transformRefComponent(
     node: JsxSelfClosingElement,
     ctx: RuntimeTransformContext
   ): InlineNode {
     const valueAttr = node.getAttribute('value');
     const callAttr = node.getAttribute('call');

     if (!valueAttr) {
       throw ctx.createError('<Ref> requires value prop', node);
     }

     // Get the expression from value prop
     const expr = getAttributeExpression(valueAttr);
     if (!expr) {
       throw ctx.createError('<Ref> value must be an expression', node);
     }

     // Check if it's a RuntimeVar reference
     const runtimeVarRef = parseRuntimeVarRef(expr, ctx);
     if (runtimeVarRef) {
       // Emit shell variable syntax
       const pathStr = runtimeVarRef.path.length === 0
         ? ''
         : '.' + runtimeVarRef.path.join('.');
       return { kind: 'text', value: `$${runtimeVarRef.varName}${pathStr}` };
     }

     // Check if it's a RuntimeFn reference
     if (Node.isIdentifier(expr)) {
       const fnInfo = ctx.runtimeFunctions.get(expr.getText());
       if (fnInfo) {
         const useCallSyntax = callAttr !== undefined;
         const value = useCallSyntax ? `${fnInfo.fnName}()` : fnInfo.fnName;
         return { kind: 'text', value };
       }
     }

     // Check for RuntimeFn property access (myFn.input, myFn.output)
     if (Node.isPropertyAccessExpression(expr)) {
       const objExpr = expr.getExpression();
       const propName = expr.getName();

       if (Node.isIdentifier(objExpr)) {
         const fnInfo = ctx.runtimeFunctions.get(objExpr.getText());
         if (fnInfo) {
           if (propName === 'input') {
             // Would need runtime function parameter extraction
             return { kind: 'text', value: '' };
           }
           if (propName === 'output') {
             return { kind: 'text', value: 'unknown' };
           }
           if (propName === 'name') {
             return { kind: 'text', value: fnInfo.fnName };
           }
           if (propName === 'call') {
             return { kind: 'text', value: `${fnInfo.fnName}()` };
           }
         }
       }
     }

     throw ctx.createError(
       '<Ref> value must be a RuntimeVar or RuntimeFn reference',
       node
     );
   }
   ```

3. **Register Ref in component dispatch** (runtime-dispatch.ts or equivalent):
   - Add 'Ref' to the switch case for component transformation
  </action>
  <verify>
```bash
npx tsc --noEmit
# Create a minimal test TSX file with Ref component, compile it, verify output
npm test -- --run tests/components/ref.test.ts
```
Verify that Ref component transformer:
1. Compiles without TypeScript errors
2. Is registered in component dispatch
3. Produces expected markdown output (tested in Task 6)
  </verify>
  <done>
Ref component transformation implemented. Handles RuntimeVar and RuntimeFn references with appropriate output format.
  </done>
</task>

<task type="auto">
  <name>Task 5: Export Ref from component index and jsx.ts</name>
  <files>src/components/index.ts, src/jsx.ts</files>
  <action>
1. **Update src/components/index.ts**:
   Add exports for Ref component:
   ```typescript
   export { Ref, REF_MARKER, type RefProps } from './Ref.js';
   ```

2. **Update src/jsx.ts**:
   Add Ref to the re-exports from components:
   ```typescript
   // In the existing export block from './components/index.js'
   Ref,
   REF_MARKER,
   type RefProps,
   ```

3. **Update src/index.ts** (if needed):
   Verify Ref is accessible from package root via existing re-exports.
  </action>
  <verify>
```bash
npx tsc --noEmit
# Verify import works:
node -e "import('./dist/jsx.js').then(m => console.log('Ref:', typeof m.Ref))"
```
  </verify>
  <done>
Ref component exported from react-agentic package. Users can import `{ Ref }` from the package.
  </done>
</task>

<task type="auto">
  <name>Task 6: Add tests for reference printing</name>
  <files>tests/components/ref.test.ts, tests/parser/runtime-inline.test.ts</files>
  <action>
1. **Create tests/components/ref.test.ts**:
   ```typescript
   import { describe, expect, it } from 'vitest';
   import { Ref, RefProps } from '../../src/jsx.js';

   describe('Ref component', () => {
     describe('type safety', () => {
       it('accepts RuntimeVar as value', () => {
         // Type check - this should compile
         const props: RefProps = {
           value: {} as any, // RuntimeVar type
         };
         expect(props.value).toBeDefined();
       });

       it('accepts call prop for RuntimeFn', () => {
         const props: RefProps = {
           value: {} as any,
           call: true,
         };
         expect(props.call).toBe(true);
       });
     });
   });
   ```

2. **Create/update tests/parser/runtime-inline.test.ts** with reference output tests:
   ```typescript
   describe('RuntimeVar interpolation output format', () => {
     it('emits shell variable syntax for simple reference', () => {
       // Test that {ctx} emits $CTX
     });

     it('emits dot notation for property access', () => {
       // Test that {ctx.data.status} emits $CTX.data.status
     });

     it('emits bracket notation for array access', () => {
       // Test that {ctx.items[0]} emits $CTX.items[0]
     });
   });
   ```

3. **Add snapshot tests** for Ref component output if the test infrastructure supports it.

4. **Update existing snapshot tests** that may have changed due to the jq->shell syntax change.
  </action>
  <verify>
```bash
npm test -- --run tests/components/ref.test.ts
npm test -- --run tests/parser/runtime-inline.test.ts
npm test  # Run all tests to catch any snapshot updates needed
```
  </verify>
  <done>
Tests cover RuntimeVar interpolation output format, Ref component type safety, and integration with the parser. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 7: Update snapshots and verify all tests pass</name>
  <files>tests/**/__snapshots__/*</files>
  <action>
1. **Run full test suite** to identify snapshot mismatches:
   ```bash
   npm test
   ```

2. **Review changed snapshots**:
   - The jq expression format changes to shell variable syntax
   - Expected change: `$(echo "$CTX" | jq -r '.path')` -> `$CTX.path`
   - Verify changes are intentional and correct

3. **Update snapshots**:
   ```bash
   npm test -- -u
   ```

4. **Verify test count** remains at 155+ tests passing.

5. **Run build** to ensure everything compiles:
   ```bash
   npm run build
   ```
  </action>
  <verify>
```bash
npm test
npm run build
```
All tests pass, build succeeds.
  </verify>
  <done>
All snapshots updated to reflect new shell variable syntax. Full test suite (155+ tests) passes. Build succeeds without errors.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **RuntimeVar interpolation format verified:**
   ```bash
   grep -r "\\$CTX\." tests/  # Should find new format in tests
   grep -r "jq -r" tests/     # Should find fewer/no jq expressions in inline tests
   ```

2. **RuntimeFn properties exist:**
   ```bash
   grep "readonly name:" src/components/runtime-fn.ts
   grep "readonly call:" src/components/runtime-fn.ts
   grep "readonly input:" src/components/runtime-fn.ts
   grep "readonly output:" src/components/runtime-fn.ts
   ```

3. **Ref component exported:**
   ```bash
   grep "Ref" src/jsx.ts
   grep "RefProps" src/jsx.ts
   ```

4. **Tests pass:**
   ```bash
   npm test
   ```

5. **Build succeeds:**
   ```bash
   npm run build
   ```
</verification>

<success_criteria>
- [ ] RuntimeVar interpolation `{ctx.data.status}` emits `$CTX.data.status` in markdown
- [ ] RuntimeVar interpolation `{ctx}` emits `$CTX` in markdown
- [ ] Array access `{ctx.items[0]}` emits `$CTX.items[0]` format
- [ ] RuntimeFn has `.name`, `.call`, `.input`, `.output` properties
- [ ] `<Ref value={ctx} />` component exists and transforms correctly
- [ ] `<Ref value={myFn} call />` renders function call syntax
- [ ] Ref component exported from package root
- [ ] Tests cover all reference printing scenarios
- [ ] All 155+ existing tests pass (with updated snapshots)
- [ ] Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/29-reference-printing/29-01-SUMMARY.md`
</output>
