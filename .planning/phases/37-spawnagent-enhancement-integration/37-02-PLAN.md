---
phase: 37-spawnagent-enhancement-integration
plan: 02
type: execute
wave: 2
depends_on: ["37-01"]
files_modified:
  - tests/composites/v31-integration.test.ts
autonomous: true

must_haves:
  truths:
    - "SpawnAgent with readAgentFile emits self-reading instruction"
    - "readAgentFile without agent prop throws compile error"
    - "Command with MetaPrompt + SpawnAgent compiles correctly"
    - "Agent with all contract components compiles correctly"
  artifacts:
    - path: "tests/composites/v31-integration.test.ts"
      provides: "v3.1 integration test suite"
      contains: "v3.1 Integration"
      min_lines: 100
  key_links:
    - from: "tests/composites/v31-integration.test.ts"
      to: "readAgentFile"
      via: "snapshot test"
      pattern: "readAgentFile.*toMatchSnapshot"
---

<objective>
Create integration tests validating v3.1 meta-prompting components work together end-to-end.

Purpose: Validate that all Phase 34-37 components integrate correctly: agent contracts, command orchestration, meta-prompting context composition, and SpawnAgent self-reading.

Output: Comprehensive test file with snapshot-based integration tests covering critical component pairs and full end-to-end scenarios.
</objective>

<execution_context>
@/Users/glenninizan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/glenninizan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-spawnagent-enhancement-integration/37-CONTEXT.md
@.planning/phases/37-spawnagent-enhancement-integration/37-RESEARCH.md
@.planning/phases/37-spawnagent-enhancement-integration/37-01-SUMMARY.md

Source files:
@tests/composites/spawn-agent.test.ts
@tests/composites/control-flow.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create v31-integration.test.ts with SpawnAgent self-reading tests</name>
  <files>
    tests/composites/v31-integration.test.ts
  </files>
  <action>
Create tests/composites/v31-integration.test.ts with the following content:

```typescript
/**
 * v3.1 Integration Tests
 *
 * Validates that all v3.1 meta-prompting components work together:
 * - Agent contracts (Role, UpstreamInput, DownstreamConsumer, Methodology, StructuredReturns)
 * - Command orchestration (OnStatus, OnStatusDefault)
 * - Meta-prompting (MetaPrompt, GatherContext, ComposeContext, ReadFile)
 * - SpawnAgent enhancement (readAgentFile)
 */

import { describe, it, expect } from 'vitest';
import { Project } from 'ts-morph';
import { transformCommandTsx, transformAgentTsx } from '../../src/parser/index.js';
import { RuntimeMarkdownEmitter } from '../../src/emitter/index.js';

describe('v3.1 Integration Tests', () => {
  describe('SpawnAgent Self-Reading', () => {
    it('should emit self-reading instruction when readAgentFile=true', () => {
      const project = new Project({ useInMemoryFileSystem: true });

      const source = `
        import { Command, SpawnAgent } from 'react-agentic';

        export default function TestCommand() {
          return (
            <Command name="test" description="Test command">
              <SpawnAgent
                agent="gsd-phase-researcher"
                model="sonnet"
                description="Research phase"
                readAgentFile
                prompt="Research context here"
              />
            </Command>
          );
        }
      `;

      const sourceFile = project.createSourceFile('test.tsx', source);
      const ir = transformCommandTsx(sourceFile);

      // Emit with default config
      const emitter = new RuntimeMarkdownEmitter(ir);
      const markdown = emitter.emit();

      // Verify self-reading instruction is present
      expect(markdown).toContain('First, read');
      expect(markdown).toContain('gsd-phase-researcher.md');
      expect(markdown).toContain('for your role and instructions');

      // Snapshot full output
      expect(markdown).toMatchSnapshot('spawnagent-readAgentFile-basic');
    });

    it('should emit self-reading instruction with custom agentsDir config', () => {
      const project = new Project({ useInMemoryFileSystem: true });

      const source = `
        import { Command, SpawnAgent } from 'react-agentic';

        export default function TestCommand() {
          return (
            <Command name="test" description="Test command">
              <SpawnAgent
                agent="custom-agent"
                model="sonnet"
                description="Custom agent task"
                readAgentFile={true}
                prompt="Custom prompt"
              />
            </Command>
          );
        }
      `;

      const sourceFile = project.createSourceFile('test.tsx', source);
      const ir = transformCommandTsx(sourceFile);

      // Emit with custom agentsDir
      const emitter = new RuntimeMarkdownEmitter(ir, {
        agentsDir: '/custom/agents/path/',
      });
      const markdown = emitter.emit();

      // Verify custom path is used
      expect(markdown).toContain('First, read /custom/agents/path/custom-agent.md');
      expect(markdown).toMatchSnapshot('spawnagent-readAgentFile-custom-path');
    });

    it('should NOT emit self-reading instruction when readAgentFile={false}', () => {
      const project = new Project({ useInMemoryFileSystem: true });

      const source = `
        import { Command, SpawnAgent } from 'react-agentic';

        export default function TestCommand() {
          return (
            <Command name="test" description="Test command">
              <SpawnAgent
                agent="normal-agent"
                model="sonnet"
                description="Normal task"
                readAgentFile={false}
                prompt="Normal prompt"
              />
            </Command>
          );
        }
      `;

      const sourceFile = project.createSourceFile('test.tsx', source);
      const ir = transformCommandTsx(sourceFile);

      const emitter = new RuntimeMarkdownEmitter(ir);
      const markdown = emitter.emit();

      // Verify no self-reading instruction
      expect(markdown).not.toContain('First, read');
      expect(markdown).not.toContain('for your role and instructions');
    });

    it('should error when readAgentFile=true without agent prop', () => {
      const project = new Project({ useInMemoryFileSystem: true });

      // This is intentionally invalid - readAgentFile without agent
      // Note: In practice, agent is required, but we test the validation message
      const source = `
        import { Command, SpawnAgent } from 'react-agentic';

        export default function TestCommand() {
          return (
            <Command name="test" description="Test command">
              <SpawnAgent
                model="sonnet"
                description="Missing agent"
                readAgentFile
                prompt="Some prompt"
              />
            </Command>
          );
        }
      `;

      const sourceFile = project.createSourceFile('test.tsx', source);

      // Should throw because agent prop is missing
      expect(() => transformCommandTsx(sourceFile)).toThrow(/agent/i);
    });
  });

  describe('Agent Contract Components', () => {
    it('should compile agent with all contract components', () => {
      const project = new Project({ useInMemoryFileSystem: true });

      const source = `
        import { Agent, Role, UpstreamInput, DownstreamConsumer, Methodology, StructuredReturns, StatusReturn } from 'react-agentic';

        interface ResearchInput {
          topic: string;
          depth: 'shallow' | 'deep';
        }

        interface ResearchOutput {
          status: 'SUCCESS' | 'NOT_FOUND' | 'ERROR';
          findings?: string;
          error?: string;
        }

        export default function Researcher() {
          return (
            <Agent<ResearchInput, ResearchOutput>
              name="researcher"
              description="Research agent"
              tools="Read WebSearch"
            >
              <Role>
                You are a research specialist who gathers information on topics.
              </Role>

              <UpstreamInput>
                - topic: The subject to research
                - depth: Level of detail required
              </UpstreamInput>

              <DownstreamConsumer>
                - report-writer: Uses findings to generate reports
              </DownstreamConsumer>

              <Methodology>
                1. Understand the topic
                2. Search for relevant sources
                3. Synthesize findings
              </Methodology>

              <StructuredReturns>
                <StatusReturn status="SUCCESS" description="Research completed">
                  Return findings in markdown format.
                </StatusReturn>
                <StatusReturn status="NOT_FOUND" description="No relevant information found">
                  Explain what was searched and why nothing was found.
                </StatusReturn>
                <StatusReturn status="ERROR" description="Research failed">
                  Describe the error encountered.
                </StatusReturn>
              </StructuredReturns>
            </Agent>
          );
        }
      `;

      const sourceFile = project.createSourceFile('researcher.tsx', source);
      const ir = transformAgentTsx(sourceFile);

      const emitter = new RuntimeMarkdownEmitter(ir);
      const markdown = emitter.emit();

      // Verify all contract sections are present
      expect(markdown).toContain('<role>');
      expect(markdown).toContain('research specialist');
      expect(markdown).toContain('<upstream_input>');
      expect(markdown).toContain('<downstream_consumer>');
      expect(markdown).toContain('<methodology>');
      expect(markdown).toContain('<structured_returns>');

      // Snapshot full output
      expect(markdown).toMatchSnapshot('agent-full-contract');
    });
  });

  describe('MetaPrompt + SpawnAgent Integration', () => {
    it('should compile command with MetaPrompt context composition', () => {
      const project = new Project({ useInMemoryFileSystem: true });

      const source = `
        import { Command, SpawnAgent } from 'react-agentic';
        import { MetaPrompt, GatherContext, ComposeContext, Preamble, InlineField } from 'react-agentic/composites';
        import { ReadFile, XmlBlock } from 'react-agentic';

        export default function PlanPhase() {
          return (
            <Command name="plan-phase" description="Plan a project phase">
              <MetaPrompt>
                <GatherContext>
                  <ReadFile path=".planning/PROJECT.md" as="PROJECT" />
                  <ReadFile path=".planning/STATE.md" as="STATE" optional />
                </GatherContext>

                <ComposeContext>
                  <Preamble>
                    You are planning phase 37 of the project.
                  </Preamble>

                  <InlineField name="Phase Number" value={37} />

                  <XmlBlock name="project">
                    {'$PROJECT'}
                  </XmlBlock>

                  <XmlBlock name="state">
                    {'$STATE'}
                  </XmlBlock>
                </ComposeContext>
              </MetaPrompt>

              <SpawnAgent
                agent="gsd-planner"
                model="opus"
                description="Create phase plan"
                readAgentFile
                prompt="Plan the phase using the provided context."
              />
            </Command>
          );
        }
      `;

      const sourceFile = project.createSourceFile('plan-phase.tsx', source);
      const ir = transformCommandTsx(sourceFile);

      const emitter = new RuntimeMarkdownEmitter(ir);
      const markdown = emitter.emit();

      // Verify ReadFile instructions present
      expect(markdown).toContain('PROJECT=$(cat');
      expect(markdown).toContain('STATE=$(cat');
      expect(markdown).toContain('2>/dev/null'); // Optional file suppresses errors

      // Verify XML blocks present
      expect(markdown).toContain('<project>');
      expect(markdown).toContain('<state>');

      // Verify SpawnAgent self-reading
      expect(markdown).toContain('First, read');
      expect(markdown).toContain('gsd-planner.md');

      // Snapshot full output
      expect(markdown).toMatchSnapshot('metaprompt-spawnagent-integration');
    });
  });

  describe('OnStatus with Agent Returns', () => {
    it('should compile command with OnStatus and OnStatusDefault', () => {
      const project = new Project({ useInMemoryFileSystem: true });

      const source = `
        import { Command, SpawnAgent, useOutput, OnStatus, OnStatusDefault, Markdown } from 'react-agentic';

        interface TaskOutput {
          status: 'SUCCESS' | 'BLOCKED' | 'ERROR';
          result?: string;
          blockedBy?: string;
          error?: string;
        }

        export default function TaskRunner() {
          const taskResult = useOutput<TaskOutput>('task-agent');

          return (
            <Command name="run-task" description="Run a task with status handling">
              <SpawnAgent
                agent="task-agent"
                model="sonnet"
                description="Execute task"
                prompt="Execute the assigned task."
              />

              <OnStatus output={taskResult} status="SUCCESS">
                <Markdown>
                  Task completed successfully!
                  Result: {taskResult.field('result')}
                </Markdown>
              </OnStatus>

              <OnStatus output={taskResult} status="BLOCKED">
                <Markdown>
                  Task is blocked by: {taskResult.field('blockedBy')}
                </Markdown>
              </OnStatus>

              <OnStatusDefault output={taskResult}>
                <Markdown>
                  Unexpected status. Check error: {taskResult.field('error')}
                </Markdown>
              </OnStatusDefault>
            </Command>
          );
        }
      `;

      const sourceFile = project.createSourceFile('task-runner.tsx', source);
      const ir = transformCommandTsx(sourceFile);

      const emitter = new RuntimeMarkdownEmitter(ir);
      const markdown = emitter.emit();

      // Verify OnStatus sections
      expect(markdown).toContain('On SUCCESS');
      expect(markdown).toContain('On BLOCKED');
      expect(markdown).toContain('On any other status');

      // Snapshot full output
      expect(markdown).toMatchSnapshot('onstatus-handling');
    });
  });

  describe('Full End-to-End Scenario', () => {
    it('should compile comprehensive command using all v3.1 components', () => {
      const project = new Project({ useInMemoryFileSystem: true });

      const source = `
        import { Command, SpawnAgent, useOutput, OnStatus, OnStatusDefault, Markdown, XmlBlock, If, Else } from 'react-agentic';
        import { MetaPrompt, GatherContext, ComposeContext, Preamble } from 'react-agentic/composites';
        import { ReadFile } from 'react-agentic';

        interface PlanOutput {
          status: 'SUCCESS' | 'BLOCKED' | 'ERROR';
          plan?: string;
          blockedBy?: string;
        }

        export default function ExecutePhase() {
          const planResult = useOutput<PlanOutput>('planner');

          return (
            <Command name="execute-phase" description="Full v3.1 demo">
              <MetaPrompt>
                <GatherContext>
                  <ReadFile path=".planning/PROJECT.md" as="PROJECT" />
                  <ReadFile path=".planning/ROADMAP.md" as="ROADMAP" />
                  <ReadFile path=".planning/CONTEXT.md" as="CONTEXT" optional />
                </GatherContext>

                <ComposeContext>
                  <Preamble>
                    Planning context for phase execution.
                  </Preamble>

                  <XmlBlock name="project_context">
                    {'$PROJECT'}
                  </XmlBlock>

                  <XmlBlock name="roadmap">
                    {'$ROADMAP'}
                  </XmlBlock>
                </ComposeContext>
              </MetaPrompt>

              <SpawnAgent
                agent="gsd-planner"
                model="opus"
                description="Create execution plan"
                readAgentFile
                prompt="Create plan from context"
              />

              <OnStatus output={planResult} status="SUCCESS">
                <Markdown>Plan created successfully!</Markdown>
                <XmlBlock name="plan">
                  {planResult.field('plan')}
                </XmlBlock>
              </OnStatus>

              <OnStatus output={planResult} status="BLOCKED">
                <Markdown>Blocked: {planResult.field('blockedBy')}</Markdown>
              </OnStatus>

              <OnStatusDefault output={planResult}>
                <Markdown>Unexpected result from planner.</Markdown>
              </OnStatusDefault>
            </Command>
          );
        }
      `;

      const sourceFile = project.createSourceFile('execute-phase.tsx', source);
      const ir = transformCommandTsx(sourceFile);

      const emitter = new RuntimeMarkdownEmitter(ir);
      const markdown = emitter.emit();

      // Verify all major v3.1 components are working together
      expect(markdown).toContain('PROJECT=$(cat');
      expect(markdown).toContain('ROADMAP=$(cat');
      expect(markdown).toContain('CONTEXT=$(cat');
      expect(markdown).toContain('2>/dev/null');
      expect(markdown).toContain('<project_context>');
      expect(markdown).toContain('<roadmap>');
      expect(markdown).toContain('First, read');
      expect(markdown).toContain('gsd-planner.md');
      expect(markdown).toContain('On SUCCESS');
      expect(markdown).toContain('On BLOCKED');
      expect(markdown).toContain('On any other status');

      // Snapshot full output
      expect(markdown).toMatchSnapshot('full-v31-end-to-end');
    });
  });
});
```
  </action>
  <verify>
- npm run typecheck passes (or no type errors in test file)
- tests/composites/v31-integration.test.ts exists with describe blocks
- npm test -- tests/composites/v31-integration.test.ts runs and creates snapshots
  </verify>
  <done>v3.1 integration test file created with SpawnAgent, agent contracts, and end-to-end tests</done>
</task>

<task type="auto">
  <name>Task 2: Run tests and verify all pass</name>
  <files>
    tests/composites/v31-integration.test.ts
  </files>
  <action>
1. Run the new integration tests:
```bash
npm test -- tests/composites/v31-integration.test.ts
```

2. If any tests fail due to implementation issues:
   - Check if imports need adjustment (e.g., composites path)
   - Verify RuntimeMarkdownEmitter accepts config parameter
   - Update test assertions if output format differs from expected

3. Run full test suite to ensure no regressions:
```bash
npm test
```

4. If snapshot tests fail on first run (because snapshots don't exist yet):
   - Review the output to ensure it's correct
   - Update snapshots: `npm test -- tests/composites/v31-integration.test.ts -u`

5. Commit if all tests pass.
  </action>
  <verify>
- npm test passes (all tests green)
- Snapshots created in tests/composites/__snapshots__/v31-integration.test.ts.snap
- No regressions in existing tests
  </verify>
  <done>All v3.1 integration tests pass with valid snapshots</done>
</task>

</tasks>

<verification>
```bash
# Run new integration tests
npm test -- tests/composites/v31-integration.test.ts

# Run full test suite to ensure no regressions
npm test

# Verify snapshot file was created
ls tests/composites/__snapshots__/v31-integration.test.ts.snap

# View snapshot contents
cat tests/composites/__snapshots__/v31-integration.test.ts.snap | head -100
```
</verification>

<success_criteria>
1. tests/composites/v31-integration.test.ts exists with comprehensive tests
2. SpawnAgent self-reading tests pass (basic, custom path, false, error)
3. Agent contract component tests pass
4. MetaPrompt + SpawnAgent integration tests pass
5. OnStatus handling tests pass
6. Full end-to-end scenario tests pass
7. All snapshots are valid and capture expected output
8. No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/37-spawnagent-enhancement-integration/37-02-SUMMARY.md`
</output>
