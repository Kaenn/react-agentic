---
phase: 02-core-transpilation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/parser/transformer.ts
  - src/parser/index.ts
  - tests/parser/transformer.test.ts
autonomous: true

must_haves:
  truths:
    - "TSX <h1>-<h6> elements transform to HeadingNode with correct level"
    - "TSX <p> elements transform to ParagraphNode with inline children"
    - "TSX text content transforms to TextNode with normalized whitespace"
    - "TSX <b>/<strong> transform to BoldNode"
    - "TSX <i>/<em> transform to ItalicNode"
    - "TSX <code> (inline) transforms to InlineCodeNode"
    - "TSX <br> transforms to LineBreakNode"
    - "TSX <hr> transforms to ThematicBreakNode"
  artifacts:
    - path: "src/parser/transformer.ts"
      provides: "JSX to IR transformation for basic elements"
      exports: ["Transformer", "transform"]
    - path: "tests/parser/transformer.test.ts"
      provides: "Transformer unit tests"
      min_lines: 100
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/parser/parser.ts"
      via: "getElementName, getJsxChildren, extractText imports"
      pattern: "import.*from './parser.js'"
    - from: "src/parser/transformer.ts"
      to: "src/ir/nodes.ts"
      via: "IR node type imports"
      pattern: "import.*from '../ir/index.js'"
---

<objective>
Implement transformer for basic HTML-like elements: headings, paragraphs, and text formatting.

Purpose: Convert JSX AST nodes to IR nodes for the most common document elements. This establishes the transformation pattern that Phase 2 Plan 3 will extend.

Output: Transformer class that converts h1-h6, p, b/strong, i/em, code, br, hr elements to their IR equivalents.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-transpilation/02-RESEARCH.md
@.planning/phases/02-core-transpilation/02-CONTEXT.md
@.planning/phases/02-core-transpilation/02-01-SUMMARY.md
@src/ir/nodes.ts
@src/parser/parser.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Transformer class with heading and paragraph support</name>
  <files>
    - src/parser/transformer.ts
    - src/parser/index.ts
  </files>
  <action>
1. Create `src/parser/transformer.ts`:

```typescript
import { Node, JsxElement, JsxSelfClosingElement, JsxText, JsxExpression, JsxFragment } from 'ts-morph';
import type { BlockNode, InlineNode, DocumentNode, HeadingNode, ParagraphNode, TextNode } from '../ir/index.js';
import { getElementName, extractText, getJsxChildren } from './parser.js';

export class Transformer {
  /**
   * Transform a root JSX element/fragment into a DocumentNode
   */
  transform(node: JsxElement | JsxSelfClosingElement | JsxFragment): DocumentNode {
    const blocks = this.transformChildren(node);
    return { kind: 'document', children: blocks };
  }

  private transformChildren(node: JsxElement | JsxFragment): BlockNode[] {
    const children = Node.isJsxFragment(node)
      ? node.getJsxChildren()
      : node.getJsxChildren();

    const blocks: BlockNode[] = [];
    for (const child of children) {
      const block = this.transformToBlock(child);
      if (block) blocks.push(block);
    }
    return blocks;
  }

  private transformToBlock(node: Node): BlockNode | null {
    if (Node.isJsxText(node)) {
      // Whitespace-only text between block elements - skip
      const text = extractText(node);
      if (!text) return null;
      // Standalone text becomes paragraph
      return { kind: 'paragraph', children: [{ kind: 'text', value: text }] };
    }

    if (Node.isJsxElement(node) || Node.isJsxSelfClosingElement(node)) {
      const name = getElementName(node);
      return this.transformElement(name, node);
    }

    return null; // JsxExpression etc - handle later
  }

  private transformElement(name: string, node: JsxElement | JsxSelfClosingElement): BlockNode | null {
    // Heading elements
    const headingMatch = name.match(/^h([1-6])$/);
    if (headingMatch) {
      const level = parseInt(headingMatch[1], 10) as 1|2|3|4|5|6;
      const children = Node.isJsxElement(node)
        ? this.transformInlineChildren(node)
        : [];
      return { kind: 'heading', level, children };
    }

    // Paragraph
    if (name === 'p') {
      const children = Node.isJsxElement(node)
        ? this.transformInlineChildren(node)
        : [];
      return { kind: 'paragraph', children };
    }

    // Self-closing hr
    if (name === 'hr') {
      return { kind: 'thematicBreak' };
    }

    throw new Error(`Unsupported block element: <${name}>`);
  }

  private transformInlineChildren(node: JsxElement): InlineNode[] {
    const children = node.getJsxChildren();
    const inlines: InlineNode[] = [];

    for (const child of children) {
      const inline = this.transformToInline(child);
      if (inline) inlines.push(inline);
    }

    return inlines;
  }

  private transformToInline(node: Node): InlineNode | null {
    if (Node.isJsxText(node)) {
      const text = extractText(node);
      if (!text) return null;
      return { kind: 'text', value: text };
    }

    if (Node.isJsxSelfClosingElement(node)) {
      const name = getElementName(node);
      if (name === 'br') {
        return { kind: 'lineBreak' };
      }
      throw new Error(`Unsupported inline self-closing element: <${name}>`);
    }

    if (Node.isJsxElement(node)) {
      const name = getElementName(node);
      return this.transformInlineElement(name, node);
    }

    return null;
  }

  private transformInlineElement(name: string, node: JsxElement): InlineNode {
    // Bold
    if (name === 'b' || name === 'strong') {
      return { kind: 'bold', children: this.transformInlineChildren(node) };
    }

    // Italic
    if (name === 'i' || name === 'em') {
      return { kind: 'italic', children: this.transformInlineChildren(node) };
    }

    // Inline code
    if (name === 'code') {
      // Inline code: extract raw text content
      const text = this.extractAllText(node);
      return { kind: 'inlineCode', value: text };
    }

    throw new Error(`Unsupported inline element: <${name}>`);
  }

  private extractAllText(node: JsxElement): string {
    // Recursively extract all text content from children
    const parts: string[] = [];
    for (const child of node.getJsxChildren()) {
      if (Node.isJsxText(child)) {
        const text = extractText(child);
        if (text) parts.push(text);
      }
    }
    return parts.join('');
  }
}

export function transform(node: JsxElement | JsxSelfClosingElement | JsxFragment): DocumentNode {
  const transformer = new Transformer();
  return transformer.transform(node);
}
```

2. Update `src/parser/index.ts` to export transformer functions:
   ```typescript
   export * from './parser.js';
   export * from './transformer.js';
   ```
  </action>
  <verify>
    - `pnpm typecheck` passes
    - Transformer class compiles without errors
  </verify>
  <done>
    - Transformer class exists with transform method
    - Handles h1-h6 -> HeadingNode
    - Handles p -> ParagraphNode
    - Handles text -> TextNode (normalized)
    - Handles b/strong -> BoldNode
    - Handles i/em -> ItalicNode
    - Handles code -> InlineCodeNode
    - Handles br -> LineBreakNode
    - Handles hr -> ThematicBreakNode
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive transformer tests</name>
  <files>
    - tests/parser/transformer.test.ts
  </files>
  <action>
Create `tests/parser/transformer.test.ts` with tests for all supported elements:

1. **Headings tests:**
   - h1 through h6 produce correct level
   - Heading with text content
   - Heading with inline formatting (bold, italic)

2. **Paragraph tests:**
   - Simple paragraph with text
   - Paragraph with mixed inline content
   - Paragraph with normalized whitespace

3. **Text formatting tests:**
   - `<b>text</b>` -> bold
   - `<strong>text</strong>` -> bold
   - `<i>text</i>` -> italic
   - `<em>text</em>` -> italic
   - `<code>text</code>` -> inlineCode
   - Nested: `<b><i>text</i></b>` -> bold containing italic

4. **Self-closing elements:**
   - `<br />` -> lineBreak
   - `<hr />` -> thematicBreak

5. **Whitespace handling:**
   - Multiple spaces collapse to single space
   - Leading/trailing whitespace trimmed
   - Whitespace-only text nodes filtered

6. **End-to-end:**
   - Full document with multiple elements
   - Verify emitting transformed document produces valid Markdown

Use the pattern:
```typescript
import { createProject, parseSource, findRootJsxElement } from '../../src/parser/index.js';
import { Transformer } from '../../src/parser/transformer.js';
import { emit } from '../../src/emitter/index.js';

describe('Transformer', () => {
  const project = createProject();

  function transformTsx(tsx: string) {
    const source = parseSource(project, tsx, 'test.tsx');
    const root = findRootJsxElement(source);
    if (!root) throw new Error('No JSX found');
    const transformer = new Transformer();
    return transformer.transform(root);
  }

  // ... tests
});
```
  </action>
  <verify>
    - `pnpm test:run` passes all transformer tests
    - Tests cover all supported elements
  </verify>
  <done>
    - At least 15 test cases covering all basic elements
    - Edge cases tested (whitespace, nesting, multiple elements)
    - End-to-end test verifies parse -> transform -> emit pipeline
  </done>
</task>

<task type="auto">
  <name>Task 3: Add error handling for unsupported elements</name>
  <files>
    - src/parser/transformer.ts
    - tests/parser/transformer.test.ts
  </files>
  <action>
1. Ensure transformer throws descriptive errors for:
   - Unsupported block elements (throw with element name)
   - Unsupported inline elements (throw with element name)
   - Invalid nesting (e.g., block element inside inline context)

2. Add tests for error cases:
   - `<div>content</div>` throws "Unsupported block element: <div>"
   - `<span>content</span>` inside paragraph throws unsupported
   - Verify error messages include the element name

3. Per CONTEXT.md: "Unsupported elements: pass through raw HTML with warning"
   - RECONSIDER: For Phase 2, throwing is cleaner. Phase 3 adds XmlBlock support which will handle div elements.
   - For now: throw on unsupported, document that Phase 3 relaxes this

Note: The CONTEXT.md says "pass through raw HTML with warning" but that's complex to implement in Phase 2. For this phase, we throw on unsupported elements. Phase 3 will add proper handling when XmlBlock is implemented.
  </action>
  <verify>
    - `pnpm test:run` passes
    - Error tests verify descriptive messages
  </verify>
  <done>
    - Unsupported elements throw with clear error messages
    - Error includes element name for debugging
    - Tests verify error behavior
  </done>
</task>

</tasks>

<verification>
Run full verification:
```bash
pnpm typecheck && pnpm test:run
```

End-to-end verification - create a test file and verify full pipeline:
```typescript
const tsx = `export default () => (
  <>
    <h1>Hello World</h1>
    <p>This is <b>bold</b> and <i>italic</i> text.</p>
    <hr />
  </>
)`;
// Should produce:
// # Hello World
//
// This is **bold** and *italic* text.
//
// ---
```
</verification>

<success_criteria>
- Transformer handles all basic elements: h1-h6, p, b/strong, i/em, code, br, hr
- Text content is properly normalized (whitespace collapsed)
- Nested inline elements work (bold inside paragraph, italic inside bold)
- Error messages are descriptive for unsupported elements
- All tests pass
- Pipeline works: parse TSX -> transform to IR -> emit to Markdown
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-transpilation/02-02-SUMMARY.md`
</output>
