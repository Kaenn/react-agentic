---
phase: 02-core-transpilation
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/parser/transformer.ts
  - tests/parser/transformer.test.ts
autonomous: true

must_haves:
  truths:
    - "TSX <ul>/<ol> with <li> children transform to ListNode"
    - "Nested lists render with correct indentation"
    - "List items can contain inline formatting"
    - "TSX <blockquote> transforms to BlockquoteNode"
    - "TSX <pre><code> transforms to CodeBlockNode"
    - "TSX <a href='url'> transforms to LinkNode"
    - "Links without href throw descriptive error"
  artifacts:
    - path: "src/parser/transformer.ts"
      provides: "Complete element transformation for Phase 2"
      exports: ["Transformer", "transform"]
    - path: "tests/parser/transformer.test.ts"
      provides: "Comprehensive transformer tests"
      min_lines: 200
  key_links:
    - from: "src/parser/transformer.ts"
      to: "src/parser/parser.ts"
      via: "getAttributeValue import for href extraction"
      pattern: "getAttributeValue"
    - from: "transform()"
      to: "emit()"
      via: "Integration test pipeline"
      pattern: "emit\\(.*transform"
---

<objective>
Complete Phase 2 element coverage with lists, blockquotes, code blocks, and links.

Purpose: Enable full document transformation capability for all HTML-like elements specified in Phase 2 scope.

Output: Complete transformer supporting ul, ol, li, blockquote, pre+code, and a elements.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-transpilation/02-RESEARCH.md
@.planning/phases/02-core-transpilation/02-CONTEXT.md
@.planning/phases/02-core-transpilation/02-02-SUMMARY.md
@src/ir/nodes.ts
@src/parser/parser.ts
@src/parser/transformer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add list transformation (ul, ol, li)</name>
  <files>
    - src/parser/transformer.ts
    - tests/parser/transformer.test.ts
  </files>
  <action>
1. Update `src/parser/transformer.ts` to handle lists:

In `transformElement`, add cases:
```typescript
// Unordered list
if (name === 'ul') {
  return this.transformList(node, false);
}

// Ordered list
if (name === 'ol') {
  return this.transformList(node, true);
}
```

Add new method:
```typescript
private transformList(node: JsxElement | JsxSelfClosingElement, ordered: boolean): ListNode {
  if (Node.isJsxSelfClosingElement(node)) {
    return { kind: 'list', ordered, items: [] };
  }

  const items: ListItemNode[] = [];
  for (const child of node.getJsxChildren()) {
    if (Node.isJsxElement(child)) {
      const childName = getElementName(child);
      if (childName === 'li') {
        items.push(this.transformListItem(child));
      } else {
        throw new Error(`Expected <li> inside list, got <${childName}>`);
      }
    } else if (Node.isJsxText(child) && !child.containsOnlyTriviaWhiteSpaces()) {
      throw new Error('Lists can only contain <li> elements');
    }
    // Skip whitespace-only text nodes
  }

  return { kind: 'list', ordered, items };
}

private transformListItem(node: JsxElement): ListItemNode {
  // List items can contain blocks (paragraphs, nested lists)
  const children: BlockNode[] = [];

  for (const child of node.getJsxChildren()) {
    if (Node.isJsxText(child)) {
      const text = extractText(child);
      if (text) {
        // Plain text in li becomes paragraph
        children.push({ kind: 'paragraph', children: [{ kind: 'text', value: text }] });
      }
    } else if (Node.isJsxElement(child) || Node.isJsxSelfClosingElement(child)) {
      const childName = getElementName(child);

      // Check if it's a nested list
      if (childName === 'ul' || childName === 'ol') {
        const nestedList = this.transformElement(childName, child);
        if (nestedList) children.push(nestedList);
      } else if (childName === 'p') {
        // Explicit paragraph
        const para = this.transformElement(childName, child);
        if (para) children.push(para);
      } else {
        // Inline elements get wrapped in implicit paragraph
        const inline = Node.isJsxSelfClosingElement(child)
          ? this.transformToInline(child)
          : this.transformInlineElement(childName, child);
        if (inline) {
          // Merge into last paragraph if possible
          const lastChild = children[children.length - 1];
          if (lastChild?.kind === 'paragraph') {
            lastChild.children.push(inline);
          } else {
            children.push({ kind: 'paragraph', children: [inline] });
          }
        }
      }
    }
  }

  return { kind: 'listItem', children };
}
```

2. Add tests for lists:
   - Simple unordered list: `<ul><li>item</li></ul>`
   - Simple ordered list: `<ol><li>first</li><li>second</li></ol>`
   - List item with inline formatting: `<li><b>bold</b> text</li>`
   - Nested list: `<ul><li>parent<ul><li>child</li></ul></li></ul>`
   - Deeply nested lists (3 levels)
   - Mixed ordered/unordered nesting
  </action>
  <verify>
    - `pnpm test:run` passes
    - List tests verify correct nesting and ordering
  </verify>
  <done>
    - ul/ol elements transform to ListNode with correct ordered flag
    - li elements transform to ListItemNode with block children
    - Nested lists work correctly
    - Inline content in li items is properly wrapped
  </done>
</task>

<task type="auto">
  <name>Task 2: Add blockquote and code block transformation</name>
  <files>
    - src/parser/transformer.ts
    - tests/parser/transformer.test.ts
  </files>
  <action>
1. Add blockquote handling in `transformElement`:
```typescript
if (name === 'blockquote') {
  return this.transformBlockquote(node);
}
```

Add method:
```typescript
private transformBlockquote(node: JsxElement | JsxSelfClosingElement): BlockquoteNode {
  if (Node.isJsxSelfClosingElement(node)) {
    return { kind: 'blockquote', children: [] };
  }

  const children: BlockNode[] = [];
  for (const child of node.getJsxChildren()) {
    const block = this.transformToBlock(child);
    if (block) children.push(block);
  }

  return { kind: 'blockquote', children };
}
```

2. Add code block handling (pre containing code):
```typescript
if (name === 'pre') {
  return this.transformCodeBlock(node);
}
```

Add method:
```typescript
private transformCodeBlock(node: JsxElement | JsxSelfClosingElement): CodeBlockNode {
  if (Node.isJsxSelfClosingElement(node)) {
    return { kind: 'codeBlock', content: '' };
  }

  // Look for <code> child with optional language
  const children = node.getJsxChildren();
  for (const child of children) {
    if (Node.isJsxElement(child) && getElementName(child) === 'code') {
      const language = getAttributeValue(
        child.getOpeningElement(),
        'className'
      )?.replace(/^language-/, '');

      // Extract raw text content preserving whitespace
      const content = this.extractCodeContent(child);
      return { kind: 'codeBlock', language, content };
    }
  }

  // Pre without code child - extract text directly
  const content = this.extractCodeContent(node);
  return { kind: 'codeBlock', content };
}

private extractCodeContent(node: JsxElement): string {
  // Preserve whitespace in code blocks - don't normalize
  const parts: string[] = [];
  for (const child of node.getJsxChildren()) {
    if (Node.isJsxText(child)) {
      parts.push(child.getText());
    }
  }
  // Trim only the outermost whitespace (leading/trailing)
  return parts.join('').trim();
}
```

3. Add tests:
   - Simple blockquote: `<blockquote><p>quote</p></blockquote>`
   - Blockquote with multiple paragraphs
   - Nested blockquotes
   - Code block: `<pre><code>code here</code></pre>`
   - Code block with language: `<pre><code className="language-typescript">...</code></pre>`
   - Code block preserves whitespace and indentation
  </action>
  <verify>
    - `pnpm test:run` passes
    - Code blocks preserve exact content
    - Language is extracted from className
  </verify>
  <done>
    - blockquote -> BlockquoteNode with block children
    - pre/code -> CodeBlockNode with language extraction
    - Code content preserves whitespace (not normalized)
    - Language extracted from `className="language-x"` pattern
  </done>
</task>

<task type="auto">
  <name>Task 3: Add link transformation and end-to-end tests</name>
  <files>
    - src/parser/transformer.ts
    - tests/parser/transformer.test.ts
  </files>
  <action>
1. Add link handling in `transformInlineElement`:
```typescript
if (name === 'a') {
  return this.transformLink(node);
}
```

Add method:
```typescript
private transformLink(node: JsxElement): LinkNode {
  const href = getAttributeValue(node.getOpeningElement(), 'href');
  if (!href) {
    throw new Error('<a> element requires href attribute');
  }

  const children = this.transformInlineChildren(node);
  return { kind: 'link', url: href, children };
}
```

2. Add link tests:
   - Simple link: `<a href="url">text</a>`
   - Link with inline formatting: `<a href="url"><b>bold link</b></a>`
   - Link with JSX expression href: `<a href={"url"}>text</a>`
   - Missing href throws error
   - Empty href throws error (or is allowed? - check CONTEXT.md)

3. Create comprehensive end-to-end tests that verify full pipeline:

```typescript
describe('End-to-end transformation', () => {
  it('transforms complete document with all element types', () => {
    const tsx = `export default () => (
      <>
        <h1>Document Title</h1>
        <p>Intro paragraph with <b>bold</b> and <i>italic</i> text.</p>

        <h2>Lists Section</h2>
        <ul>
          <li>First item</li>
          <li>Second item with <code>code</code></li>
        </ul>

        <h2>Quote Section</h2>
        <blockquote>
          <p>This is a quote</p>
        </blockquote>

        <h2>Code Section</h2>
        <pre><code className="language-typescript">
const x = 1;
        </code></pre>

        <p>Visit <a href="https://example.com">our site</a> for more.</p>
        <hr />
      </>
    )`;

    const doc = transformTsx(tsx);
    const markdown = emit(doc);

    // Verify output structure
    expect(markdown).toContain('# Document Title');
    expect(markdown).toContain('**bold**');
    expect(markdown).toContain('*italic*');
    expect(markdown).toContain('- First item');
    expect(markdown).toContain('> This is a quote');
    expect(markdown).toContain('```typescript');
    expect(markdown).toContain('[our site](https://example.com)');
    expect(markdown).toContain('---');
  });
});
```
  </action>
  <verify>
    - `pnpm test:run` passes all tests
    - `pnpm typecheck` passes
    - End-to-end test verifies complete document transformation
  </verify>
  <done>
    - Links transform with href attribute extracted
    - Missing href throws clear error
    - All Phase 2 elements work in combination
    - Full pipeline (parse -> transform -> emit) produces valid Markdown
    - Phase 2 requirements CORE-01 and CORE-03 are satisfied
  </done>
</task>

</tasks>

<verification>
Run full verification suite:
```bash
pnpm typecheck && pnpm test:run
```

Create sample TSX file and verify complete transformation:
```bash
# Create test file
cat > /tmp/test-command.tsx << 'EOF'
export default () => (
  <>
    <h1>My Command</h1>
    <p>This command does <b>important</b> things.</p>
    <ul>
      <li>First capability</li>
      <li>Second capability with <code>code</code></li>
    </ul>
    <blockquote><p>A wise quote</p></blockquote>
    <pre><code className="language-bash">echo "hello"</code></pre>
    <p>See <a href="https://docs.example.com">documentation</a>.</p>
  </>
);
EOF
```

Expected output includes all transformed elements.
</verification>

<success_criteria>
Phase 2 complete when:
- All HTML-like elements transform correctly:
  - Headings: h1-h6 -> HeadingNode
  - Paragraph: p -> ParagraphNode
  - Text formatting: b/strong, i/em, code -> Bold/Italic/InlineCode
  - Links: a with href -> LinkNode
  - Lists: ul/ol with li -> ListNode (nested supported)
  - Blockquotes: blockquote -> BlockquoteNode
  - Code blocks: pre/code -> CodeBlockNode (with language)
  - Line breaks: br -> LineBreakNode
  - Horizontal rule: hr -> ThematicBreakNode
- Text content preserved through parse->transform->emit
- Nested elements render correctly (bold in lists, formatting in links)
- Unsupported elements throw descriptive errors
- All tests pass
- Requirements CORE-01 and CORE-03 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-transpilation/02-03-SUMMARY.md`
</output>
