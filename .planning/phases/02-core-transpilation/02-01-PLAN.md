---
phase: 02-core-transpilation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/parser/parser.ts
  - src/parser/index.ts
  - src/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "ts-morph can parse TSX files and extract JSX AST"
    - "Parser can identify root-level JSX elements in a TSX file"
    - "Parser can traverse JSX children recursively"
  artifacts:
    - path: "src/parser/parser.ts"
      provides: "ts-morph Project wrapper and JSX traversal"
      exports: ["createProject", "parseFile", "getRootJsxElement"]
    - path: "src/parser/index.ts"
      provides: "Parser module exports"
    - path: "package.json"
      provides: "ts-morph dependency"
      contains: "ts-morph"
  key_links:
    - from: "src/parser/parser.ts"
      to: "ts-morph"
      via: "import { Project, Node } from 'ts-morph'"
      pattern: "import.*from 'ts-morph'"
---

<objective>
Set up ts-morph parser infrastructure for parsing TSX files and extracting JSX AST nodes.

Purpose: Establish the parsing foundation that transformer will build upon. The parser provides JSX element traversal, attribute extraction, and child node access.

Output: `src/parser/` module with ts-morph Project wrapper and JSX traversal utilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-transpilation/02-RESEARCH.md
@.planning/phases/02-core-transpilation/02-CONTEXT.md
@src/ir/nodes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install ts-morph and create parser module</name>
  <files>
    - package.json
    - src/parser/parser.ts
    - src/parser/index.ts
    - src/index.ts
  </files>
  <action>
1. Install ts-morph:
   ```bash
   pnpm add ts-morph
   ```

2. Create `src/parser/parser.ts` with:
   - `createProject()`: Returns a ts-morph Project configured for JSX parsing
     - compilerOptions: jsx: JsxEmit.Preserve, target: ESNext, module: ESNext
   - `parseFile(project: Project, filePath: string)`: Adds source file and returns SourceFile
   - `parseSource(project: Project, source: string, fileName?: string)`: Parses in-memory TSX string

3. Create `src/parser/index.ts` - re-export all from parser.ts

4. Update `src/index.ts` - add `export * from './parser/index.js'`

Follow ESM conventions (import from 'ts-morph', .js extensions on local imports).
  </action>
  <verify>
    - `pnpm typecheck` passes
    - `import { createProject } from './parser/index.js'` works
  </verify>
  <done>
    - ts-morph installed and visible in package.json dependencies
    - parser.ts exports createProject and parseFile functions
    - Project compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add JSX traversal utilities and element extraction</name>
  <files>
    - src/parser/parser.ts
    - tests/parser/parser.test.ts
  </files>
  <action>
1. Add to `src/parser/parser.ts`:
   - `getElementName(node: JsxElement | JsxSelfClosingElement): string`
     - For JsxElement: `node.getOpeningElement().getTagNameNode().getText()`
     - For JsxSelfClosingElement: `node.getTagNameNode().getText()`

   - `getJsxChildren(node: JsxElement): (JsxElement | JsxSelfClosingElement | JsxText | JsxExpression)[]`
     - Returns `node.getJsxChildren()` typed appropriately

   - `getAttributeValue(element: JsxOpeningElement | JsxSelfClosingElement, name: string): string | undefined`
     - Gets attribute by name
     - Handles string literals: `attr="value"` -> returns "value"
     - Handles JSX expressions with string literals: `attr={"value"}` -> returns "value"
     - Returns undefined if attribute missing or non-string

   - `findRootJsxElement(sourceFile: SourceFile): JsxElement | JsxSelfClosingElement | JsxFragment | null`
     - Finds the JSX element returned by the default export function
     - Uses forEachDescendant to find ReturnStatement containing JSX
     - Returns null if no JSX found

2. Create `tests/parser/parser.test.ts`:
   - Test createProject returns valid Project
   - Test parseSource with simple TSX
   - Test getElementName for both JsxElement and JsxSelfClosingElement
   - Test getAttributeValue with string literal and JSX expression
   - Test findRootJsxElement extracts JSX from function return

Use inline snapshots where appropriate. Follow existing test patterns from tests/emitter/.
  </action>
  <verify>
    - `pnpm test:run` passes all new parser tests
    - `pnpm typecheck` passes
  </verify>
  <done>
    - getElementName correctly extracts tag names
    - getAttributeValue handles both `attr="x"` and `attr={"x"}` syntax
    - findRootJsxElement locates JSX in function return statements
    - All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Add whitespace-aware text extraction</name>
  <files>
    - src/parser/parser.ts
    - tests/parser/parser.test.ts
  </files>
  <action>
1. Add to `src/parser/parser.ts`:
   - `isWhitespaceOnlyText(node: JsxText): boolean`
     - Returns `node.containsOnlyTriviaWhiteSpaces()`

   - `normalizeWhitespace(text: string): string`
     - Collapse multiple spaces/newlines to single space
     - Trim leading and trailing whitespace
     - Implementation: `text.replace(/\s+/g, ' ').trim()`

   - `extractText(node: JsxText): string | null`
     - If whitespace only, return null
     - Otherwise return normalizeWhitespace(node.getText())

2. Add tests in `tests/parser/parser.test.ts`:
   - Test isWhitespaceOnlyText returns true for formatting whitespace
   - Test normalizeWhitespace collapses multiple spaces
   - Test extractText filters whitespace-only and normalizes content
   - Test with real JSX examples:
     ```tsx
     <p>
       Hello    world
     </p>
     ```
     Should extract "Hello world" (normalized)
  </action>
  <verify>
    - `pnpm test:run` passes all tests
    - `pnpm typecheck` passes
  </verify>
  <done>
    - Whitespace-only JSX text nodes are correctly identified
    - Text content is normalized (collapsed spaces, trimmed)
    - Parser is ready for transformer to use
  </done>
</task>

</tasks>

<verification>
Run all checks:
```bash
pnpm typecheck && pnpm test:run
```

Manual verification:
- Create a test TSX file and verify parser can extract elements
- Check that ts-morph is in dependencies (not devDependencies - it's a runtime dependency)
</verification>

<success_criteria>
- ts-morph installed as production dependency
- Parser module exports: createProject, parseFile, parseSource, getElementName, getAttributeValue, findRootJsxElement, extractText
- All utilities handle edge cases (self-closing elements, missing attributes, whitespace)
- Parser tests pass with 100% coverage of exported functions
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-transpilation/02-01-SUMMARY.md`
</output>
